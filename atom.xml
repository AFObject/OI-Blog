<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[OI Blog]]></title>
  <link href="oi.afobject.ml/atom.xml" rel="self"/>
  <link href="oi.afobject.ml/"/>
  <updated>2022-01-16T13:55:55+08:00</updated>
  <id>oi.afobject.ml/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[0xff 算法竞赛进阶指南]]></title>
    <link href="oi.afobject.ml/overview.html"/>
    <updated>2022-01-07T23:06:53+08:00</updated>
    <id>oi.afobject.ml/overview.html</id>
    <content type="html"><![CDATA[
<hr />
<ul>
<li><c>0x0101</c> 表示题目编号。根据书后索引编号或直接写题目来源。</li>
<li><e>Easy</e> 我能很快做出来的题目。<br />
大约对应红 ～ 黄，典型题目：NOIP 2021 A。</li>
<li><m>Medium</m> 我需要充足的思考才能做出来或者能轻易理解思路的题目。<br />
大约对应思维黄 ～ 下位蓝，典型题目：CSP-S 2021 A。</li>
<li><h>Hard</h> 我看题解都蚌埠住的那种。<br />
大约对应上位蓝到黑。</li>
</ul>
<hr />
<ul>
<li>0x00 基本算法</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x00 基本算法]]></title>
    <link href="oi.afobject.ml/0x00.html"/>
    <updated>2022-01-07T23:05:09+08:00</updated>
    <id>oi.afobject.ml/0x00.html</id>
    <content type="html"><![CDATA[
<ul>
<li>0x01 位运算</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x01 位运算]]></title>
    <link href="oi.afobject.ml/0x01.html"/>
    <updated>2022-01-08T11:01:10+08:00</updated>
    <id>oi.afobject.ml/0x01.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E8%A1%A5%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>补码</h2>
<ul>
<li>对于 <code>unsigned int</code>：补码等于原码。</li>
<li>对于 <code>signed int</code>：正数部分补码等于原码，负数部分 \([-2^{31}, -1]\) 相当于 <code>unsigned int</code> \([2^{31}+1, 2^{32}]\)。即原来的<strong>负数的绝对值减去 1 后取反</strong>。<br />
\(-45 \to -(00101101)_2 \to \operatorname{rev}(00101101-1)_2 \to (11010011)_2\)。</li>
</ul>
<hr />
<h2><a id="%E6%88%90%E5%AF%B9%E5%8F%98%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>成对变换</h2>
<p>\((0,1), (2,3), (4,5)\) 这些二元组中的一个数可以通过 <code>xor</code> 运算得到另一个数。应用：双向边邻接表。</p>
<hr />
<h2><a id="lowbit%E8%BF%90%E7%AE%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>lowbit 运算</h2>
<p>lowbit 是<strong>二进制下最低位的 1 及其右边的所有 0 构成的数值</strong>。</p>
\[\operatorname{lowbit}(n)=n\ \&amp;\ (-n)
\]
<p>应用：哈希、树状数组等。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x02 递推与递归]]></title>
    <link href="oi.afobject.ml/16422139834989.html"/>
    <updated>2022-01-15T10:33:03+08:00</updated>
    <id>oi.afobject.ml/16422139834989.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E5%AE%8F%E8%A7%82%E6%8F%8F%E8%BF%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>宏观描述</h2>
<h3><a id="%E9%80%92%E5%BD%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>递归</h3>
<p>从原大问题出发到小问题，然后将小问题推广到大问题。</p>
<p>缩小、求解、扩展。</p>
<p>Key Points：</p>
<ul>
<li>自身调用自身</li>
<li>回溯时还原现场。</li>
</ul>
<h3><a id="%E9%80%92%E6%8E%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>递推</h3>
<p>正向，由小问题直接推到大问题。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x011 位运算基础]]></title>
    <link href="oi.afobject.ml/0x011.html"/>
    <updated>2022-01-07T22:44:17+08:00</updated>
    <id>oi.afobject.ml/0x011.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E5%BF%AB%E9%80%9F%E5%B9%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>快速幂</h2>
<p><tc><c>0x0101</c><e>Easy-</e><t>快速幂</t></tc></p>
<p>求 \(a^b \bmod p\) 的值。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>\(b\) 可以拆分为这样的二进制：\(b=\sum\limits_{i=0}^{n-1} k_i \times 2^i\)（\(k_i \in \{0, 1\}\)）。</p>
<p>因此 \(a^b = \prod\limits_{i=0}^{n-1} a^{k_i \times 2^{i}}\)。</p>
<p>可以看成递推：\(p_i=a^{2^i}\)，则 \(a^b = \prod\limits_{i=0}^{n-1} p_{i}^{k_i}\)，其中 \(p_{i}= p_{i-1}^2\)。</p>
<p>做的时候直接把数组免了。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int pow(int a, int b, int p) {
	int ans = 1 % p;
	while (b) {
		if (b &amp; 1)
			ans = (ans * a) % p;
		a = (a * a) % p;
		b &gt;&gt;= 1;
	}
	return ans;
}
</code></pre>
<hr />
<h2><a id="raising-modulo-numbers" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Raising Modulo Numbers</h2>
<p><tc><c>0x0102</c><e>Easy-</e><t>快速幂</t></tc></p>
<p>给你 \(N\) 组数，让你求 \(\sum a_i^{b_i} \bmod M\)（\(N, M \le 4.5 \times 10^4\)）。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>暴力。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n, p, a, b, T;
signed main() {
	T = read();
	while (T--) {
		p = read(), n = read();
		int ans = 0;
		while (n--) {
			a = read(), b = read();
			ans = (ans + pow(a, b, p)) % p;
		}
		printf(&quot;%lld\n&quot;, ans);
	}
}
</code></pre>
<hr />
<h2><a id="64%E4%BD%8D%E6%95%B4%E6%95%B0%E4%B9%98%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>64 位整数乘法</h2>
<p><tc><c>0x0103</c><e>Easy-</e><t>快速幂</t></tc></p>
<p>求 \(a \times b \bmod p\) 的值。\(1 \le a,b,p \le 10^{18}\)。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>除非用 <code>__int128</code>，否则必须要将 \(a,b\) 拆分成更小的数再合并求积。这时就可以用到位运算了。</p>
<p>和快速幂几乎完全一样，改几个符号而已。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int mul(int a, int b, int p) {
	int ans = 0;
	while (b) {
		if (b &amp; 1)
			ans = (ans + a) % p;
		a = (a &lt;&lt; 1) % p;
		b &gt;&gt;= 1;
	}
	return ans;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x021 递推与递归的简单应用]]></title>
    <link href="oi.afobject.ml/16422141961714.html"/>
    <updated>2022-01-15T10:36:36+08:00</updated>
    <id>oi.afobject.ml/16422141961714.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8C%87%E6%95%B0%E5%9E%8B%E6%9E%9A%E4%B8%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>递归实现指数型枚举</h2>
<p><tc><c>0x0201</c><e>Easy-</e><t>递归</t><t>搜索</t></tc></p>
<pre class="line-numbers"><code class="language-cpp">bool c[21];
void recursive(int t) {
	if (t == n + 1) {
		for (int i = 1; i &lt;= n; ++i)
			if (c[i])
				printf(&quot;%d &quot;, i);
		putchar('\n');
		return;
	}
	c[t] = true;
	recursive(t + 1);
	c[t] = false;
	recursive(t + 1);
}
</code></pre>
<h2><a id="%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E7%BB%84%E5%90%88%E5%9E%8B%E6%9E%9A%E4%B8%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>递归实现组合型枚举</h2>
<p><tc><c>0x0202</c><e>Easy-</e><t>递归</t><t>搜索</t></tc></p>
<pre class="line-numbers"><code class="language-cpp">bool c[21];
void recursive(int t, int sel) {
	if (sel &gt; m || sel + n - t + 1 &lt; m)
		return;
	if (t == n + 1) {
		for (int i = 1; i &lt;= n; ++i)
			if (c[i])
				printf(&quot;%d &quot;, i);
		putchar('\n');
		return;
	}
	c[t] = true;
	recursive(t + 1, sel + 1);
	c[t] = false;
	recursive(t + 1, sel);
}
</code></pre>
<h2><a id="%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%88%97%E5%9E%8B%E6%9E%9A%E4%B8%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>递归实现排列型枚举</h2>
<p><tc><c>0x0203</c><e>Easy-</e><t>递归</t><t>搜索</t></tc></p>
<pre class="line-numbers"><code class="language-cpp">bool c[21];
int sel[21];
void recursive(int t) {
	if (t == n + 1) {
		for (int i = 1; i &lt;= n; ++i)
			printf(&quot;%d &quot;, sel[i]);
		putchar('\n');
		return;
	}
	for (int i = 1; i &lt;= n; ++i) {
		if (!c[i]) {
			sel[t] = i;
			c[i] = true;
			recursive(t +  1);c[i] = false;
		}
	}
}
</code></pre>
<hr />
<h2><a id="%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>费解的开关</h2>
<p><tc><c>0x0204</c><m>Medium</m><t>结论</t><t>贪心</t></tc></p>
<p>\(5\times 5\) 的 01 矩阵中，点击一个位置，它及它上下左右格内的数都会变化，最少多少次点击变成全 0？</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p><strong>考虑特殊情况：</strong> 假如不能动第一行，则对于第一行的任意一个数，如果它是 1，那么只能点击它下面的那个格子。</p>
<p>又有：<strong>点击的顺序不影响最终的结果。</strong> 一个格子被翻转的次数等于它四周的格子被点按次数之和。所以可以以任意顺序考虑点击的位置。</p>
<p>因此只用枚举第一行的 \(2^5\) 种状态即可。后面的方案都是确定的。假如最后不都为 0 那么这种做法就是寄的，继续搜索求解。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>第一次在 OI 里写异常处理。</p>
<pre class="line-numbers"><code class="language-cpp">int T;
int m[7][7];
int t[7][7];

int cnt = 0;
void doOper(int x, int y) {
	t[x][y] ^= 1;
	t[x - 1][y] ^= 1;
	t[x + 1][y] ^= 1;
	t[x][y - 1] ^= 1;
	t[x][y + 1] ^= 1;
	++cnt;
	if (cnt &gt; 6)
		throw -1;
}

int main() {
	scanf(&quot;%d&quot;, &amp;T);
	while (T--) {
		for (int i = 1; i &lt;= 5; ++i)
			for (int j = 1; j &lt;= 5; ++j)
				scanf(&quot;%1d&quot;, &amp;m[i][j]);
		int ans = 0x3f3f3f3f;
		for (int s = 0; s &lt; 32; ++s) {
			cnt = 0;
			try {
				for (int i = 1; i &lt;= 5; ++i)
					for (int j = 1; j &lt;= 5; ++j)
						t[i][j] = m[i][j];
				for (int i = 1, s0 = s; s0; s0 &gt;&gt;= 1, ++i)
					if (s0 &amp; 1)
						doOper(1, i);
				for (int r = 2; r &lt;= 5; ++r) {
					for (int c = 1; c &lt;= 5; ++c)
						if (!t[r - 1][c])
							doOper(r, c);
				}
			} catch (int e) {
				continue;
			}
			int sum = 1;
			for (int i = 1; i &lt;= 5; ++i)
				sum &amp;= t[5][i];
			if (sum)
				ans = std::min(ans, cnt);
		}
		printf(&quot;%d\n&quot;, (ans == 0x3f3f3f3f) ? -1 : ans);
	}
	return 0;
}
</code></pre>
<hr />
<h2><a id="strange-towers-of-hanoi" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Strange Towers of Hanoi</h2>
<p><tc><c>0x0205</c><m>Medium</m><t>递推</t><t>DP</t></tc></p>
<p>求 \(n\) 盘 4 塔的汉诺塔步数。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>考虑 \(n\) 盘 3 塔：</p>
<ul>
<li>\(n-1\) 盘：A \(\to\) B</li>
<li>第 \(n\) 盘：A \(\to\) C</li>
<li>\(n-1\) 盘：B \(\to\) C</li>
</ul>
<p>因此 \(f_3(n)=2 \times f_3(n-1) + 1\)，其中 \(f_3(1)=1\)。可以知道 \(f_3(n)=2^n-1\)。</p>
<p>再考虑 \(n\) 盘 4 塔：</p>
\[f_4(n) \le \min_{1 \le i \lt n} \{2 \times f_4(i) + f_3(n-i)\}
\]
<p>注意此处使用小于等于号。</p>
<p>参照具体数学上证明等于的方法：</p>
<p>我们迟早都必须要移动最下面的那 \(n-i\) 个盘子移动到 D 柱，当我们这么做的时候，上面 \(i\) 个必须已经在某个柱子上。而把下面的这 \(n-i\) 个盘子摆好以后，又要用 \(f_4(i)\) 次移动将上面的盘子放置在它上方（胡言乱语 /tuu）。因此至少需要有 \(\min_{1 \le i \lt n} \{2 \times f_4(i) + f_3(n-i)\}\) 次移动。</p>
\[\therefore f_4(n) = \min_{1 \le i \lt n} \{2 \times f_4(i) + f_3(n-i)\}
\]
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">#define f3(x) ((1 &lt;&lt; (x)) - 1)

int f4[13];

int main() {
    f4[1] = 1;
    for (int x = 2; x &lt;= 12; ++x) {
    	f4[x] = 0x3f3f3f3f;
    	for (int i = 1; i &lt; x; ++i)
    		f4[x] = std::min(f4[x], 2 * f4[i] + f3(x - i));
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x012 二进制状态压缩]]></title>
    <link href="oi.afobject.ml/0x012.html"/>
    <updated>2022-01-07T22:44:57+08:00</updated>
    <id>oi.afobject.ml/0x012.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E6%9C%80%E7%9F%ADhamilton%E8%B7%AF%E5%BE%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>最短 Hamilton 路径</h2>
<p><tc><c>0x0104</c><c>LG1171</c><m>Medium</m><t>状压</t><t>DP</t></tc></p>
<p>在一张点数小于等于 \(20\) 的带权无向图中找出一条从 \(0\) 到 \(n-1\) <strong>不重不漏地经过每一个点</strong>且<strong>边权和最短</strong>的路径。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>很容易想到用一个二进制数来表示已路过的点的状态（路径状态）。</p>
<p>令 \(f(s,i)\) 为路径状态为 \(s\)，当前点在 \(i\) 的最短路。然后转移即可。</p>
\[f(s,i) = \min_{s' \to s}\{f(s',k) + w(k,i)\}
\]
<p>注意细节：\(s'\) 能通向 \(s\) 需要满足 <strong>\(k\) 包含在 \(s'\) 中</strong>，即 \(k\) 包含在 \(s\) 中且 \(k \neq i\)。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n;
int w[21][21];
int dis[1 &lt;&lt; 21][21];

int main() {
    memset(dis, 0x3f, sizeof dis);
	dis[1][0] = 0;
	for (int s = 2; s &lt; (1 &lt;&lt; n); ++s) {
		for (int i = 0; i &lt; n; ++i) {
			if (!((s &gt;&gt; i) &amp; 1)) continue; // 要求 s 包含 i。
			for (int k = 0; k &lt; n; ++k) { // 选择上一个点。
				if ((s &gt;&gt; k) &amp; 1 &amp;&amp; k != i) // 要求 s 包含 k 且 k 不等于 i。
					dis[s][i] = std::min(dis[s][i], dis[s ^ (1 &lt;&lt; i)][k] + w[k][i]);
			}
		}
	}
	printf(&quot;%d\n&quot;, dis[(1 &lt;&lt; n) - 1][n - 1]);
	return 0;
}
</code></pre>
<hr />
<h2><a id="%E8%B5%B7%E5%BA%8A%E5%9B%B0%E9%9A%BE%E7%BB%BC%E5%90%88%E7%97%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>起床困难综合症</h2>
<p><tc><c>0x0105</c><c>NOI 2014</c><m>Medium</m><t>位运算</t><t>贪心</t></tc></p>
<p>\([0, m]\) 之间选择一个数，使得经过 \(n\) 次位运算后值最大，求最大值。\(m \le 10^9\)，\(n \le 10^5\)。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>很牛的一点：<strong>题目中这些操作在二进制中都不会产生进位。</strong></p>
<p>所以每一位分讨，结果能是 1 就是 1，原数能是 0 就是 0（因为要满足 \(\le m\) 的条件）。</p>
<p>即如果只有填 1 结果才能是 1，且当前还 \(\le m\) 的情况下，就填 1。否则一律填 0。</p>
<p>从高到低分位讨论。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n, m, arg[1000001];
std::string op[1000001];

bool calc(int k, bool val) {
	for (int i = 1; i &lt;= n; ++i) {
		if (op[i] == &quot;AND&quot;)
			val &amp;= (arg[i] &gt;&gt; k) &amp; 1;
		else if (op[i] == &quot;OR&quot;)
			val |= (arg[i] &gt;&gt; k) &amp; 1;
		else
			val ^= (arg[i] &gt;&gt; k) &amp; 1;
	}
	return val;
}

int main() {
	std::cin &gt;&gt; n &gt;&gt; m;
	for (int i = 1; i &lt;= n; ++i)
		std::cin &gt;&gt; op[i] &gt;&gt; arg[i];
		
	int sel = 0, ans = 0;
	for (int i = 30; i &gt;= 0; --i) {
		if (sel + (1 &lt;&lt; i) &lt;= m &amp;&amp;
			calc(i, 0) == 0 &amp;&amp; calc(i, 1) == 1)
			sel += (1 &lt;&lt; i), ans += (1 &lt;&lt; i);
		else if (calc(i, 0))
			ans += (1 &lt;&lt; i);
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x022 分治]]></title>
    <link href="oi.afobject.ml/16422572946324.html"/>
    <updated>2022-01-15T22:34:54+08:00</updated>
    <id>oi.afobject.ml/16422572946324.html</id>
    <content type="html"><![CDATA[
<h2><a id="sumdiv" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sumdiv</h2>
<p><tc><c>0x0206</c><c>LG1593</c><m>Medium+</m><t>数论</t><t>分治</t><t>快速幂</t></tc></p>
<p>求 \(a^b\) 的因子和 \(\bmod 9901\)。\(a, b \le 5 \times 10^7\)。</p>
<h2><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h2>
<p>假设 \(a = \prod p_i^{c_i}\)，则 \(a^b=\prod p_i^{c_i \times b}\) 因子和为</p>
\[\prod{\sum_{k=0}^{c_i \times b} {p_i}^k}
\]
<p>求个 \(p\) 是 \(\sqrt a\) 级别的，现在要快速求 \(\sum_{k=0}^{c_i \times b} {p_i}^k\)。</p>
<p>考虑使用等比数列求和公式：</p>
\[\begin{aligned}
S&amp;=1+p+p^2+p^3+\cdots+p^k\\
p\cdot S&amp;=p+p^2+p^3+\cdots+p^k+p^{k+1}\\
S&amp;=\frac{p^{k+1}-1}{p-1}
\end{aligned}
\]
<p>但要取模所以不能除啊……</p>
<p>于是，开始分治（\(k \in \mathbb N\)）！</p>
\[\begin{aligned}
\sum_{i=0}^{2k+1}p^i &amp;= \sum_{i=0}^k p^i+ p^{k+1} \cdot \sum_{i=0}^k p^i \\
&amp;=(1+p^{k+1}) \cdot\sum_{i=0}^k p^i\\

\sum_{i=0}^{2k}p^i &amp;= \sum_{i=0}^{k-1} p^i+ p^{k} \cdot \sum_{i=0}^{k-1} p^i+p^{2k} \\
&amp;=(1+p^k) \cdot\sum_{i=0}^{k-1} p^i+p^{2k}
\end{aligned}
\]
<p>拆完了！\(\log\) 时间内可以求到结果。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>随时取模；特判个 \(0\)。</p>
<pre class="line-numbers"><code class="language-cpp">#define MOD 9901

int a, b;
std::map&lt;int, int&gt; m;

int pow(int a, int b, int p = MOD) {
	int ans = 1 % MOD;
	while (b) {
		if (b &amp; 1)
			ans = (ans * a) % MOD;
		a = (a * a) % MOD;
		b &gt;&gt;= 1;
	}
	return ans;
}

int sum(int p, int c) {
	if (c == 0) return 1;
	if (c == 1) return p + 1;
	const int k = c / 2;
	if (c &amp; 1) {
		const int t = (1 + pow(p, k + 1)) % MOD;
		return (t * sum(p, k)) % MOD;
	} else {
		const int t = (1 + pow(p, k)) % MOD;
		return (t * sum(p, k - 1) + pow(p, 2 * k)) % MOD; 
	}
}

int main() {
	a = read(), b = read();
	for (int i = 2; i * i &lt;= a; ) {
		if (a % i == 0)
			++m[i], a /= i;
		else
			++i;
	}
	if (a != 1)
		++m[a];
    if (!a) return puts(&quot;0&quot;), 0;
	int ans = 1;
	for (auto [p, k] : m) {
		ans = (ans * sum(p % MOD, k * b)) % MOD;
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
</code></pre>

]]></content>
  </entry>
  
</feed>
