<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[OI Blog]]></title>
  <link href="oi.afobject.ml/atom.xml" rel="self"/>
  <link href="oi.afobject.ml/"/>
  <updated>2022-06-12T23:36:23+08:00</updated>
  <id>oi.afobject.ml/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[0x15 字符串]]></title>
    <link href="oi.afobject.ml/0x15-.html"/>
    <updated>2022-07-03T23:13:38+08:00</updated>
    <id>oi.afobject.ml/0x15-.html</id>
    <content type="html"><![CDATA[
<h2><a id="0x151-kmp%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>0x151 KMP 模式匹配</h2>
<p>目的：匹配字符串 A 在字符串 B 中各次出现的位置。</p>
<h3><a id="%E4%B8%80%E4%BA%9B%E5%AE%9A%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一些定义</h3>
<p>\(S_{l\dots r}\)：S 字符串中 \([l,r]\) 范围内的子串。</p>
<p>\(next(i)\)：<strong>满足 \(A_{1 \ldots j}=A_{i-j+1\ldots i}\) 的最大的 \(j\)（\(0\le j&lt;i\)）</strong>。</p>
<pre class="line-numbers"><code class="language-text">   1  j       i
   |  |       |
A: ABCD....ABCD....
</code></pre>
<p>为了方便表述，称 \(A_{1 \ldots j}\) 为 \(next(i)\) 的「前字符串」，\(A_{i-j+1\ldots i}\) 为「后字符串」。</p>
<p>\(f(i)\)：<strong>满足 \(A_{1 \ldots j}=B_{i-j+1\ldots i}\) 的最大的 \(j\)（\(0 \le j\le i\)）</strong>。</p>
<pre class="line-numbers"><code class="language-text">   1  j      i
   |  |      |
A: ABCD...........
B: .......ABCD....
</code></pre>
<p>为了方便表述，称 \(A_{1 \ldots j}\) 为 \(f(i)\) 「前字符串」，\(B_{i-j+1\ldots i}\) 为「后字符串」。</p>
<h3><a id="%E8%AE%A1%E7%AE%97next%E6%95%B0%E7%BB%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>计算 next 数组</h3>
<p>首选考虑找一找有没有递推的方式，效率高一些。初始值是 \(next(1)=0\)。</p>
<p>在计算 \(next(i)\) 时，假定 \(next(1 \ldots i-1)\) 都已经计算完毕。</p>
<p>\(next(i)\) 可能是哪些值？从最极端最大的来看，就是 \(i\)，但是显然定义不允许。那就只能缩一点了，很容易想到 \(next(i-1)+1\) 必然是一个可能的结果。有没有更大的呢？如果有更大的，那么 \(next(i)\) 的前、后字符串各砍最后一个字符就变成 \(next(i-1)\) 的前、后字符串了，导致 \(next(i-1)\) 不是最大，矛盾。因此 \(next(i)\) 的最大可能值即为 \(next(i-1)+1\)。（I）</p>
<p>但是如果它不太行——即最后一个字符无法对应——那就要找一找有没有替代方案了。与上面类似，继续缩小范围，考虑到前、后字符串完全相同，相同长度的前后缀也相同，那么进一步缩小到 \(next(next(i-1))+1\) 就行了。同样可以反证这是除了 \(next(i-1)+1\) 以外最大的。（II）</p>
<p>进一步整理，得出如下的算法框架：</p>
<ol>
<li>\(next(1) \gets 0, j\gets 0\)</li>
<li>对于每个 \(i\)，检查 \(A_{j+1}\) 是否等于 \(A_i\)：
<ol>
<li>如果是，\(j \gets j + 1\)，且 \(next(i) \gets j\)（对应上文步骤 I）；</li>
<li>如果不是，\(j \gets next(j)\)，重复直到 \(j=0\)，则 \(next(i) \gets 0\)（对应上文步骤 II）。</li>
</ol>
</li>
</ol>
<p>上面酸的非常重要的点就是一轮循环完以后，\(j\) 的值等于 \(next(i-1)\)，这有助于下一轮循环的计算。</p>
<h3><a id="%E8%AE%A1%E7%AE%97f%E6%95%B0%E7%BB%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>计算 f 数组</h3>
<p>完全一样，计算 \(f(i)\) 时最大的可能就是 \(f(i-1)+1\)，否则就缩到 \(next(f(i-1))+1\)。</p>
<p>注意，\(f\) 数组允许 \(f(i)=i\) 的情况发生，因此 \(f(1)\gets 1\) 即可。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p><tc><c>LG3375</c></tc></p>
<pre class="line-numbers"><code class="language-cpp">char a[1000001], b[1000001];
int next[1000001];

int main() {
    scanf(&quot;%s\n%s&quot;, b + 1, a + 1);
    const int A = strlen(a + 1), B = strlen(b + 1);

    next[1] = 0;
    for (int i = 2, j = 0; i &lt;= A; ++i) {
        while (a[j + 1] != a[i] &amp;&amp; j &gt; 0)
            j = next[j];
        if (a[j + 1] == a[i]) ++j;
        next[i] = j;
    }
    for (int i = 2, j = 1; i &lt;= B; ++i) {
        while (a[j + 1] != b[i] &amp;&amp; j &gt; 0)
            j = next[j];
        if (a[j + 1] == b[i]) ++j;
        if (j == A)
            printf(&quot;%d\n&quot;, i - A + 1);
    }
    for (int i = 1; i &lt;= A; printf(&quot;%d&quot;, next[i]), putchar(&quot; \n&quot;[i == A]), ++i);
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RingtoneHY V2 项目详解]]></title>
    <link href="oi.afobject.ml/16549586469772.html"/>
    <updated>2022-06-11T22:44:06+08:00</updated>
    <id>oi.afobject.ml/16549586469772.html</id>
    <content type="html"><![CDATA[
<h2><a id="1%E5%89%8D%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1 前言</h2>
<p>RingtoneHY V2 项目开源在 GitHub 仓库： <a href="https://github.com/AFObject/RingtoneHY">AFObject/RingtoneHY</a>，前身是 2020 年疫情期间的初版，在 2022 年网课期间进行了完全重构，是一款 macOS 原生 App，用于在网课期间提供模拟校园铃声的功能。</p>
<p>前有 C+++ 对抗 ClickIDE，后有 RingtoneHY 对抗 HYRing，好啊！!1</p>
<p>本项目的开发经历了一个完整的流程，在本文中进行详细的阐述。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h34osrcyi4j21by0qqq79.jpg" alt="" /><br />
（图 1.1 社团课演示文稿截图）</p>
<p>因为是小程序，整个的开发路子基本都是按照我之前总结的这个来，没有大的改动。</p>
<hr />
<h2><a id="2%E7%AB%8B%E9%A1%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2 立项</h2>
<p>究其原因是：</p>
<ol>
<li>班主任及多名任课教师在晨会 / 课上提到相关内容；</li>
<li>懒得在 iPad 上设闹钟；</li>
<li>秀 / 锻炼一下自己的码力。</li>
</ol>
<p>有了 20 年 V1 版本的经验，在开发之前将本次开发的主要内容确定为：</p>
<ul>
<li>增强 UI 界面的美观性、易用性；</li>
<li>动态编辑铃声的功能；</li>
<li>在实现功能的同时试试看简化、优化代码，至少让我自己满意。</li>
</ul>
<hr />
<h2><a id="3%E6%A8%A1%E5%9E%8B%E6%90%AD%E5%BB%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3 模型搭建</h2>
<blockquote>
<p>Code: <a href="https://github.com/AFObject/RingtoneHY/blob/main/RingtoneHY/TaskStorage.swift">RingtoneHY/TaskStorage.swift</a></p>
<p>Reference:</p>
<ol>
<li><a href="https://stackoverflow.com/questions/24217586/structure-vs-class-in-swift-language">StackOverflow 24217586</a></li>
</ol>
</blockquote>
<h3><a id="3-1%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%B4%E6%8A%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.1 模型的基本维护</h3>
<p>因为早就想好了，上来就直接写数据结构。</p>
<p>我们在这个 App 里需要维护的是什么？（一个<strong>星期</strong>中）【（每一<strong>天</strong>的）【（每一节<strong>课 / 任务</strong>的）【（开始、结束<strong>时间</strong>的）【时、分、秒和铃声】】】】。</p>
<p>上面这一句话的排版有点乱，但已经很明确了——对于每个加粗的部分，都写一个结构体来保存数据。</p>
<pre class="line-numbers"><code class="language-swift">struct Time { // 一个响铃时间点
    var hour: Int
    var minute: Int
    var music: Int
}
struct Task { // 一天
    var start: Time
    var end: Time
    var name: String
}
struct TaskList { // 一天的任务列表
    var tasks: [Task]
}
struct TaskStorage { // 一周七天，七个任务列表的集合
    var lists: [TaskList]
}
</code></pre>
<p>这是整个 <code>TaskStorage.swift</code> 150 行的精髓。接下来就要考虑的是细枝末节的东西：如何将数据变成系统可读的格式保存在本地？如何快速地新建一个结构体？如何配置默认日程表？……</p>
<ul>
<li>Q1：如何将数据变成系统可读的格式保存在本地？</li>
<li>A1：对于每个结构体，使其遵守 <code>Codable</code> 协议。使用 <code>JSONEncoder</code> / <code>JSONDecoder</code> 来解 / 编码数据。最后写几个方便操作的结构体内函数。</li>
</ul>
<pre class="line-numbers"><code class="language-swift">var data: Data {
    return try! JSONEncoder().encode(self)
}
    
static func from(data: Data?) -&gt; TaskStorage {
    if let data = data {
        do {
            return try JSONDecoder().decode(TaskStorage.self, from: data)
        } catch {
            print(error)
        }
    }
    return .default
}
</code></pre>
<ul>
<li>Q2：如何快速地新建一个结构体？</li>
<li>A2：在每个结构体内写好方便的构造函数。例如下面这段，输入一个五位数字串，自动转换成一个时间点的结构体。</li>
</ul>
<pre class="line-numbers"><code class="language-swift">init(_ string: String) {
    hour = Int(string.prefix(2)) ?? 0
    minute = Int((string as NSString).substring(with: NSMakeRange(2, 2))) ?? 0
    music = Int(string.suffix(1)) ?? 0
}
</code></pre>
<ul>
<li>Q3：如何配置默认日程表？</li>
<li>A3：在 <code>TaskStorage</code> 内写一个常量即可。例如：</li>
</ul>
<pre class="line-numbers"><code class="language-swift">static var `default`: TaskStorage {
    let ver1 = TaskList(tasks: [
        Task(&quot;07401&quot;, &quot;07450&quot;, &quot; 点名 &quot;),
        Task(&quot;08001&quot;, &quot;08402&quot;, &quot; 第 1 节课 &quot;), // trimmed
        Task(&quot;16051&quot;, &quot;16452&quot;, &quot; 第 9 节课 &quot;)
    ])
    let ver2 = TaskList(tasks: [
        Task(&quot;07401&quot;, &quot;07450&quot;, &quot; 点名 &quot;),
        Task(&quot;08001&quot;, &quot;08402&quot;, &quot; 第 1 节课 &quot;), // trimmed
        Task(&quot;15451&quot;, &quot;16252&quot;, &quot; 第 9 节课 &quot;)
    ])
    return TaskStorage(lists: [.empty, .empty, ver1, ver1, ver1, ver1, ver2, .empty])
}
</code></pre>
<h3><a id="3-2%E9%87%8D%E4%B8%AD%E4%B9%8B%E9%87%8D%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.2 重中之重：为什么不用面向对象？</h3>
<p>注意我在上文中自始至终贯穿了「结构体」一词。为什么我不把 <code>struct</code> 换成 <code>class</code>？</p>
<p>温习一遍：<code>struct</code> 是值，而 <code>class</code> 是引用。</p>
<blockquote>
<p>When you make a copy of a value type, it copies all the data from the thing you are copying into the new variable. They are 2 separate things and changing one does not affect the other. [1]</p>
</blockquote>
<p>我要维护的东西，再简单不过，就是几个时间点罢了。请问这些时间点何德何能逼着我去用引用类型来维护它？想象一下，我要把周二的课程表拷贝到周一的课程表上面去，我所希望的，仅是它们两个是值相同的不同的两个结构体，而不是什么别的。</p>
<p>用一个形象的比喻：Class 是活物，它可以灵活变通，有生有死也有变化；Struct 是死物，它只能长那样，我虽然可以改变它的值，但它永远只包含这些值，没有生命。可不希望这些课程表亦或是时间点的结构体变成活的，然后在运行的时候跳出来干些预料之外的事情！</p>
<hr />
<h2><a id="4%E4%B8%BB%E7%95%8C%E9%9D%A2%E4%B8%8E%E9%93%83%E5%A3%B0%E6%8A%A5%E6%97%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4 主界面与铃声报时</h2>
<blockquote>
<p>Code: <a href="https://github.com/AFObject/RingtoneHY/blob/main/RingtoneHY/ViewController.swift">RingtoneHY/ViewController.swift</a></p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h34r8cr0bbj20g20buaam.jpg" alt="" /></p>
<p>这是整个 App 的核心功能，也是最简单最易实现的，因为有去年的基础。</p>
<p>当然得有 ViewController（这回用了系统的 Visual Effect 模糊背景），还得有 Storyboard。</p>
<p>算法：每天开始运行时，或是更改设置时，从保存的日程表中拉取数据，把所有的时间节点排好序放进一个队列里，每 2 秒（<code>Timer</code>）获取一次系统时间（可以自己写一些东西方便实现），到时间了就响铃（<code>AVFoundation</code> 库），并把队首弹出。</p>
<pre class="line-numbers"><code class="language-swift">let timer = Timer(timeInterval: 2.0, target: self, selector: #selector(updateTime), userInfo: nil, repeats: true)
RunLoop.current.add(timer, forMode: .default)
</code></pre>
<pre class="line-numbers"><code class="language-swift">private var queue: [(Time, String, Bool)] = []
private func initializeQueue() {
    storedWeekday = DateManager.weekday
    let list = TaskStorage.shared.lists[DateManager.weekday]
    queue = []
    for i in list.tasks {
        if i.start.music &gt; 0 &amp;&amp; i.start &gt; .now {
            queue.append((i.start, i.name, true))
        }
        if i.end.music &gt; 0 &amp;&amp; i.end &gt; .now {
            queue.append((i.end, i.name, false))
        }
    }
    queue.sort(by: { lhs, rhs in
        lhs.0 &lt; rhs.0
    })
}
</code></pre>
<pre class="line-numbers"><code class="language-swift">@objc func updateTime() {
    dateLabel.stringValue = &quot;\(DateManager.month) 月 \(DateManager.day) 日 / 周 \(String.weekdayName(of: DateManager.weekday))&quot;
    timeLabel.stringValue = Time.now.timeString
    
    if DateManager.weekday != storedWeekday {
        initializeQueue()
    }
    
    while queue.count &gt; 0 &amp;&amp; queue.first!.0 &lt; .now {
        queue.removeFirst()
    }
    if let current = queue.first {
        if Time.timeEqual(current.0, .now) {
            AVAudioPlayer.ring(type: current.0.music)
            queue.removeFirst()
        }
    }
    if let current = queue.first {
        taskLabel.stringValue = &quot;下一项：\(current.0.timeString) \(current.1)\(current.2 ? &quot;开始&quot; : &quot;结束&quot;)&quot;
    } else {
        taskLabel.stringValue = &quot;今日无其他日程&quot;
    }
}
</code></pre>
<hr />
<h2><a id="5%E8%AE%BE%E7%BD%AE%E7%95%8C%E9%9D%A2%EF%BC%9A-swiftui%E7%9A%84%E6%AD%A3%E7%89%87%E5%BC%80%E5%A7%8B%EF%BC%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>5 设置界面：SwiftUI 的正片开始！</h2>
<p>设置界面，狗都不用 <code>AppKit</code> 中的控件！从现在开始，使用 SwiftUI。</p>
<blockquote>
<p>Code:</p>
<ul>
<li><a href="https://github.com/AFObject/RingtoneHY/blob/main/RingtoneHY/ViewController.swift">RingtoneHY/ViewController.swift</a></li>
<li><a href="https://github.com/AFObject/RingtoneHY/blob/main/RingtoneHY/TaskListView.swift">RingtoneHY/TaskListView.swift</a></li>
<li><a href="https://github.com/AFObject/RingtoneHY/blob/main/RingtoneHY/SettingsView.swifts">RingtoneHY/SettingsView.swift</a></li>
</ul>
</blockquote>
<h3><a id="5-1-appkit%E4%B8%8E-swiftui%E7%9A%84%E8%A1%94%E6%8E%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>5.1 AppKit 与 SwiftUI 的衔接</h3>
<p>老样子，用 <code>NSHostingController</code>。保存设置后让设置界面消失是当时的一个难点，这种问题直接在更高一层的 <code>ViewController</code> 中宏观控制就行了（否则为啥叫它 <code>Controller</code>）。</p>
<pre class="line-numbers"><code class="language-swift">@IBAction func showSettings(_ sender: Any?) {
    settingsController = NSHostingController(rootView: SettingsView(onCompletion: {
        self.settingsController?.dismiss(nil)
        self.initializeQueue()
    }))
    self.presentAsSheet(settingsController!)
}  
</code></pre>
<h3><a id="5-2-swiftui%E7%95%8C%E9%9D%A2%E7%BB%93%E6%9E%84%E7%9A%84%E6%90%AD%E5%BB%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>5.2 SwiftUI 界面结构的搭建</h3>
<p>老样子，你之前数据结构部分怎么套娃，现在也怎么套。接下来贴出的代码都是核心省略版。</p>
<pre class="line-numbers"><code class="language-swift">import SwiftUI

struct SettingsView: View {
    var onCompletion: () -&gt; () = {} // 配合 5.1 中的衔接部分
    @State private var taskStorage: TaskStorage = .default
    
    var body: some View {
        VStack {
            ScrollView {
                Form {
                    ForEach(1...7, id: \.self) { i in
                        Section {
                            Text(verbatim: &quot;周&quot; + .weekdayName(of: i))
                                .font(.title)
                            TaskListView(taskList: $taskStorage.lists[i]) // 套娃！
                        }
                        Divider()
                    }
                }.padding()
            }.frame(width: 540, height: 360)
                .onAppear {
                    taskStorage = .shared
                }
                .onChange(of: taskStorage) { newValue in
                    UserDefaults.standard.set(taskStorage.data, forKey: .storageKey)
                } // 重要！保存数据至本地。
        }
    }
}
</code></pre>
<pre class="line-numbers"><code class="language-swift">import SwiftUI

struct TaskView: View {
    @Binding var task: Task
    var body: some View {
        VStack(alignment: .leading) { // ... trimmed
        }.sheet(isPresented: $editing) { // 套娃！
                TaskEditView(task: $task)
            }
    }
}

struct TimeEditView: View { // 底层套娃
    var label: String
    @Binding var time: Time
    var body: some View {
        HStack {
            DatePicker(label, selection:
                Binding(get: {
                    Calendar.current.date(from: DateComponents(hour: time.hour, minute: time.minute))!
                }, set: { date in
                    let components = Calendar.current.dateComponents([.hour, .minute], from: date)
                    time.hour = components.hour!
                    time.minute = components.minute!
                }), displayedComponents: .hourAndMinute
            ) // DatePicker 编辑时间
            Picker(&quot;铃声&quot;, selection: $time.music) {
                ForEach(0...3, id: \.self) { i in
                    Text(verbatim: .audioName(of: i)).tag(i)
                }
            } // 普通 Picker 编辑铃声
        }
    }
}

struct TaskEditView: View {
    @Binding var task: Task
    @Environment(\.presentationMode) var presentationMode
    var body: some View {
        VStack {
            TextField(&quot;任务名称&quot;, text: $task.name)
            TimeEditView(label: &quot;起始时间&quot;, time: $task.start) // 套娃！
            TimeEditView(label: &quot;结束时间&quot;, time: $task.end) // 套娃！
            Spacer()
            HStack {
                Spacer()
                Button(&quot;完成&quot;) {
                    presentationMode.wrappedValue.dismiss()
                }
            }
        }.frame(width: 300, height: 120).padding()
    }
}

struct TaskListView: View, TaskViewManager {
    @Binding var taskList: TaskList
    @State private var newTask: Task = Task(&quot;08001&quot;, &quot;08402&quot;, &quot;新任务&quot;)
    @State private var editing = false
    
    let rows = Array(repeating: GridItem(), count: 3)
    var body: some View {
        LazyVGrid(columns: rows) {
            ForEach($taskList.tasks) { i in
                TaskView(task: i, manager: self) // 套娃！
            }
            Button(action: addItem) // ... trimmed
        }.frame(width: 500, alignment: .leading)
            .sheet(isPresented: $editing, onDismiss: {
                taskList.tasks.append(newTask)
                newTask = Task(&quot;08001&quot;, &quot;08402&quot;, &quot; 新任务 &quot;)
            }) {
                TaskEditView(task: $newTask) // 新建任务时的套娃！
            }
    }
    
    func addItem() {
        editing = true
    }
}
</code></pre>
<p>以上的代码即可完成编辑界面的 UI 基本功能。可以看出，SwiftUI 的一大特点就是通过套娃来节省代码量（别的地方也挺常见的），你只需要良好地完成单一界面的一个功能，并设置一个接口（例如支持同步修改的 <code>@Binding var ...</code>）就可以在别的任意地方调用它。</p>
<p>被省略的代码中还有一部分实现了任务的删除操作。与添加操作不同的是，任务的删除操作是针对单个任务的，它的按钮也放在单个任务的显示控件内。所以我另外写了一个协议（<code>TaskManager</code>），让它可以通知它的 Superview（不知表述是否准确）来控制它。一样的思路，还是想方设法把控制权交给上一级试图。</p>
<p>此外，SwiftUI 中的 <code>onChange(of:perform:)</code> 也是相当重要的一个功能。因为前文中我们使用了结构体，所以就可以放心大胆的使用它了，只要值有修改，立刻就会触发它！</p>
<hr />
<h2><a id="6%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%8F%91%E5%B8%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>6 测试与发布</h2>
<p>本项目的功能主体开发用时 3 天左右，测试与发布前准备用时也是 3 天左右，也可见其重要性。</p>
<p>首先就是自己个人的使用了。用了一天，主要是两个问题：一个是不断需要鼠标去点才能看到时间，所以我补了自动置顶的功能；还有一个是长的音频不能自动停止，所以我补了点击窗口停止铃声的功能。</p>
<p>在完成全部功能并在本机（macOS 12 Monterey）上测试完运行良好后，我修改了部分代码使其支持 macOS 11 Big Sur（这时还跳了坑，有些 SwiftUI 的东西在两个平台上实现得完全不一样），并在家里的旧电脑上测试成功。这个时候才能不动代码，开始发布前期的准备工作。</p>
<p>发布前的准备工作主要有两项：一是 App Icon 的设计；二是用户手册的编写与打包。</p>
<p>前者，在 Apple Developer 官网上就可以得到设计资源与设计建议。去年的图标我是网上嫖的，这次我照着去年的样子，自己用 PS 重新画了一遍，添加了阴影等细节，算是半个原创吧（笑）。至于用户手册的编写，用尽量书面化的语言、尽量完备地讲全软件的使用方式和 FAQ 即可，我选择了用 LaTeX 编辑。</p>
<p>耗时一共一个礼拜不到，显然算是极小的项目；但积累的经验应该是不少的。最终发布也没有引起什么波澜，方便了自己和一小部分人。</p>
<hr />
<h2><a id="7%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>7 总结</h2>
<p>本文写于 6 月 11 日至 12 日凌晨，感谢 macOS 13 的台前调度能让我专注地赶在 nth 之前写完这个东西（不是）。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h34r26jx6ij21c00u0ahl.jpg" alt="" /></p>
<p>用上我之前复活纪念的那篇文章的话，这可能是我第一个从头到尾自己做的、良好运行的 App，即使简单但很有意义。不过这大概也是初中能写的最后一个小项目了，之后也没什么时间，希望能记住这次开发带来的宝贵经验吧。</p>
<p>如果全文含有表述不准确或者明显错误的内容，请务必指出！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x14 Hash]]></title>
    <link href="oi.afobject.ml/0x14-.html"/>
    <updated>2022-06-10T22:13:57+08:00</updated>
    <id>oi.afobject.ml/0x14-.html</id>
    <content type="html"><![CDATA[
<h2><a id="snowflake-snow-snowflakes" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Snowflake Snow Snowflakes</h2>
<p><tc><c>0x1401</c><e>Easy+</e><t>Hash</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>我们目标的 Hash 函数要满足：</p>
<ul>
<li>对于每个数是平等的；</li>
<li>能尽量区分出不同的雪花。</li>
</ul>
<p>因此可以构造出 Hash 函数 \(H(a_{i,1},a_{i,2},\ldots,a_{i,6})=(\sum_{j=1}^6a_{i,j}+\prod_{j=1}^6a_{i,j}) \bmod P\)。</p>
<p>对于每一个 Hash 值，期望的项目数是 \(\dfrac N P\)。每个块内比一比，最终的时间复杂度是 \(P \cdot \left(\dfrac N P\right)^2= \dfrac{N^2}P\)）。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>Hash 的实现注意：</p>
<ul>
<li>当 Hash 值计算过程中可能超过 <code>int</code> 范围（如乘积等）时，先转一下 <code>long long</code>；</li>
<li>能不开新空间就不开新空间，少用指针（适用所有题目）。</li>
</ul>
<pre class="line-numbers"><code class="language-cpp">#define P 99991

int n;

struct Snowflake {
    int a[6];
    int hashValue() {
        int sum = 0, prod = 1;
        for (int i = 0; i &lt; 6; ++i) 
            sum = (sum + a[i]) % P, prod = ((long long)prod * a[i]) % P;
        return (sum + prod) % P;
    }
    bool operator == (const Snowflake&amp; other) const {
        for (int s = 0; s &lt; 6; ++s) {
            bool flag = true;
            for (int i = 0; i &lt; 6; ++i)
                if (a[(s + i) % 6] != other.a[i])
                    flag = false;
            if (flag) return true;
            flag = true;
            for (int i = 0; i &lt; 6; ++i)
                if (a[(s + i) % 6] != other.a[5 - i])
                    flag = false;
            if (flag) return true;
        }
        return false;
    }
};

std::vector&lt;Snowflake&gt; v[100001];

int main() {
    n = read();
    while (n--) {
        Snowflake t;
        for (int i = 0; i &lt; 6; ++i)
            t.a[i] = read() % P;
        const int val = t.hashValue();
        for (auto x : v[val])
            if (x == t)
                return puts(&quot;Twin snowflakes found.&quot;), 0;
        v[val].push_back(t);
    }
    return puts(&quot;No two snowflakes are alike.&quot;), 0;
}
</code></pre>
<hr />
<h2><a id="%E5%85%94%E5%AD%90%E4%B8%8E%E5%85%94%E5%AD%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>兔子与兔子</h2>
<p><tc><c>0x1402</c><e>Easy</e><t>Hash</t><t>字符串</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>书上讲的非常详细。例如串 <code>abcxyz</code>，在 27 进制下将它表示为 <code>1 2 3 24 25 26</code>。想要取出 <code>bcx</code> 的哈希值，则用 <code>abcx</code> 的哈希值减去 <code>a000</code> 的哈希值。其中 <code>a000</code> 代表 <code>a</code> 的哈希值在 27 进制下左移 3 位。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">char s[1000001];
unsigned long long x[1000001], p[1000001];

#define B 131

int main() {
    scanf(&quot;%s&quot;, s + 1);
    const int len = strlen(s + 1);
    p[0] = 1;
    for (int i = 1; i &lt;= len; ++i) {
        x[i] = x[i - 1] * B + s[i];
        p[i] = p[i - 1] * B;
    }
    int q = read();
    while (q--) {
        int l1 = read(), r1 = read(), l2 = read(), r2 = read();
        const auto h1 = x[r1] - x[l1 - 1] * p[r1 - l1 + 1];
        const auto h2 = x[r2] - x[l2 - 1] * p[r2 - l2 + 1];
        puts(h1 == h2 ? &quot;Yes&quot; : &quot;No&quot;);
    }
    return 0;
}
</code></pre>
<hr />
<h2><a id="palindrome" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Palindrome</h2>
<p><tc><c>0x1403</c><m>Medium-</m><t>Hash</t><t>字符串</t><t>二分</t></tc></p>
<p>Manacher 模版，但是数据范围 \(10^6\)。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>一眼二分 + 正 / 反向哈希。</p>
<p>但这只是宏观描述，还是有比较多的细节。</p>
<ol>
<li>
<p>二分什么？从哪里开始二分？</p>
<p>应该对于每一个回文串可能的中点，在两边二分出最远的回文串的左右端点。注意，这个中点可能是夹在字符中间的。</p>
</li>
<li>
<p>二分的边界范围</p>
<p>应当为 \([0,\text{maxLength}]\)。注意一定要取 0，这样方便判断不存在回文串的情况。</p>
</li>
<li>
<p>反向哈希</p>
<p>若要求 \([l,r]\) 的反向哈希值，则答案为 \(b(l)-b(r+1)\cdot B^{r-l+1}\)，与正向的恰好相反。</p>
</li>
</ol>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>我在实现中用了 <code>std::string</code>，下次不要这样捏！尽量下标从 1 开始方便自己，否则在预处理哈希值的时候碰到数组越界很麻烦。</p>
<pre class="line-numbers"><code class="language-cpp">
std::string s;
unsigned long long f[1000003], b[1000003], p[1000003];

#define B 31

unsigned long long getFront(int l, int r) {
    if (l) return f[r] - f[l - 1] * p[r - l + 1];
    else return f[r];
}

unsigned long long getBack(int l, int r) {
    return b[l] - b[r + 1] * p[r - l + 1];
}

int main() {
    int t = 0;
    while (true) {
        std::cin &gt;&gt; s;
        if (s == &quot;END&quot;) break;
        ++t; std::cout &lt;&lt; &quot;Case &quot; &lt;&lt; t &lt;&lt; &quot;: &quot;;
        const int len = s.length();
        for (int i = 0; i &lt; len; i++)
            f[i] = (s[i] - 'a') + (i ? f[i - 1] * B : 0),
            b[len - i - 1] = (s[len - i - 1] - 'a') + b[len - i] * B,
            p[i] = i ? p[i - 1] * B : 1;
        int ans = 0;
        
        for (int i = 0; i &lt; len; ++i) {
            int l = 0, r = std::min(i, len - i - 1);
            while (l &lt; r) {
                const int mid = (l + r + 1) &gt;&gt; 1;
                if (getFront(i - mid, i) == getBack(i, i + mid))
                    l = mid;
                else
                    r = mid - 1;
            }
            ans = std::max(ans, (l &lt;&lt; 1) + 1);
        }
        for (int i = 1; i &lt; len; ++i) {
            int l = 0, r = std::min(i, len - i);
            while (l &lt; r) {
                const int mid = (l + r + 1) &gt;&gt; 1;
                if (getFront(i - mid, i - 1) == getBack(i, i + mid - 1))
                    l = mid;
                else
                    r = mid - 1;
            }
            ans = std::max(ans, l &lt;&lt; 1);
        }
        std::cout &lt;&lt; ans &lt;&lt; std::endl;
    }
}
</code></pre>
<hr />
<h2><a id="%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%EF%BC%88%E5%BC%B1%E5%8C%96%E7%89%88%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>后缀数组（弱化版）</h2>
<p><tc><c>0x1404</c><m>Medium-</m><t>Hash</t><t>字符串</t><t>二分</t></tc></p>
<p>后缀排序模版，但是 \(n \le 3\times10^5\)。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>其实是字符串 Hash 的综合。看看我们现有的知识对所求的两问分别有什么帮助。</p>
<ol>
<li>对于 Height 数组，似乎可以拿与上一题类似的二分来做，也比较好写。</li>
<li>对于 SA 的排序，无非就是用常规的 <code>std::sort</code> / 手写快排，归并排序，或者是用一些别的奇妙方法。当我们比较两个前缀的时候，常规做法应该是逐个字符比较；但已经可以实现 Height 了，要什么暴力！直接拿 Height 找出第一个不同的位置即可。把这些东西套在一个 <code>comp</code> 里，用 <code>std::sort</code>  排序。</li>
</ol>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>上面几题踩过坑，这次快很多。</p>
<pre class="line-numbers"><code class="language-cpp">char s[3000003];
int n;
unsigned long long x[3000003], p[3000003];

#define B 31

int getHash(int l, int r) {
    return x[r] - x[l - 1] * p[r - l + 1];
}

int height(int a, int b) {
    int l = 0, r = std::min(n - b + 1, n - a + 1);
    while (l &lt; r) {
        const int mid = (l + r + 1) &gt;&gt; 1;
        if (getHash(a, a + mid - 1) == getHash(b, b + mid - 1))
            l = mid;
        else
            r = mid - 1;
    }
    return l;
}

bool comp(int a, int b) {
    const int h = height(a, b);
    return s[a + h] &lt; s[b + h];
}

int sa[3000003];

int main() {
    scanf(&quot;%s&quot;, s + 1);
    n = strlen(s + 1);
    p[0] = 1;
    for (int i = 1; i &lt;= n; ++i) {
        x[i] = x[i - 1] * B + s[i] - 'a';
        p[i] = p[i - 1] * B;
        sa[i] = i;
    }
    std::sort(sa + 1, sa + n + 1, comp);
    for (int i = 1; i &lt;= n; ++i)
        printf(&quot;%d &quot;, sa[i] - 1);
    printf(&quot;\n0 &quot;);
    for (int i = 2; i &lt;= n; ++i)
        printf(&quot;%d &quot;, height(sa[i - 1], sa[i]));
    putchar('\n');
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ABC254]]></title>
    <link href="oi.afobject.ml/abc254.html"/>
    <updated>2022-06-04T23:26:05+08:00</updated>
    <id>oi.afobject.ml/abc254.html</id>
    <content type="html"><![CDATA[
<p>VP</p>
<span id="more"></span><!-- more -->
<h2><a id="d-together-square" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>D Together Square</h2>
<p><tc><m>Medium *1191</m><t>数论</t><t>组合</t><t>筛法</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>两个数都是平方数的话其实是很简单的，但如果两个都不是平方数就有点难搞。一个非平方数所对应的可以让它们的积为完全平方数的另一个数是不唯一的，怎么快速找到它呢？</p>
<p>考虑将所有的数 \(i\) 都除去它们最大的完全平方数因数（\(p_i\)），然后剩下的部分（设为 \(f_i\)）相等的，原数拼在一起就可以得到一个完全平方数。下面考虑的是如何快速的得到 \(f_i\)。由于数据范围不大，可以直接枚举它的因数找到 \(p_i\)。枚举因数用类似埃筛的方法，时间复杂度反正不大。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">#define int long long

int n, sum[200001];
bool g[200001];
std::vector&lt;int&gt; v[200001];

signed main() {
    scanf(&quot;%lld&quot;, &amp;n);
    int ans = 0;
    for (int i = 1; i * i &lt;= n; ++i) g[i * i] = true;
    for (int i = 1; i &lt;= n; ++i)
        for (int j = i; j &lt;= n; j += i)
            v[j].push_back(i);
    for (int i = 1; i &lt;= n; ++i) {
        int f = 1;
        for (int p : v[i])
            if (i % p == 0 &amp;&amp; g[p]) f = std::max(f, p);
        sum[i / f]++;
    }
    for (int i = 1; i &lt;= n; ++i) ans += sum[i] * sum[i];
    printf(&quot;%lld\n&quot;, ans);
}
</code></pre>
<hr />
<h2><a id="e-small-d-and-k" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>E Small d and k</h2>
<p><tc><e>Easy+ *1202</e><t>搜索</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>答案是暴力。</p>
<p>这种最短路问题理应用 BFS 解决，但实际上 DFS 乱搞搞也可以过。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int x, k;
int dis[200001];
std::vector&lt;int&gt; nodes;
void dfs(int x, int t) {
    if (t &gt;= dis[x]) return;
    if (dis[x] &gt; k) nodes.push_back(x);
    dis[x] = t;
    if (t == k) return;
    for (int v : e[x])
        dfs(v, t + 1);
}

int main() {
    n = read(), m = read();
    for (int i = 1; i &lt;= n; ++i) dis[i] = 1e9;
    while (m--) {
        int u = read(), v = read();
        e[u].push_back(v);
        e[v].push_back(u);
    }
    q = read();
    while (q--) {
        x = read(), k = read();
        nodes = std::vector&lt;int&gt;();
        dfs(x, 0);
        long long ans = 0;
        for (int u : nodes) {
            dis[u] = 1e9;
            ans += u;
        }
        printf(&quot;%lld\n&quot;, ans);
    }
    return 0;
}
</code></pre>
<hr />
<h2><a id="f-rectangle-gcd" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>F Rectangle GCD</h2>
<p><tc><m>Medium- *1764</m><t>数论</t><t>GCD</t><t>线段树</t><t>DS</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>极其显然地，答案是</p>
\[\gcd\{A_{h_1}+B_{w_1},\underset{i\in(h_1,h_2]}{\left|A_i-A_{i-1}\right|},\underset{i\in(w_1,w_2]}{\left|B_i-B_{i-1}\right|}\}
\]
<p>然后就是查询区间 \(\gcd\)，用线段树或者 ST 表。</p>
<p>为什么感觉 E &lt; F &lt; D……</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>不带修的线段树真好写。注意四倍空间！</p>
<pre class="line-numbers"><code class="language-cpp">#define lt(x) ((x) &lt;&lt; 1)
#define rt(x) (((x) &lt;&lt; 1) + 1)
#define abs(x) ((x) &gt; 0 ? (x) : -(x))

int n, q;
int a[200001], b[200001];
int ca[200001], cb[200001];

int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}

int segA[800001], segB[800001];
void build(int *s1, int *s2, int x, int l, int r) {
    if (l == r) {
        s1[x] = s2[l];
        return;
    }
    const int mid = (l + r) &gt;&gt; 1;
    build(s1, s2, lt(x), l, mid);
    build(s1, s2, rt(x), mid + 1, r);
    s1[x] = gcd(s1[lt(x)], s1[rt(x)]);
}

int query(int *s, int x, int l, int r, int ql, int qr) {
    if (l &gt; r) return 1;
    if (ql &lt;= l &amp;&amp; r &lt;= qr) return s[x];
    const int mid = (l + r) &gt;&gt; 1;
    int res = 0;
    if (ql &lt;= mid) res = gcd(res, query(s, lt(x), l, mid, ql, qr));
    if (qr &gt; mid) res = gcd(res, query(s, rt(x), mid + 1, r, ql, qr));
    return res;
}

int main() {
    n = read(), q = read();
    for (int i = 1; i &lt;= n; ++i) a[i] = read();
    for (int i = 1; i &lt;= n; ++i) b[i] = read();
    for (int i = 1; i &lt;= n; ++i)
        ca[i] = abs(a[i] - a[i - 1]), cb[i] = abs(b[i] - b[i - 1]);
    build(segA, ca, 1, 1, n);
    build(segB, cb, 1, 1, n);
    while (q--) {
        int h1 = read(), h2 = read(), w1 = read(), w2 = read();
        printf(&quot;%d\n&quot;, gcd( gcd(query(segA, 1, 1, n, h1 + 1, h2),
                                query(segB, 1, 1, n, w1 + 1, w2)),
                            a[h1] + b[w1]));
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x13 链表与邻接表]]></title>
    <link href="oi.afobject.ml/0x13-.html"/>
    <updated>2022-06-01T20:12:11+08:00</updated>
    <id>oi.afobject.ml/0x13-.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E5%B0%8F%E7%86%8A%E7%9A%84%E6%9E%9C%E7%AF%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>小熊的果篮</h2>
<p><tc><c>CSP-J 2021</c><e>Easy+</e><t>模拟</t><t>链表</t></tc></p>
<p>普及摆烂没 AK 的痛</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>将块作为链表的一个项目，每一轮进行合并，由于每个水果至多被删一次，所以时间复杂度就是 \(O(n)\) 的。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>有点难整。。。</p>
<p>首先明确一个块内的编号并不是连续的，所以除了维护块之间的顺序外还要再开一个双向链表来维护编号间的前后关系（但这个实现起来用数组即可，比较简单）。考场上写错就是因为这个点。</p>
<p>另外这里的写法中两边的 <code>head</code> 和 <code>tail</code> 是空的，要判一下。</p>
<pre class="line-numbers"><code class="language-cpp">namespace List {
    struct Node {
        int val, type, start;
        Node *prev, *next;
    } v[200001], *head, *tail;
    void init() {
        head = new Node();
        tail = new Node();
        head-&gt;next = tail;
        tail-&gt;prev = head;
    }
    void insert(int val, int type, int start, Node *p) {
        auto r = new Node();
        r-&gt;val = val; r-&gt;type = type; r-&gt;start = start;
        r-&gt;prev = p; r-&gt;next = p-&gt;next;
        p-&gt;next-&gt;prev = r; p-&gt;next = r;
    }
    void remove(Node *p) {
        p-&gt;prev-&gt;next = p-&gt;next;
        p-&gt;next-&gt;prev = p-&gt;prev;
        delete p;
    }
};

int prevN[200001], nextN[200001];

int n;

int main() {
    n = read();
    List::init();
    int prev = 0, count = 0;
    for (int i = 1; i &lt;= n; ++i) {
        if (i != n) nextN[i] = i + 1; prevN[i] = i - 1;
        int a = read();
        if (a != prev) {
            if (i != 1)
                List::insert(count, prev, i - count, List::tail-&gt;prev);
            prev = a;
            count = 0;
        }
        ++count;
    }
    List::insert(count, prev, n + 1 - count, List::tail-&gt;prev);
    while (List::head-&gt;next != List::tail) {
        for (auto x = List::head-&gt;next; x-&gt;next != NULL; x = x-&gt;next)
            printf(&quot;%d &quot;, x-&gt;start);
        putchar('\n');
        for (auto x = List::head-&gt;next; x-&gt;next != NULL; x = x-&gt;next) {
            x-&gt;val--;

            nextN[prevN[x-&gt;start]] = nextN[x-&gt;start];
            prevN[nextN[x-&gt;start]] = prevN[x-&gt;start];
            x-&gt;start = nextN[x-&gt;start];

            if (x-&gt;val == 0)
                List::remove(x);
            else if (x-&gt;prev-&gt;type == x-&gt;type &amp;&amp; x-&gt;prev != List::head)
                x-&gt;prev-&gt;val += x-&gt;val, List::remove(x);
        }
    }
    return 0;
}
</code></pre>
<hr />
<h2><a id="%E9%82%BB%E5%80%BC%E6%9F%A5%E6%89%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>邻值查找</h2>
<p><tc><c>0x1301</c><m>Medium-</m><t>模拟</t><t>链表</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>显然有一步是要从小到大排序并且找出某个数的前驱 / 后继。</p>
<p>一种方法是依次将数有序地插入一个 <code>std::set</code>，并输出这个数的前驱或后缀。</p>
<p>另一种方法则是<strong>倒序</strong>处理，用完一个删一个，用链表维护数据。</p>
<p>本节例题中「Running Median」（0x0503）也可以用这种倒序的思想处理数据（用完一个删一个）。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>还是注意判断队列首、尾预留的空项的问题，赋一个极大的初值即可。</p>
<pre class="line-numbers"><code class="language-cpp">namespace List {
    struct Node {
        std::pair&lt;int, int&gt; val;
        Node *prev, *next;
    } v[200001], *head, *tail;
    void init() {
        head = new Node();
        tail = new Node();
        head-&gt;val.first = -2e9;
        tail-&gt;val.first = 2e9;
        head-&gt;next = tail;
        tail-&gt;prev = head;
    }
    void insert(std::pair&lt;int, int&gt; val, Node *p) {
        auto r = new Node();
        r-&gt;val = val; r-&gt;prev = p; r-&gt;next = p-&gt;next;
        p-&gt;next-&gt;prev = r; p-&gt;next = r;
    }
    void remove(Node *p) {
        p-&gt;prev-&gt;next = p-&gt;next;
        p-&gt;next-&gt;prev = p-&gt;prev;
        delete p;
    }
};

std::pair&lt;int, int&gt; a[200001];
List::Node *b[200001];

int n;
int ansVal[200001], ansIdx[200001];

int main() {
    n = read();
    List::init();
    for (int i = 1; i &lt;= n; ++i) a[i] = {read(), i};
    std::sort(a + 1, a + n + 1);
    for (int i = 1; i &lt;= n; ++i) {
        List::insert(a[i], List::tail-&gt;prev);
        b[a[i].second] = List::tail-&gt;prev;
    }
    for (int i = n; i &gt; 1; --i) {
        int lhs = b[i]-&gt;val.first - b[i]-&gt;prev-&gt;val.first,
            rhs = b[i]-&gt;next-&gt;val.first - b[i]-&gt;val.first;
        ansVal[i] = std::min(lhs, rhs);
        if (lhs &lt;= rhs) ansIdx[i] = b[i]-&gt;prev-&gt;val.second;
        else ansIdx[i] = b[i]-&gt;next-&gt;val.second;
        List::remove(b[i]);
    }
    for (int i = 2; i &lt;= n; ++i)
        printf(&quot;%d %d\n&quot;, ansVal[i], ansIdx[i]);
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x12 队列]]></title>
    <link href="oi.afobject.ml/0x12-.html"/>
    <updated>2022-05-20T22:37:19+08:00</updated>
    <id>oi.afobject.ml/0x12-.html</id>
    <content type="html"><![CDATA[
<h2><a id="team-queue" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Team Queue</h2>
<p><tc><c>0x1201</c><e>Easy</e><t>模拟</t><t>队列</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>开个队列记录下队伍之间的顺序；再对于每个队伍开个队列记录下内部的顺序。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n;
std::map&lt;int, int&gt; m;
std::queue&lt;int&gt; d, q[1001];

int main() {
    int T = 0;
    while (std::cin &gt;&gt; n &amp;&amp; n) {
        ++T;
        std::cout &lt;&lt; &quot;Scenario #&quot; &lt;&lt; T &lt;&lt; '\n';

        m.clear(); d = std::queue&lt;int&gt;();
        for (int i = 1; i &lt;= n; ++i) {
            q[i] = std::queue&lt;int&gt;();
            int t; std::cin &gt;&gt; t;
            while (t--) {
                int g; std::cin &gt;&gt; g;
                m[g] = i;
            }
        }

        std::string s; int op;
        while (std::cin &gt;&gt; s &amp;&amp; s != &quot;STOP&quot;) {
            if (s == &quot;DEQUEUE&quot;) {
                std::cout &lt;&lt; q[d.front()].front() &lt;&lt; '\n';
                q[d.front()].pop();
                if (q[d.front()].empty()) d.pop();
            } else if (s == &quot;ENQUEUE&quot;) {
                std::cin &gt;&gt; op;
                if (q[m[op]].empty()) d.push(m[op]);
                q[m[op]].push(op);
            }
        }
        std::cout &lt;&lt; '\n';
    }
}
</code></pre>
<hr />
<h2><a id="%E8%9A%AF%E8%9A%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>蚯蚓</h2>
<p><tc><c>NOIP2016 D2T2</c><c>0x1202</c><m>Medium+</m><t>数学</t><t>队列</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>时间复杂度的瓶颈像是 \(O(m)\) 的，这也就是要求我们 \(O(1)\) 实现查询最大值、分裂、增长长度这三个操作。</p>
<p>最直接地，可以想到通过大根堆找出最大值，但是顺序不保证，而且太慢了，想要 \(O(1)\) 的话最好使序列有序。接下来就是试图找出单调性。</p>
<p>一次操作，等效于把一个数 \(x\) 分为 \(\lfloor px \rfloor - q\) 和 \(x - \lfloor px \rfloor - q\) 这两个数（实际值是全部数加上 \(\Delta=q\cdot T\)，\(T\) 为当前操作次数）。任何操作都只会让数列中的数变小，所以数列的最大值单调递减，被砍的数单调递减。</p>
<p>可不想让被砍出来的数再放回原队列破坏单调性，所以继续探究被砍出来的数是否存在单调性。注意我们集体减了 \(\Delta\)，计算的时候要还原 \(\Delta\)（\(\Delta\) 为本轮操作前的 \(\Delta\)）。一个数被分为了 \(x_1=\lfloor p(x+\Delta) \rfloor - q - \Delta\) 和 \(x_2=x - \lfloor p(x+\Delta) \rfloor - q\)。假设在这个数后面被分裂的那个数是 \(y\)（\(y \le x\)），那么分出来的就是 \(y_1=\lfloor p(y+\Delta+q) \rfloor - q - \Delta-q\) 和 \(y_2=y - \lfloor p(y+\Delta+q) \rfloor - q\)。</p>
<p>作差：</p>
\[\begin{aligned}
x_1-y_1
&amp;=\lfloor p(x+\Delta) \rfloor-\lfloor p(y+\Delta+q) \rfloor+q\\
&amp;=\lfloor p(x+xq) \rfloor-\lfloor p(y+q) \rfloor&gt;0\\

x_2-y_2
&amp;=x - \lfloor p(x+\Delta) \rfloor - y + \lfloor p(y+\Delta+q) \rfloor\\
&amp;=\lfloor x-p(x)\rfloor-\lfloor y-p(y+q) \rfloor&gt;0
\end{aligned}
\]
<p>也就是说，<strong>砍出来的那两截蚯蚓的长度也随着时间的推移而单调递减</strong>。在所有操作之前先把整个序列排序存进一个队列中，当进行分裂操作时，把大的取出来放进一个队列，把小的取出来放进另一个队列。可以保证这三个队列都是队首大，队尾小，这样就完成了 \(O(1)\) 地求最大值。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">#define int long long
#define top(x) ((x.empty()) ? -1e16 : x.front())

int n, m, q, u, v, t;
int d[100001];
std::queue&lt;int&gt; a, b, c;

signed main() {
    n = read(), m = read(), q = read(), u = read(), v = read(), t = read();
    for (int i = 1; i &lt;= n; ++i) d[i] = read();
    std::sort(d + 1, d + n + 1);
    for (int i = n; i; --i) a.push(d[i]);

    int delta = 0;
    for (int i = 1; i &lt;= m; ++i, delta += q) {
        int a0 = top(a), b0 = top(b), c0 = top(c), max = 0;
        if (a0 &gt;= b0 &amp;&amp; a0 &gt;= c0) max = a0, a.pop();
        else if (b0 &gt;= c0) max = b0, b.pop();
        else max = c0, c.pop();
        if (i % t == 0) printf(&quot;%lld &quot;, max + delta);
        b.push(floor((double)u / v * (max + delta)) - q - delta);
        c.push(max - floor((double)u / v * (max + delta)) - q);
    }
    putchar('\n');
    for (int i = 1; i &lt;= n + m; ++i) {
        int a0 = top(a), b0 = top(b), c0 = top(c), max = 0;
        if (a0 &gt;= b0 &amp;&amp; a0 &gt;= c0) max = a0, a.pop();
        else if (b0 &gt;= c0) max = b0, b.pop();
        else max = c0, c.pop();
        if (i % t == 0) printf(&quot;%lld &quot;, max + delta);
    }

    return 0;
}
</code></pre>
<hr />
<h2><a id="%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>双端队列</h2>
<p><tc><c>BJOI 2011</c><c>0x1203</c><m>Medium+</m><t>贪心</t><t>队列</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>以输入为出发点考虑问题：我不太行，因为他要求是整体有序，很难光通过原始的无序序列找到答案。</p>
<p><strong>以输出为出发点考虑问题</strong>：最终要求排好序，那我就排好序，把排好序的数组分割，每一段对应一个双端队列。每一段中要求数的下标具有<strong>单谷性质</strong>。注意判断重复的数。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>接下来是单谷怎么找的问题，一开始是下降的状态，降不动的时候只能升，升不动的时候就成了一个双端队列（同一个数的下标要么全升要么全降，否则复杂化了）。开两个变量，一个是上升下降的标志，一个是上升 / 下降期的最小 / 最大下标。</p>
<pre class="line-numbers"><code class="language-cpp">int n, a[200001];
std::pair&lt;int, int&gt; p[200001];
std::vector&lt;int&gt; v[200001];

int main() {
    n = read();
    for (int i = 1; i &lt;= n; ++i) {
        p[i].first = read();
        p[i].second = i;
    }
    std::sort(p + 1, p + n + 1);
    int t = 1;
    v[t].push_back(p[1].second);
    for (int i = 2; i &lt;= n; ++i) {
        if (p[i].first != p[i - 1].first)
            v[++t].push_back(p[i].second);
        else v[t].push_back(p[i].second);
    }
    int flag = 0, num = 0, ans = 0;
    for (int i = 1; i &lt;= t; ++i) {
        const int first = v[i][0], last = v[i][v[i].size() - 1];
        if (flag) {
            if (first &lt; num) { ++ans; flag = 0; num = first; }
            else num = last;
        } else {
            if (last &gt; num) { flag = 1; num = last; }
            else num = first;
        }
    }
    printf(&quot;%d\n&quot;, ans);
    return 0;
}
</code></pre>
<hr />
<h2><a id="%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>最大子序和</h2>
<p><tc><c>0x1204</c><e>Easy</e><t>前缀和</t><t>单调队列</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>考虑没有限制的做法：一个是递推一下，一个是前缀和一下。有限制的话感觉前缀和更靠谱，那就试一试。求出前缀和 \(p\) 后，问题转化为找出 \(\max\limits_{i-j &lt; m}\{p_i-p_j\}\)。</p>
<p>考虑用单调队列求解。用滑动窗口求出当前点之前的 \(m\) 个前缀和的最小值，用现在的前缀和去减，就做完了。</p>
<p>复习一下滑动窗口的做法：进队尾把大数顶掉，维持单调递增，把超过窗口范围的也推掉。最小值在每次的队头。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n, m, p[300001];
std::deque&lt;std::pair&lt;int, int&gt;&gt; q;

int main() {
    n = read(), m = read();
    for (int i = 1; i &lt;= n; ++i)
        p[i] = p[i - 1] + read();
    int ans = -2e8;
    q.push_back({0, 0});
    for (int i = 1; i &lt;= n; ++i) {
        while (q.size() &amp;&amp; q.back().second &gt; p[i]) q.pop_back();
        q.push_back({i, p[i]});
        if (i - q.front().first &gt; m) q.pop_front();
        ans = std::max(ans, p[i] - q.front().second);
    }
    printf(&quot;%d\n&quot;, ans);
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Educational Codeforces Round #128 (Div.2)]]></title>
    <link href="oi.afobject.ml/cf1680.html"/>
    <updated>2022-05-14T22:28:03+08:00</updated>
    <id>oi.afobject.ml/cf1680.html</id>
    <content type="html"><![CDATA[
<p>[5/6] Alt (Rated), 3/6, 1071 \(\to\) 1278</p>
<span id="more"></span><!-- more -->
<h2><a id="1680c-binary-string" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1680C Binary String</h2>
<p><tc><m>Medium- *1600</m><t>二分</t><t>前缀和</t></tc></p>
<p>场切了，想出二分没觉得特难，到时候看看 \(O(n)\) 做法是什么。</p>
<hr />
<h2><a id="1680d-dog-walking" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1680D Dog Walking</h2>
<p><tc><m>Medium+ *2400</m><t>数学</t><t>贪心</t><t>前缀和</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>题面太长不看。稍微简化一下题面：将数列中的 \(0\) 都替换成 \([-k,k]\) 中的一个数后，令前缀和数组为 \(s\)，最大化 \(\max\{s\}-\min\{s\}\) 且 \(s_n=0\)（很容易判断，当 \(\mid s_n\mid\) 大于 0 的个数乘以 \(k\) 的时候，必然无解）。</p>
<p>由这个式子不难想到最大子段和的前缀和解法，可以差不多地理解一下，这个 \(\max\{s\}-\min\{s\}\) 代表的是原数列中的<strong>一段区间和（的绝对值）</strong>。然后注意到 \(1 \le n \le 3000\) 的良心范围，考虑直接枚举这个区间的左、右端点。最优化的方案必然是要么 0 全替换为 \(k\)，要么全替换为 \(-k\)。</p>
<p>但要求 \(s_n=0\)，怎么处理这个条件也是难点之一。关键点在于看被选择的区间内、外的和能否达到平衡，即「归零」：</p>
<ul>
<li>当区间内的和为一个正数 \(p\)，区间外的和的最小值为 \(p'_{\min}\)，我们想要使 \(p+p'_{\min}=0\)，因此答案取 \(\min\{p, \mid p'_{\min} \mid\}\)；</li>
<li>同理，当区间内的和为一个负数 \(-p\)，区间外的和的最大值为 \(p'_{\max}\)，答案取 \(\min\{\mid p \mid, p'_{\max}\}\)。</li>
</ul>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n, k, a[3001];
int p[3001], d[3001];

signed main() {
    n = read(), k = read();
    for (int i = 1; i &lt;= n; i++) {
        a[i] = read();
        d[i] = d[i - 1] + (a[i] == 0);
        p[i] = p[i - 1] + a[i];
    }
    if (abs(p[n]) &gt; k * d[n]) return puts(&quot;-1&quot;), 0;
    int max = -1;
    for (int l = 1; l &lt;= n; l++) {
        for (int r = l; r &lt;= n; r++) {
            int sum = p[r] - p[l - 1], cnt = d[r] - d[l - 1];
            int lSum = p[n] - sum, lCnt = d[n] - cnt;
            max = std::max(max, std::min(abs(sum + cnt * k), abs(lSum - lCnt * k)));
            max = std::max(max, std::min(abs(sum - cnt * k), abs(lSum + lCnt * k)));
        }
    }
    printf(&quot;%lld\n&quot;, max + 1);
    return 0;
}
</code></pre>
<hr />
<h2><a id="1680e-moving-chips" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1680E Moving Chips</h2>
<p><tc><m>Medium+ *2000</m><t>DP</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>这题里吃的路径其实是可逆的，比如说 A 吃了 B，C 再吃了 B 和 A 吃了 B 然后继续吃了 C 是一样的。所以我们的目标是找出代价最少的一条吃人路径，并且可以钦定任意一个星号作为最终状态。假如设最后留下来的是最右边的某个星号，那就是「从左吃到右」的过程，可以尝试用 DP 来最优化方案。</p>
<p>设 \(f(i,0/1)\) 为把第 \(1\) 到第 \(i-1\) 列全部吃掉，且星号仅在 \((i,0/1)\) 时的最小步数。在对这一列进行 DP 的过程中，我们要考虑的问题是<strong>怎么把上一列的星号全部转移到这一列的目标位置中去</strong>。假如本列有两个星号，<strong>合并一定更优</strong>（否则同时移两个就是浪费），所以也要考虑合并。</p>
<ul>
<li>若全部转移到 \((i,0)\)：
<ul>
<li>从 \((i-1,0)\) 转移：代价为 \(1\)，但如果 \((i,1)\) 有星号，还需要再加一。</li>
<li>从 \((i-1,1)\) 转移：可以顺便吃了 \((i,1)\)，无论如何代价始终为 \(2\)。</li>
</ul>
</li>
<li>若全部转移到 \((i,1)\)：
<ul>
<li>从 \((i-1,1)\) 转移：代价为 \(1\)，但如果 \((i,0)\) 有星号，还需要再加一。</li>
<li>从 \((i-1,0)\) 转移：代价始终为 \(2\)。</li>
</ul>
</li>
</ul>
<p>可以轻松写出状态转移方程。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int T, n;
int g[200001][2], f[200001][2];

int main() {
    std::cin &gt;&gt; T;
    while (T--) {
        std::cin &gt;&gt; n;
        for (int i = 1; i &lt;= n; ++i)
            f[i][0] = f[i][1] = 0;
        for (int i = 0; i &lt; 2; ++i) {
            for (int j = 1; j &lt;= n; ++j) {
                char c; std::cin &gt;&gt; c;
                g[j][i] = (c == '*');
            }
        }
        int l = 1, r = n;
        while (!g[l][0] &amp;&amp; !g[l][1]) ++l;
        while (!g[r][0] &amp;&amp; !g[r][1]) --r;
        for (int i = l; i &lt;= r; ++i) {
            f[i][0] = std::min(f[i - 1][0] + g[i][1] + 1, f[i - 1][1] + 2);
            f[i][1] = std::min(f[i - 1][1] + g[i][0] + 1, f[i - 1][0] + 2);
        }
        std::cout &lt;&lt; std::min(f[r][0], f[r][1]) - 1 &lt;&lt; std::endl;
        // 之前没有特地算 f[l][0/1] 的初始值，循环直接从 l 开始，但是 l-1 -&gt; l 算了 1 步，所以这里减去一。
    }
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces Round #786 (Div.3)]]></title>
    <link href="oi.afobject.ml/cf1674.html"/>
    <updated>2022-05-03T23:02:19+08:00</updated>
    <id>oi.afobject.ml/cf1674.html</id>
    <content type="html"><![CDATA[
<p>[已通关] Rated, 4/7, 1364 \(\to\) 1438</p>
<span id="more"></span><!-- more -->
<p>E 大家都 fst 也就算了，F 就差造个极端数据拍一拍就过了 /fn</p>
<h2><a id="1674f-desktop-rearrangement" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1674F Desktop Rearrangement</h2>
<p><tc><e>Easy+ *1800</e><t>模拟</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>你 CF 为啥要出这种烂模拟。</p>
<p>问题相当于询问有几个图标需要移动。首先求出原图状态下有几个需要移的，接下来考虑变化。</p>
<ul>
<li>
<p>如果是从没有变成有的：</p>
<ul>
<li>在操作<strong>后</strong>的边界上的那个点（如果存在）不用移了，答案减一（如果操作的就是这个点，<strong>忽略</strong>这一条，对答案没有影响）。</li>
<li>另外如果改变的这个点超过了操作<strong>后</strong>的边界，那么就需要费力气移它，答案加一。</li>
</ul>
</li>
<li>
<p>如果是从有变成没有的：</p>
<ul>
<li>操作<strong>前</strong>的守门员（如果存在）被踢了，需要移的加一（如果操作的就是这个点，<strong>忽略</strong>这一条，对答案没有影响）。</li>
<li>如果本来就超出了操作<strong>前</strong>的范围，需要移的减一，否则不变。</li>
</ul>
</li>
</ul>
<p>由上分类讨论可见，<code>.</code> 变 <code>*</code> 和 <code>*</code> 变 <code>.</code> 对答案的影响是不同的，尤其体现在操作前边界或是操作后边界的区别。</p>
<p>更直接的做法是树状数组直接暴力维护范围内有几个（前缀和）。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>考虑将矩阵转为序列，在序列上操作方便得多。</p>
<pre class="line-numbers"><code class="language-cpp">#define trans(i, j) (((j) - 1) * n + (i))
int n, m, q;
char map[1000001];

int main() {
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
    int cnt = 0;
    for (int i = 1, k = 0; i &lt;= n; ++i) {
        for (int j = 1; j &lt;= m; ++j) {
            std::cin &gt;&gt; map[trans(i, j)];
            if (map[trans(i, j)] == '*') ++cnt;
        }
    }
    int ans = cnt;
    for (int i = 1; i &lt;= cnt; ++i)
        if (map[i] == '*')
            --ans;

    while (q--) {
        int x, y;
        std::cin &gt;&gt; x &gt;&gt; y;
        int idx = trans(x, y);
        if (map[idx] == '.') {
            ++cnt;
            if (map[cnt] == '*') --ans;
            if (idx &gt; cnt) ++ans;
            map[idx] = '*';
        } else {
            map[idx] = '.';
            if (idx &gt; cnt) --ans;
            if (map[cnt] == '*') ++ans;
            --cnt;
        }
        std::cout &lt;&lt; ans &lt;&lt; '\n';
    }
    return 0;
}
</code></pre>
<hr />
<h2><a id="1674e-breaking-the-wall" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1674E Breaking the Wall</h2>
<p><tc><m>Medium- *2000</m><t>数学</t><t>贪心</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>形象一点，我们的答案的来源只有可能是这几种情况：</p>
<ul>
<li>火力全开。即对数列中最小的两个每次杀掉 2。适用于数列中最小的两个数分隔较远的情况。</li>
<li>投机取巧。相隔一个数的两个奇数，先通过杀中间的那个数一次转为偶数，然后转为「火力全开」型。</li>
<li>互帮互助。杀掉相邻两个数，互相凑一凑，答案就是两个数和除以 3 向上取整。但当一个数 \(a\) 大于另一个数 \(b\) 的两倍时，此方法只能妥协，答案为 \(\lceil \dfrac a 2 \rceil\)。</li>
</ul>
<p>当被杀的两个数距离大于等于 2 的时候，可以做到各杀各的互不干涉，归于「火力全开」型。</p>
<p>当被杀的两个数距离等于 1 的时候，适用「火力全开」型或「投机取巧」型（总结起来就是两个数加起来除以二向上取整）。</p>
<p>当被杀的两个数相邻，那必然属于「互帮互助」型。</p>
<p>因此，以上三种得到答案的类型覆盖所有的情况，解法是正确的。</p>
<p>这个题叉麻了，300 多测试点，乐死了。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n, a[200001];

int upper(int a, int b) {
    if (a % b) return a / b + 1;
    else return a / b;
}

int main() {
    n = read();
    for (int i = 1; i &lt;= n; ++i) {
        a[i] = read();
    }

    int t3 = 1000000;
    for (int i = 1; i &lt;= n - 1; ++i) {
        int res = 0;
        if (a[i] &gt; a[i + 1] * 2) res = (a[i] + 1) / 2;
        else if (a[i + 1] &gt; a[i] * 2) res = (a[i + 1] + 1) / 2;
        else res = upper(a[i] + a[i + 1], 3);
        t3 = std::min(t3, res);
    }

    int t2 = 1000000;
    for (int i = 1; i &lt;= n - 2; ++i)
        if ((a[i] &amp; 1) &amp;&amp; (a[i + 2] &amp; 1))
            t2 = std::min(t2, 1 + a[i] / 2 + a[i + 2] / 2);

    std::sort(a + 1, a + n + 1);
    int t1 = (a[1] + 1) / 2 + (a[2] + 1) / 2;

    printf(&quot;%d\n&quot;, std::min({t1, t2, t3}));
    return 0;
}
</code></pre>
<hr />
<h2><a id="1674g-remove-directed-edges" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1674G Remove Directed Edges</h2>
<p><tc><m>Medium+ *2000</m><t>图论</t><t>拓扑</t><t>DP</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>首先回顾一下「Cute Set」的定义：</p>
<blockquote>
<p>一个顶点的集合 \(S\) 被称作可爱的当且仅当任意两个顶点 \(v\) 和 \(u\)（\(v \neq u,v \in S,u \in S\)），可以经过由未删除的边组成的路径由 \(u\) 达到 \(v\)，或是从 \(v\) 达到 \(u\)。</p>
</blockquote>
<p>由于原图是一个 DAG，集合中点和未删除的边构成的也是一个 DAG。由 DAG 联想到可以进行拓扑排序。拓扑序中，任何一对相邻的顶点 \((i, i+1)\)，都满足：由 \(i\) 可以通过一条路径到达 \(i+1\)，或是由 \(i+1\) 可以通过条路径到达 \(i\)。若是后者，则 \(i+1\) 在拓扑序中，必位于 \(i\) 之前，矛盾。因此拓扑序中，总可以由靠前的顶点经过一些边到达靠后的顶点。由此推出一个重要的结论：<strong>存在一条经过一个 Cute Set 中所有顶点的路径，一条路径经过的顶点的集合也是一个 Cute Set</strong>。</p>
<p>问题转化为：在 DAG 中找一条最长路，且经过的边均未删除。</p>
<p>转化为一个更简单直白问题后，再来看删边的条件。每个顶点要么没有入边，要么被删一条入边，出边同理。下面思考的问题是，在选择路径的时候，哪些顶点可以被加入集合中？路径对于一个顶点而言，就是一条入边和一条出边。在保留这条路径不能删的同时，它还要预留可以删除的入边、出边各一条，以满足题意。因此，第二个重要的结论是：除了路径的起点没有入度要求、路径的终点没有出度要求以外，对于路径上每一个点的要求是至少分别有两条入边和两条出边，即<strong>对于路径上的每一条边 \(u \to v\)，都要满足 \(out_u&gt;1\) 且 \(in_v&gt;1\)</strong>。</p>
<p>对于 DAG 上最长路问题，直接在拓扑序上 DP 即可，具体方法不再赘述。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n, m;
int ind[200001], oud[200001], del[200001];
std::vector&lt;int&gt; e[200001];
std::queue&lt;int&gt; q;
int f[200001];

int main() {
    n = read(), m = read();
    while (m--) {
        int u = read(), v = read();
        ++ind[v], ++del[v], ++oud[u];
        e[u].push_back(v);
    }
    for (int i = 1; i &lt;= n; ++i) {
        f[i] = 1;
        if (!del[i]) q.push(i);
    }
    int ans = 1;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        ans = std::max(ans, f[u]);
        for (int v : e[u]) {
            if (ind[v] &gt; 1 &amp;&amp; oud[u] &gt; 1)
                f[v] = std::max(f[v], f[u] + 1);
            if (!--del[v])
                q.push(v);
        }
    }
    printf(&quot;%d\n&quot;, ans);
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LGR108]]></title>
    <link href="oi.afobject.ml/LGR108.html"/>
    <updated>2022-05-01T23:13:15+08:00</updated>
    <id>oi.afobject.ml/LGR108.html</id>
    <content type="html"><![CDATA[
<h2><a id="c-sunset-p8320" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>C Sunset - P8320</h2>
<p><tc><e>Easy</e><t>交互</t><t>二分</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>观察 \(a\) 数列的变化趋势，那必然是先上升后不变，不变的那个点为当前数列的最大值。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int main() {
    cin &gt;&gt; T;
    while (T--) {
        cin &gt;&gt; n;
        for (int i = n; i; --i) {
            int last = query(n);
            int l = 1, r = n;
            while (l &lt; r) {
                const int mid = (l + r) / 2;
                if (query(mid) &lt; last) l = mid + 1;
                else r = mid;
            }
            ans[l] = i;
            cout &lt;&lt; &quot;? 2 &quot; &lt;&lt; l &lt;&lt; endl;
        }
        cout &lt;&lt; &quot;! &quot;;
        for (int i = 1; i &lt;= n; ++i)
            cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot;;
        cout &lt;&lt; endl;
    }
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces Round #785 (Div.2)]]></title>
    <link href="oi.afobject.ml/cf1673.html"/>
    <updated>2022-05-01T00:58:35+08:00</updated>
    <id>oi.afobject.ml/cf1673.html</id>
    <content type="html"><![CDATA[
<p>[3/6] Rated, 1/6, \(1448 \to 1364\)，我是天下第一🎤，哈哈哈哈！！！！！！！！！B 都不会！！！</p>
<span id="more"></span><!-- more -->
<h2><a id="1673b-a-perfectly-balanced-string" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1673B A Perfectly Balanced String?</h2>
<p><tc><m>Medium- *1100</m><t>结论</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>五花八门。</p>
<p>你找一个长度最短且首尾字符相同的，此时首尾字符出现的次数为 \(2\)，那么中间的次数只能是 \(1\) 咯，必须每个都轮一遍。轮不到的寄。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>这个 <code>last</code> 的用法还挺妙的。</p>
<pre class="line-numbers"><code class="language-cpp">int T;
char s[200003];
bool e[27];
int last[27];

int main() {
    scanf(&quot;%d&quot;, &amp;T);
    while (T--) {
        scanf(&quot;%s&quot;, s);
        const int len = strlen(s);
        for (int i = 0; i &lt; 27; i++)
            e[i] = false;
        for (int i = 0; i &lt; len; i++)
            e[s[i] - 'a'] = true;
        int kind = 0;
        for (int i = 0; i &lt; 26; i++)
            kind += e[i], last[i] = -1;
        for (int i = 0; i &lt; len; i++) {
            if (last[s[i] - 'a'] != -1) {
                if (i - last[s[i] - 'a'] != kind) {
                    puts(&quot;NO&quot;);
                    goto end;
                }
            }
            last[s[i] - 'a'] = i;
        }
        puts(&quot;YES&quot;);
        end: continue;
    }
    return 0;
}
</code></pre>
<hr />
<h2><a id="1673c-palindrome-basis" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1673C Palindrome Basis</h2>
<p><tc><m>Medium- *1500</m><t>背包</t><t>DP</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>考虑设 \(f(i,j)\) 为在前 \(i\) 个回文数中（第 \(i\) 个为 \(p_i\)），凑出来数 \(n\) 的方案数。则有：</p>
\[f(i,j)=f(i-1,j)+f(i,j-p_i)
\]
<p>考虑省去一维。</p>
\[f(j)\gets f(j)+f(j-p_i)
\]
<p>\(f(0)=1\)。</p>
<p>关于循环顺序：两维的时候你爱咋地咋地，但一维的时候省去了 \(i\) 这维，所以大前提就是在虚拟遍历 \(i\) 只不过没在转移方程里体现出来，\(i\) 必须放在外层，否则就会对 \(f(j)\) 的值产生影响。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">signed main() {
    T = read(); f[0] = 1;
    for (int k = 0; k &lt; P; ++k)
        for (int i = p[k]; i &lt;= 50000; ++i)
            f[i] = (f[i] + f[i - p[k]]) % MOD;
    while (T--)
        printf(&quot;%lld\n&quot;, f[read()]);
}
</code></pre>
<hr />
<h2><a id="1673d-lost-arithmetic-progression" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1673D Lost Arithmetic Progression</h2>
<p><tc><m>Medium+ *1900</m><t>数学</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>由题意直接得出：由公差为 \(d_0,d_1\) 的两个等差数列合成的新等差数列的公差必定为 \(d'=\operatorname{lcm}(d_0,d_1)\)，也就是说 \(d_0 \mid d'\)，\(d_1 \mid d'\)。设这三个等差数列的数的集合分别为 \(A,B,C\)，则 \(A \in C\)，\(B \in C\)。</p>
<p>无解的情况很方便判断，即 \(\exists x \in C\) 满足 \(x\notin B\)，即满足以下条件之一：</p>
<ul>
<li>\(d_B \not\mid d_C\)</li>
<li>\(C_1 \notin B\) 或 \(C_n \notin B\)</li>
</ul>
<p>接下来看有几个解。乍一看好像都是无数个解，但由于 \(A \cap B\) 中不能有 \(C\) 以外的元素，所以 \(A\) 只能在 \(C\) 限定的范围内蠕动，<strong>不得在 \(C\) 之外与 \(B\) 有交点</strong>。而 \(A\) 与 \(B\) 在 \(C\) 左侧第一个交点显然是 \(C_0\) 即 \(C_1-d_C\)（如果 \(B\) 的左端点大于这个那么 \(A\) 可以向左无限延长，无数个解），中间（从 \(C_0+1\) 到 \(C_1\)）放得下的 \(A\) 的个数显然是 \(\dfrac {d_C} {d_A}\)，\(C\) 右侧同理。因此，对于每一个 \(d_A\) 使得 \(\operatorname{lcm}(d_A,d_B)=d_C\)，答案为 \(\left(\dfrac {d_C} {d_A}\right)^2\)。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">#define int __int128
#define MOD 1000000007

int T;
struct AP {
    int s, d, n;
    int get(int i) { return (i - 1) * d + s; }
    int last() { return get(n); }
    bool in(int x) {
        if (s &lt;= x &amp;&amp; x &lt;= last() &amp;&amp; (x - s) % d == 0) return true;
        else return false;
    }
} b, c;

int gcd(int a, int b) {
    return a % b ? gcd(b, a % b) : b;
}
int lcm(int a, int b) {
    return a / gcd(a, b) * b;
}

signed main() {
    T = read();
    while (T--) {
        b.s = read(), b.d = read(), b.n = read();
        c.s = read(), c.d = read(), c.n = read();
        if (c.d % b.d || !b.in(c.s) || !b.in(c.last()))
            puts(&quot;0&quot;);
        else if (b.s &gt; c.get(0) || b.last() &lt; c.get(c.n + 1))
            puts(&quot;-1&quot;);
        else {
            int ans = 0;
            for (int x = 1; x * x &lt;= c.d; ++x) {
                if (lcm(x, b.d) == c.d)
                    ans = (ans + (c.d / x) * (c.d / x)) % MOD;
                if (x * x != c.d &amp;&amp; lcm(c.d / x, b.d) == c.d)
                    ans = (ans + x * x) % MOD;
            }
            printf(&quot;%lld\n&quot;, (long long)ans);
        }
    }
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x113 单调栈]]></title>
    <link href="oi.afobject.ml/0x113.html"/>
    <updated>2022-04-27T21:35:55+08:00</updated>
    <id>oi.afobject.ml/0x113.html</id>
    <content type="html"><![CDATA[
<h2><a id="largest-rectangle-in-a-histogram" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Largest Rectangle in a Histogram</h2>
<p><tc><c>0x1104</c><e>Easy+</e><t>单调栈</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>考虑对于每一个 \(x\) 坐标，都尝试找出以它为右边界的最大的矩形的面积。那么可能成为答案的矩形在左侧一定终止于在它左侧，且比它矮的一个位置。所以在它左侧，且比它高的东西没有用，直接用单调栈扔掉就行。</p>
<p>在原位置在 \(i\) 的一个数 \(k\) 在位置 \(j\) 时被推出栈的时候统计答案，答案为 \((j-i+d(k))\times k\)，其中 \(d(k)\) 代表这个数 \(k\) 顶掉的数的个数（即不在栈中，但可以算进矩形的宽的数，包括直接顶掉和间接顶掉）。在整个数列末尾追加一个 0，顶掉所有数。</p>
<p>按照书上做法，其实也可以把被顶掉的压一压高度，栈内宽度不变，这样就不用分「直接顶掉」和「间接顶掉」了，不过差不多。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n, a;
std::stack&lt;std::pair&lt;int, int&gt;&gt; s;
int d[1000001];

int main() {
    while (true) {
        n = read();
        if (!n) break;
        for (int i = 1; i &lt;= n; ++i) d[i] = 0;
        while (s.size()) s.pop();
        long long ans = 0;
        for (int i = 1; i &lt;= n + 1; i++) {
            a = (i &lt;= n) ? read() : 0;
            while (s.size() &amp;&amp; s.top().second &gt; a) {
                const int u = s.top().first, h = s.top().second;
                ans = std::max(ans, (long long)(i - u + d[u]) * h), d[i] += d[u] + 1;
                s.pop();
            }
            s.push({i, a});
        }
        printf(&quot;%lld\n&quot;, ans);
    }
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x112 表达式求值]]></title>
    <link href="oi.afobject.ml/0x112.html"/>
    <updated>2022-04-27T08:36:45+08:00</updated>
    <id>oi.afobject.ml/0x112.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E4%B8%BA%E5%90%8E%E7%BC%80%E6%B1%82%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>中缀表达式转为后缀求值</h2>
<p>首先举个例子：</p>
<p>中缀：<code>3 * (1 - 2)</code><br />
后缀：<code>3 1 2 - *</code></p>
<p>所有数的顺序肯定是一样的，然后就是运算符的问题（不管括号），同一优先级的情况下（如 <code>1 + 1 - 4</code> \(\to\) <code>1 1 4 - +</code>）就可以把运算符倒序输出，如果非同一优先级（如 <code>5 * 1 + 4</code> \(\to\) <code>5 1 * 4 +</code>），那就在一个运算符入栈的同时，看一下有没有比它优先级高的在栈里，如果有，顶掉输出。</p>
<p>现在考虑括号问题，括号内当一个子问题求解就行了（碰到一个右括号就把左括号及之后的所有内容输出，有点像递归的栈的写法）。</p>
<pre class="line-numbers"><code class="language-cpp">std::string s;
std::stack&lt;char&gt; st;
int priority[151];

int type[100001], n = 0;
double m[100001]; char o[100001];
std::stack&lt;double&gt; h;

int main() {
    std::cin &gt;&gt; s;
    s = '(' + s + ')';

    priority['*'] = priority['/'] = 2;
    priority['+'] = priority['-'] = 1;
    priority[')'] = 3; priority['('] = 0;

    double num = 0.0; bool flag = false;
    for (char x : s) {
        if (x &gt;= '0' &amp;&amp; x &lt;= '9') {
            flag = true;
            num *= 10, num += x - '0';
        } else {
            if (flag)
                type[++n] = 1, m[n] = num,
                num = 0, flag = false;
            if (x == ')')  {
                while (st.top() != '(')
                    type[++n] = 2, o[n] = st.top(), st.pop();
                st.pop();
                continue;
            } else if (x != '(') {
                while (st.size() &amp;&amp; priority[st.top()] &gt;= priority[x])
                    type[++n] = 2, o[n] = st.top(), st.pop();
            }
            st.push(x);
        }
    }

    for (int i = 1; i &lt;= n; ++i) {
        if (type[i] == 1) {
            h.push(m[i]);
        } else {
            double rhs = h.top(); h.pop();
            double lhs = h.top(); h.pop();
            if (o[i] == '+') h.push(lhs + rhs);
            if (o[i] == '-') h.push(lhs - rhs);
            if (o[i] == '*') h.push(lhs * rhs);
            if (o[i] == '/') h.push(lhs / rhs);
        }
    }

    std::cout &lt;&lt; h.top() &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<h2><a id="%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E9%80%92%E5%BD%92%E6%B3%95%E6%B1%82%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>中缀表达式的递归法求值</h2>
<p>这个比较简单好写，但时间复杂度是平方的。</p>
<pre class="line-numbers"><code class="language-cpp">std::string s;

double solve(int l, int r) {
    int add = -1, mul = -1, t = 0;
    for (int i = r; i &gt;= l; --i) {
        if (s[i] == ')') ++t;
        else if (s[i] == '(') --t;
        if (t == 0 &amp;&amp; add == -1 &amp;&amp; (s[i] == '+' || s[i] == '-'))
            add = i;
        if (t == 0 &amp;&amp; mul == -1 &amp;&amp; (s[i] == '*' || s[i] == '/'))
            mul = i;
    }
    if (add != -1) {
        if (s[add] == '+') return solve(l, add - 1) + solve(add + 1, r);
        else return solve(l, add - 1) - solve(add + 1, r);
    } else if (mul != -1) {
        if (s[mul] == '*') return solve(l, mul - 1) * solve(mul + 1, r);
        else return solve(l, mul - 1) / solve(mul + 1, r);
    } else if (s[l] == '(' &amp;&amp; s[r] == ')') {
        return solve(l + 1, r - 1);
    } else {
        double ans = 0;
        for (int i = l; i &lt;= r; i++) {
            ans *= 10;
            ans += s[i] - '0';
        }
        return ans;
    }
}

int main() {
    std::cin &gt;&gt; s;
    std::cout &lt;&lt; solve(0, s.size() - 1) &lt;&lt; std::endl;
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x111 栈基础]]></title>
    <link href="oi.afobject.ml/0x111.html"/>
    <updated>2022-04-25T08:20:03+08:00</updated>
    <id>oi.afobject.ml/0x111.html</id>
    <content type="html"><![CDATA[
<h2><a id="push-pop-getmin" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Push, Pop, GetMin</h2>
<p><tc><c>0x1101</c><e>Easy-</e><t>栈</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>维护两个栈，一个是题目中给出的栈，一个保存每个时刻最小值。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">class MinStack {
public:
    std::stack&lt;int&gt; o, m;
    MinStack() {}
    void push(int x) {
        o.push(x);
        if (m.size())
            m.push(std::min(m.top(), x));
        else
            m.push(x);
    }
    void pop() {
        o.pop();
        m.pop();
    }
    int top() {
        return o.top();
    }
    int getMin() {
        return m.top();
    }
};
</code></pre>
<hr />
<h2><a id="editor" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Editor</h2>
<p><tc><c>0x1102</c><e>Easy</e><t>栈</t><t>模拟</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>考虑建立对顶栈，这样前四种操作都可以实现。</p>
<p>对于第五种操作，可以再建立两个栈，一个保存所有时刻的前缀和，另一个用 0x1101 的方式维护最小值，只不过这里要用数组模拟栈（需要直接访问）。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>注意第一个数为负数时的处理。</p>
<pre class="line-numbers"><code class="language-cpp">int n;
std::stack&lt;int&gt; a, b;
int s[1000001], f[1000001], top;

void pushA(int t) {
    a.push(t);
    s[top + 1] = s[top] + t;
    if (top) f[top + 1] = std::max(f[top], s[top + 1]);
    else f[top + 1] = s[top + 1];
    ++top;
}

void popA() {
    a.pop();
    --top;
}

int main() {
    std::cin &gt;&gt; n;
    while (n--) {
        char c; int t;
        std::cin &gt;&gt; c;
        switch (c) {
            case 'I':
                std::cin &gt;&gt; t; pushA(t);
                break;
            case 'D':
                if (a.size()) popA();
                break;
            case 'L':
                if (a.size()) b.push(a.top()), popA();
                break;
            case 'R':
                if (b.size()) pushA(b.top()), b.pop();
                break;
            case 'Q':
                std::cin &gt;&gt; t;
                std::cout &lt;&lt; f[t] &lt;&lt; std::endl;
                break;
        }
    }
    return 0;
}
</code></pre>
<hr />
<h2><a id="%E8%BF%9B%E5%87%BA%E6%A0%88%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>进出栈序列问题</h2>
<p><tc><c>0x1103</c><m>Medium</m><t>栈</t><t>数学</t><t>DP</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%951" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法 1</h3>
<p>\(O(n^2)\)。</p>
<p>设 \(f(k)\) 为 \(n=k\) 时的答案。显然，\(f(0)=f(1)=1,f(2)=2\)。</p>
<p>假设最后一个出栈的选手是 \(k\)。一个数入栈时，栈里不可能有比它还大的数，如果想要压着 \(k\) 留到最后一个出栈，那必须把比它小的先踢掉，让它到栈底。因此在它之前入栈的共有 \(f(k-1)\) 种排列方式，跳过它，比它大的共有 \(f(n-k)\) 种方式。总方案数是</p>
\[\sum_{k=1}^nf(k-1) \cdot f(n-k)
\]
<p>这样的拆分是可行的。同样，也可以分析 \(1\) 来得到这个结论。</p>
<h3><a id="%E7%AE%97%E6%B3%952" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法 2</h3>
<p>\(O(n^2)\)。</p>
<p>设 \(f(i,j)\) 为其中出了 \(i\) 个，还有 \(j\) 个没出的方案数。目标状态为 \(f(n,0)\)。</p>
<p>每一步要么弹入一个，要么弹出栈顶。</p>
\[f(i,j)=f(i-1,j+1)+f(i,j-1)
\]
<h3><a id="%E7%AE%97%E6%B3%953" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法 3</h3>
<p>这玩意就是卡特兰数。</p>
\[Cat_n=\dfrac{2n \choose n}{n+1}
\]
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>贺就完了。</p>
<pre class="line-numbers"><code class="language-python">from math import factorial
n = int(input())
a = factorial(2 * n)
b = factorial(n)
print(a // b // b // (n + 1))
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ABC249]]></title>
    <link href="oi.afobject.ml/abc249.html"/>
    <updated>2022-04-23T20:54:17+08:00</updated>
    <id>oi.afobject.ml/abc249.html</id>
    <content type="html"><![CDATA[
<p>为什么每次打 ABC 都碰上蓝色的 E（恼）</p>
<p>Rated, 4/8, 977 \(\to\) 987</p>
<span id="more"></span><!-- more -->
<h2><a id="d-index-trio" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>D Index Trio</h2>
<p><tc><m>Medium- *983</m><t>数论</t><t>组合</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%951" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法 1</h3>
<p>从乘积出发。</p>
<p>考虑对于每一个数，根号复杂度分解质因数。如果分到的恰好都是数列里的数，则答案加上两边出现次数的乘积再乘以二。有一些小细节。</p>
<h3><a id="%E7%AE%97%E6%B3%952" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法 2</h3>
<p>从乘数出发。</p>
<p>在记录每个数的出现次数后，对于每对 \((i,j)\)，答案直接加上 \(c_i \cdot c_j \cdot c_{i \times j}\)。时间复杂度能过。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>（算法 1）</p>
<pre class="line-numbers"><code class="language-cpp">#define int long long

int n;
int b[1000001];

signed main() {
    n = read();
    for (int i = 1; i &lt;= n; i++)
        ++b[read()];
    int ans = 0;
    for (int i = 1; i &lt;= 200000; i++) {
        if (!b[i]) continue;
        for (int x = 1; x * x &lt;= i; ++x)
            if (i % x == 0)
                if (b[x] &amp;&amp; b[i / x]) {
                    if (x * x == i) ans += b[i] * b[x] * b[x];
                    else ans += b[i] * b[x] * b[i / x] * 2;
                }
    }
    printf(&quot;%lld\n&quot;, ans);
    return 0;
}
</code></pre>
<hr />
<h2><a id="f-ignore-operations" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>F Ignore Operations</h2>
<p><tc><m>Medium *1786</m><t>堆</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>考虑一下如果一定要删一个操作，那么肯定是看一下删哪个对最终的结果最好。如果该操作后面有替换操作，那么屁用没有；否则对最终答案的贡献就是进行到那一步和前一步操作后的结果差。</p>
<p>那如果一定要删两个呢？</p>
<p>在替换操作前面删屁用没有。所以要么在这之后选 \(y\) 最小的两个修改操作，要么就干脆直接把这个替换操作删了。所以有三种：</p>
<ul>
<li>在最后一个替换操作后面选两个 \(y\) 最小的删；</li>
<li>删了最后一个替换操作，然后在倒数第二个后面选一个最小的删；</li>
<li>直接删掉最后两个替换操作。</li>
</ul>
<p>扩展到选 \(k\) 个删，且没必要删完：</p>
<ul>
<li>在最后一个替换操作后面选至多 \(k\) 个 \(y\) 最小且为负的删；</li>
<li>删了最后一个替换操作，然后在倒数第二个后面选至多 \(k-1\) 个最小且为负的删；</li>
<li>……</li>
<li>把最后 \(k\) 个替换操作全删了（如果有）。</li>
</ul>
<p>在以上 \(k+1\) 种答案中选一个最小的即可。到这里时间复杂度为 \(O(n \log n + k^2)\)，不太行。</p>
<p>接下来考虑怎么更高效地维护信息。可以从后往前，动态维护所有修改操作 \(y\) 的前 \(k\) 小，并维护这个顺序，碰到一个替换操作的时候就可以计算出一种可能的答案了。</p>
<p>设两个相邻的替换操作在 \(i,j\) 这两个位置，并且我已经在 \((j,n]\) 范围内的修改操作中找到了删去最优的 \(k\) 个的和。我现在要找 \((i,n]\) 范围内最优 \(k-1\) 个的和。这个相对比较容易，首先先踢出去一个，然后优先队列（大根堆）维护就行了（同时另外维护一个总和），在 \((i,j)\) 的修改操作中碰到有比优先队列中相对最不优的那个更优的，把它顶掉就行了。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n, k;
std::stack&lt;int&gt; rep;
std::priority_queue&lt;long long&gt; q;
long long t[200005], y[200005];
long long suf[200005];

int main() {
    n = read(), k = read();
    rep.push(0);
    for (int i = 1; i &lt;= n; i++) {
        t[i] = read(), y[i] = read();
        if (t[i] == 1)
            rep.push(i);
    }

    for (int i = n; i; --i)
        if (t[i] == 2)
            suf[i] = suf[i + 1] + y[i];
        else
            suf[i] = suf[i + 1];

    int now, last = n;
    long long sum = 0, ans = -1e18;
    do {
        now = rep.top() + 1;
        rep.pop();
        for (int i = now; i &lt;= last; ++i)
            if (t[i] == 2 &amp;&amp; y[i] &lt; 0) {
                if (q.size() &lt; k) {
                    sum += y[i];
                    q.push(y[i]);
                } else if (k &amp;&amp; q.top() &gt; y[i]) {
                    sum += y[i] - q.top();
                    q.pop();
                    q.push(y[i]);
                }
            }
        ans = std::max(ans, y[now - 1] + suf[now] - sum);
        last = now - 2;
        if (k &amp;&amp; q.size() == k) sum -= q.top(), q.pop();
        --k;
    } while (k &gt;= 0 &amp;&amp; rep.size());

    printf(&quot;%lld\n&quot;, ans);
    return 0;
}
</code></pre>
<hr />
<h2><a id="e-rle" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>E RLE</h2>
<p><tc><m>Medium+ *1970</m><t>DP</t><t>前缀和</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>设 \(f(i,j)\) 为原长为 \(i\)，压缩后长为 \(j\) 的个数。</p>
<p>接下来考虑转移。首先假如连续段长度都只有个位数，则</p>
\[f(i,j)=\sum_{k=1}^9 f(i-k,j-2)
\]
<p>扩展：</p>
\[\begin{aligned}
f(i,j)&amp;=\sum_{k=1}^i f(i-k,j-\lfloor\log_{10}(k)\rfloor-1)
\end{aligned}
\]
<p>\(k\) 从 \(1\) 到 \(i\) 的遍历相当于逐个尝试这个字符串最后连续相同字符的个数。</p>
<p>但上面这个方程不完全对，还要考虑到每个字符都不一样，转移时都要乘上系数 \(25\)。</p>
<p>但是这样的效率还是不够高，我们考虑对于 \(f\) 的每一行进行一个前缀和，由于 \(i,j\) 显然最多只是四位数，状态转移方程变为：</p>
\[\begin{aligned}
f(i,j)&amp;=25 \cdot [ s(i-1,j-2)-s(i-10,j-2)\\
&amp;+s(i-10,j-3)-s(i-100,j-3)\\
&amp;+s(i-100,j-4)-s(i-1000,j-4)\\
&amp;+s(i-1000,j-5)-s(i-10000,j-5) ]
\end{aligned}
\]
<p>计数的时候从小到大对于每个 \(i\) 分别讨论，注意到当原长为 \(i\) 时，\(j\) 至少为 \(\lfloor \log_{10}(i)  \rfloor+1\)，因此初始值 \(f(i,\lfloor \log_{10}(i)\rfloor+1)=26\)，其余的直接 \(0\)，懒得考虑边界问题。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">long long n, p; // npk48
long long f[3005][3005], s[3005][3005];

int len(int x) {
    if (x &lt; 10) return 2;
    if (x &lt; 100) return 3;
    if (x &lt; 1000) return 4;
    return 5;
}

int main() {
    n = read(), p = read();
    for (int i = 1; i &lt;= n; ++i) {
        f[i][len(i)] = 26ll;
        for (int j = 1; j &lt; n; ++j) {
            f[i][j] = M(f[i][j] + 25ll * (s[T(i - 1)][T(j - 2)]     - s[T(i - 10)][T(j - 2)]));
            f[i][j] = M(f[i][j] + 25ll * (s[T(i - 10)][T(j - 3)]    - s[T(i - 100)][T(j - 3)]));
            f[i][j] = M(f[i][j] + 25ll * (s[T(i - 100)][T(j - 4)]   - s[T(i - 1000)][T(j - 4)]));
            f[i][j] = M(f[i][j] + 25ll * (s[T(i - 1000)][T(j - 5)]  - s[T(i - 3001)][T(j - 5)]));
            s[i][j] = M(s[i - 1][j] + f[i][j]);
        }
    }
    long long ans = 0;
    for (int i = 1; i &lt; n; ++i)
        ans = M(ans + f[n][i]);
    printf(&quot;%lld\n&quot;, ans);
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x00 索引]]></title>
    <link href="oi.afobject.ml/0x00-.html"/>
    <updated>2022-04-23T11:01:36+08:00</updated>
    <id>oi.afobject.ml/0x00-.html</id>
    <content type="html"><![CDATA[
<h2><a id="0x01" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>0x01</h2>
<table>
<thead>
<tr>
<th>题目</th>
<th>一句话题解</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x0101</td>
<td>快速幂板子，通过二进制拆分 \(b\) 证明结论。</td>
</tr>
<tr>
<td>0x0102</td>
<td>模拟。</td>
</tr>
<tr>
<td>0x0103</td>
<td>快速幂改快速乘。</td>
</tr>
<tr>
<td>0x0104</td>
<td>状压 DP 板子，设 \(f(i,u)\) 为经过的点集为 \(i\)，且当前点为 \(u\) 时的最短路长度，容易推出转移方程。</td>
</tr>
<tr>
<td>0x0105</td>
<td>从高到低对于每一位分别讨论，如果该位不确定，则在 \(m\) 的限制条件下尽量让它变成 1。</td>
</tr>
</tbody>
</table>
<h2><a id="0x02" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>0x02</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ABC248]]></title>
    <link href="oi.afobject.ml/abc248.html"/>
    <updated>2022-04-16T23:32:16+08:00</updated>
    <id>oi.afobject.ml/abc248.html</id>
    <content type="html"><![CDATA[
<p>VP</p>
<span id="more"></span><!-- more -->
<h2><a id="e-k-colinear-line" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>E K-colinear Line</h2>
<p><tc><m>Medium- *1292</m><t>计算几何</t><t>STL</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>主要问题在于如何精确、省力地表示一条直线。</p>
<p>对于过点 \((x_1,y_1),(x_2,y_2)\) 的直线，设其为 \(y=kx+b\)，则有 \(k=\dfrac{y_2-y_1}{x_2-x_1}\)，\(b=\dfrac{y_1x_2-y_2x_1}{x_2-x_1}\)。下面那个分母实在是太烦了，消掉，于是就变成了 \((x_2-x_1)y=(y_2-y_1)x+y_1x_2-y_2x_1\)。</p>
<p>于是可以用 \(x_2-x_1\)，\(y_2-y_1\)，\(y_1x_2-y_2x_1\) 这三个东西（全部除去 \(\gcd\)，且使 \(x_2-x_1\) 非负）来鉴定一条直线。可以使用 <code>std::tuple</code>。</p>
<p>这也正好解决了平行于 \(x\) 轴的直线的问题。</p>
<p>可以使用 <code>std::multiset</code> 维护信息。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">#define int long long

int n, k;
int x[301], y[301];

std::multiset&lt;std::tuple&lt;int, int, int&gt;&gt; m;
int t[90001];

auto line(int i, int j) {
    int a = x[i] - x[j];
    int b = y[i] - y[j];
    int c = x[j] * y[i] - x[i] * y[j];
    if (a &lt; 0) a = -a, b = -b, c = -c;
    const int g = gcd(a, gcd(b, c));
    a /= g, b /= g, c /= g;
    return std::make_tuple(a, b, c);
}

signed main() {
    n = read(), k = read();
    if (k == 1) return puts(&quot;Infinity&quot;), 0;
    for (int i = 1; i &lt;= n; ++i)
        x[i] = read(), y[i] = read();
    for (int i = 1; i &lt; n; ++i)
        for (int j = i + 1; j &lt;= n; ++j)
            m.insert(line(i, j));
    for (int i = 1; i &lt;= n; ++i)
        t[i * (i - 1) / 2] = i;
    int ans = 0;
    for (auto i = m.begin(); i != m.end(); i = m.upper_bound(*i))
        ans += (t[m.count(*i)] &gt;= k);
    printf(&quot;%lld\n&quot;, (int)ans);
    return 0;
}
</code></pre>
<hr />
<h2><a id="f-keep-connect" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>F Keep Connect</h2>
<p><tc><m>Medium+ *1828</m><t>DP</t><t>图论</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p><strong>考虑一个子图 \(G_k\)</strong>，它包含点 \((1,1),(1,2)\) 至 \((k,1),(k,2)\)。在 DP 进行过程中，它的 \((k-1,1) \to (k,1)\)，\((k,1) \to (k,2)\) 和 \((k-1,2) \to (k,2)\) 这三条边（分别叫做 \(a,b,c\) 边）未确定是否存在。</p>
<p><strong>考虑它在什么情况下才能让最终的图连通。</strong> 第一种是它本身连通；第二种是它有两个连通块，分别包含 \((k,1)\) 和 \((k,2)\)（注意一个点也算一个连通块！）。</p>
<p>接下来设计状态。\(f(k,j,s)\) 为 DP 进行到 \(G_k\) 时，已删了 \(j\) 条边，且连通状态为 \(s\)（\(s \in \{1,2\}\)）时的答案。</p>
<p>接下来考虑转移：</p>
<ol>
<li>从 1 转移到 1。这个时候可能的状态有：\((a,b),(b,c),(a,c),(a,b,c)\)，共 4 种。</li>
<li>从 2 转移到 2。可选择的只有 \((a,c)\)。</li>
<li>从 1 转移到 2。可以选择 \(a,c\)，2 种。</li>
<li>从 2 转移到 1。只能选择 \((a,b,c)\)。</li>
</ol>
<p>因此有：</p>
\[\begin{aligned}
f(k,j,1) &amp;= 3 \cdot f(k-1,j-1,1)+f(k-1,j,1)+f(k-1,j,2) \\
f(k,j,2) &amp;= f(k-1,j-1,2)+2 \cdot f(k-1,j-2,1)
\end{aligned}
\]
<p>最后考虑初始值。\(f(1,0,1)=f(1,1,2)=1\)。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">#define int long long

int n, p;
int f[3001][3001][3];

void add(int &amp;x, int d) {
    x = (x + d) % p;
}

signed main() {
    n = read(), p = read();
    f[1][0][1] = f[1][1][2] = 1;
    for (int i = 2; i &lt;= n; ++i) {
        for (int j = 0; j &lt; n; ++j) {
            if (j &gt;= 1) add(f[i][j][1], 3 * f[i - 1][j - 1][1]);
            add(f[i][j][1], f[i - 1][j][1] + f[i - 1][j][2]);
            if (j &gt;= 1) add(f[i][j][2], f[i - 1][j - 1][2]);
            if (j &gt;= 2) add(f[i][j][2], 2 * f[i - 1][j - 2][1]);
        }
    }
    for (int i = 1; i &lt; n; ++i)
        printf(&quot;%lld &quot;, f[n][i][1]);
    putchar('\n');
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2022 联合省选]]></title>
    <link href="oi.afobject.ml/shoi-2022.html"/>
    <updated>2022-04-10T20:58:03+08:00</updated>
    <id>oi.afobject.ml/shoi-2022.html</id>
    <content type="html"><![CDATA[
<p>我为什么敢来做省选？</p>
<span id="more"></span><!-- more -->
<h2><a id="d1t1-preprocessor" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>D1T1 Preprocessor</h2>
<p><tc><e>Easy+</e><t>模拟</t></tc></p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>纯纯的模拟，每一行分别处理。</p>
<p>处理「递归」是标准的 dfs。</p>
<pre class="line-numbers"><code class="language-cpp">#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

#define isId(x) (x &gt;= '0' &amp;&amp; x &lt;= '9' || x &gt;= 'a' &amp;&amp; x &lt;= 'z' || x &gt;= 'A' &amp;&amp; x &lt;= 'Z' || x == '_')

int n;
std::map&lt;std::string, std::string&gt; dict;
std::map&lt;std::string, bool&gt; state;

void tryReplace(std::string s);
void processText(std::string s) {
    std::string current;
    for (char x : s)
        if (isId(x))
            current += x;
        else {
            tryReplace(current);
            std::cout &lt;&lt; x;
            current = &quot;&quot;;
        }
    if (current.size())
        tryReplace(current);
}

void processPreprocessor(std::string s) {
    int pos1 = s.find(&quot; &quot;);
    auto command = s.substr(1, pos1 - 1);
    if (command == &quot;define&quot;) {
        int pos2 = s.find(&quot; &quot;, pos1 + 1);
        auto id = s.substr(pos1 + 1, pos2 - pos1 - 1),
             replacement = s.substr(pos2 + 1);
        dict[id] = replacement;
    } else {
        auto id = s.substr(pos1 + 1);
        dict.erase(dict.find(id));
    }
} 

int main() {
    std::cin &gt;&gt; n;
    std::string t;
    getline(std::cin, t);
    while (n--) {
        std::string line;
        getline(std::cin, line);
        if (line[0] == '#')
            processPreprocessor(line);
        else
            processText(line);
        std::cout &lt;&lt; std::endl;
    }
    return 0;
}

void tryReplace(std::string s) {
    if (dict.find(s) != dict.end()) {
        if (!state[s])
            state[s] = true, processText(dict[s]);
        else
            std::cout &lt;&lt; s;
        state[s] = false;
    } else
        std::cout &lt;&lt; s;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x0809 ~ 0x080C]]></title>
    <link href="oi.afobject.ml/0x08-3.html"/>
    <updated>2022-04-06T07:39:26+08:00</updated>
    <id>oi.afobject.ml/0x08-3.html</id>
    <content type="html"><![CDATA[
<h2><a id="number-base-conversion" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Number Base Conversion</h2>
<p><tc><c>0x0809</c><e>Easy+</e><t>高精</t><t>模拟</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>什么模拟题乱入，，，</p>
<p>考虑随便找个数模拟一下，\(964\) 转化 7 进制：</p>
\[\begin{aligned}
964 \div 7 &amp;= 137 &amp;\ldots 5 \\
137 \div 7 &amp;= 19 &amp;\ldots 4 \\
19 \div 7 &amp;= 2 &amp;\ldots 5 \\
2 \div 7 &amp;= 2 &amp;\ldots2 \\
(964)_{10}&amp;=(2545)_7
\end{aligned}
\]
<p>其实就是高精除低精，高精取模低精。</p>
<p>后面那个很容易，再看一下前者是怎么做的。</p>
\[\begin{aligned}
\underline 9 \div 7 &amp;= 1 &amp;\ldots 2 \\
\underline{26} \div 7 &amp;= 3 &amp;\ldots5 \\
\underline{54} \div 7&amp;=7 &amp;\ldots5
\end{aligned}
\]
<p>可以发现过程中有一个很重要的中间变量 \(k\)，也就是下划线的部分。它是计算过程中原数前若干位的十进制表示形式，只不过都及时按位模了 \(7\)。</p>
<p>……还说啥呢，可以开始写了。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int T, a, b;
char s[1000001], ans[1000001];

int to10(char x) {
    if (x &gt;= '0' &amp;&amp; x &lt;= '9') return x - '0';
    if (x &gt;= 'A' &amp;&amp; x &lt;= 'Z') return x - 'A' + 10;
    return x - 'a' + 36;
}
char from10(int x) {
    if (x &lt;= 9) return x + '0';
    if (x &lt;= 35) return x - 10 + 'A';
    return x - 36 + 'a';
}

int main() {
    scanf(&quot;%d&quot;, &amp;T);
    while (T--) {
        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
        scanf(&quot;%s&quot;, s);
        printf(&quot;%d %s\n%d &quot;, a, s, b);
        int len = strlen(s), t = 0, ansSize = 0;
        while (t &lt; len) {
            int k = 0;
            for (int i = t; i &lt; len; ++i) {
                k = k * a + to10(s[i]);
                s[i] = from10(k / b);
                k %= b;
            }
            ans[++ansSize] = from10(k);
            while (t &lt; len &amp;&amp; s[t] == '0') ++t;
        }
        for (int i = ansSize; i; --i)
            printf(&quot;%c&quot;, ans[i]);
        printf(&quot;\n\n&quot;);
    }
    return 0;
}
</code></pre>
<hr />
<h2><a id="cow-acrobats" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Cow Acrobats</h2>
<p><tc><c>0x080A</c><m>Medium-</m><t>贪心</t><t>数学</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>0x0704 改编版。</p>
<p>第 \(x\) 头奶牛的风险值为 \(a=\sum\limits_{i=1}^{x-1} w_i - s_x\)。第 \(x+1\) 头牛风险值为 \(b=\sum\limits_{i=1}^{x} w_i - s_{x+1}\)。</p>
<p>最后奶牛一定是按照某个顺序排列的，一旦打破这个顺序（交换），答案一定会增加。假设第 \(x\) 头牛与第 \(x+1\) 头牛交换。</p>
<p>此时，第 \(x\) 头牛的风险值为 \(c=\sum\limits_{i=1}^{x-1} w_i+w_{x+1}-s_x\)，第 \(x+1\) 头牛的风险值为 \(d=\sum\limits_{i=1}^{x-1} w_i-s_{x+1}\)。</p>
\[\begin{aligned}
\Delta=&amp;\max\{c,d\}-\max\{a,b\}\\
=&amp;\max\{w_{x+1}-s_x, -s_{x+1}\}-\max\{-s_x, w_x - s_{x+1}\}\text{   (统加 }\sum_{i=1}^{x-1}w_i\text{ )}\\
=&amp;\max\{w_{x+1}+s_{x+1}, s_x\}-\max\{s_{x+1}, w_x + s_x\}\text{   (统加 }s_x+s_{x+1}\text{ )}
\end{aligned}
\]
<p>好好好，当 \(w_x+s_x&gt;w_{x+1}+s_{x+1}\) 时，左边 \(s_x\) 再大也铁定大不了 \(w_x+s_x\)，\(\Delta&lt;0\)，交换更优。</p>
<p>当 \(w_x+s_x &lt; w_{x+1}+s_{x+1}\) 时，同理，\(\Delta&gt;0\)，不交换更优。</p>
<p>因此，按 \(w_i+s_i\) 从小到大排序最优。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n;
struct Cow {
    int w, s;
    bool operator &lt; (const Cow &amp;rhs) const {
        return w + s &lt; rhs.w + rhs.s;
    }
} c[1000001];

int main() {
    n = read();
    for (int i = 1; i &lt;= n; ++i)
        c[i].w = read(), c[i].s = read();
    std::sort(c + 1, c + n + 1);
    int ans = -1e9, p = 0;
    for (int i = 1; i &lt;= n; ++i) {
        ans = std::max(ans, p - c[i].s);
        p += c[i].w;
    }
    printf(&quot;%d\n&quot;, ans);
    return 0;
}
</code></pre>
<hr />
<h2><a id="to-the-max" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>To The Max</h2>
<p><tc><c>0x080B</c><e>Easy</e><t>贪心</t><t>前缀和</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>考虑从一维的最大子段和转移。不就多了一个维度吗。</p>
<p>枚举矩形的上底和下底就行了。</p>
<p>时间复杂度 \(O(n^3)\)。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n;
int s[101][101];

int main() {
    n = read();
    for (int i = 1; i &lt;= n; ++i)
        for (int j = 1; j &lt;= n; ++j)
            s[i][j] = read() + s[i][j - 1];
    int ans = -1e9;
    for (int i = 1; i &lt;= n; ++i)
        for (int j = i; j &lt;= n; ++j) {
            int max = -1e9, cur = 0;
            for (int k = 1; k &lt;= n; ++k) {
                cur += s[k][j] - s[k][i - 1];
                max = std::max(max, cur);
                cur = std::max(cur, 0);
            }
            ans = std::max(ans, max);
        }
    printf(&quot;%d\n&quot;, ans);
    return 0;
}
</code></pre>
<hr />
<h2><a id="task" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Task</h2>
<p><tc><c>0x080C</c><m>Medium-</m><t>贪心</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>Ref: 0x0701</p>
<p>考虑对于每个任务以 \(x\) 为第一关键字、\(y\) 为第二关键字从大到小排序，优先保证上面的任务。</p>
<p>对于每个任务，选用 \(x,y\) 均满足要求且 \(y\) 最小的机器。这样确保对于接下来处理的任务，\(x\) 的要求都能满足，且 \(y\) 的要求也尽量能满足。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>考虑使用 <code>std::multiset</code> 维护信息。每次将 \(x\) 满足要求的取出并放入 <code>std::multiset</code> 里，用 <code>lower_bound</code> 查询符合要求且最小的 \(y\)。</p>
<pre class="line-numbers"><code class="language-cpp">int n, m;
std::pair&lt;int, int&gt; a[100001], b[100001];
std::multiset&lt;int&gt; s;

int main() {
    while (std::cin &gt;&gt; n &gt;&gt; m) {
        s.clear();
        for (int i = 1; i &lt;= n; ++i)
            std::cin &gt;&gt; a[i].first &gt;&gt; a[i].second;
        for (int i = 1; i &lt;= m; ++i)
            std::cin &gt;&gt; b[i].first &gt;&gt; b[i].second;
        std::sort(a + 1, a + n + 1);
        std::sort(b + 1, b + m + 1);
        int j = n, cnt = 0; long long ans = 0;
        for (int i = m; i; --i) {
            while (j &amp;&amp; a[j].first &gt;= b[i].first)
                s.insert(a[j--].second);
            auto it = s.lower_bound(b[i].second);
            if (it != s.end()) {
                ++cnt;
                ans += b[i].first * 500ll + b[i].second * 2;
                s.erase(it);
            }
        }
        std::cout &lt;&lt; cnt &lt;&lt; ' ' &lt;&lt; ans &lt;&lt; std::endl;
    }
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x0805 ~ 0x0808]]></title>
    <link href="oi.afobject.ml/0x08-2.html"/>
    <updated>2022-04-04T22:22:36+08:00</updated>
    <id>oi.afobject.ml/0x08-2.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E9%98%B2%E7%BA%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>防线</h2>
<p><tc><c>0x0805</c><e>Easy</e><t>二分</t><t>前缀和</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>《人工 h1》<strong>最多只有一个事奇数的位置！</strong>《/人工 h1》</p>
<p>所以直接二分出第一个出现前缀和为奇数的位置就好了。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>样例搞偷袭不讲武德！!1</p>
<pre class="line-numbers"><code class="language-cpp">#define int long long

int T, n;
int s[200001], e[200001], d[200001];

int upper(int x, int y) {
    if (x % y) return x / y + 1;
    else return x / y;
}

int sum(int x) {
    if (x &lt; 0) return 0;
    int ans = 0;
    for (int i = 1; i &lt;= n; ++i)
        if (s[i] &lt;= x)
            ans += upper(std::min(e[i], x) - s[i] + 1, d[i]);
    return ans;
}

signed main() {
    T = read();
    while (T--) {
        n = read();
        for (int i = 1; i &lt;= n; ++i)
            s[i] = read(), e[i] = read(), d[i] = read();
        int l = 0, r = 1ll &lt;&lt; 31;
        while (l &lt; r) {
            const int mid = (l + r) &gt;&gt; 1;
            if (sum(mid) &amp; 1) r = mid;
            else l = mid + 1;
        }
        if (l == 1ll &lt;&lt; 31) puts(&quot;There's no weakness.&quot;);
        else printf(&quot;%lld %lld\n&quot;, l, sum(l) - sum(l - 1));
    }
    return 0;
}
</code></pre>
<hr />
<h2><a id="corral-the-cows" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Corral the Cows</h2>
<p><tc><c>0x0806</c><c>USACO</c><e>Easy+</e><t>二分</t><t>前缀和</t><t>离散化</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>由于 \(n\) 极小，考虑离散化。</p>
<p>离散化完了以后照样二分就完了。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>注意：</p>
<ol>
<li>处理重合的点；</li>
<li>边界情况。</li>
</ol>
<pre class="line-numbers"><code class="language-cpp">int n, c;
int x[501], y[501];
int a[501], b[501];
int sizeA, sizeB;
int x1[501], y1[501];
int g[501][501];

int xid(int x) {
    return std::lower_bound(a + 1, a + sizeA, x) - a;
}
int yid(int y) {
    return std::lower_bound(b + 1, b + sizeB, y) - b;
}

bool check(int d) {
    for (int a2 = 1; a2 &lt; sizeA; ++a2)
        for (int b2 = 1; b2 &lt; sizeB; ++b2) {
            const int a1 = xid(x1[a2] - d + 1),
                      b1 = yid(y1[b2] - d + 1);
            const int sum = g[a2][b2] - g[a1 - 1][b2] - g[a2][b1 - 1] + g[a1 - 1][b1 - 1];
            if (sum &gt;= c)
                return true;
        }
    return false;
}

int main() {
    c = read(), n = read();
    for (int i = 1; i &lt;= n; ++i) {
        x[i] = a[i] = read();
        y[i] = b[i] = read();
    }

    std::sort(a + 1, a + n + 1);
    std::sort(b + 1, b + n + 1);
    sizeA = std::unique(a + 1, a + n + 1) - a;
    sizeB = std::unique(b + 1, b + n + 1) - b;
    for (int i = 1; i &lt;= n; ++i) {
        const int p = xid(x[i]), q = yid(y[i]);
        x1[p] = x[i], y1[q] = y[i];
        ++g[p][q];
    }
    for (int i = 1; i &lt;= n; ++i)
        for (int j = 1; j &lt;= n; ++j)
            g[i][j] += g[i - 1][j] + g[i][j - 1] - g[i - 1][j - 1];

    int l = 1, r = 1e5;
    while (l &lt; r) {
        const int mid = (l + r) &gt;&gt; 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    printf(&quot;%d\n&quot;, l);
    return 0;
}
</code></pre>
<hr />
<h2><a id="%E7%B3%96%E6%9E%9C%E4%BC%A0%E9%80%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>糖果传递</h2>
<p><tc><c>0x0807</c><c>HAOI 2008</c><e>Easy+</e><t>前缀和</t><t>数学</t><t>环上问题</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>0x0503 简化版，这里重新推导一遍，思路可能不同。</p>
<p>先破环成链。假如在 \(a_1\) 与 \(a_n\) 之间断开。</p>
<p>要让 \(a_1\) 达到 \(\overline{a}\)，则需要 \(a_2\) 提供它 \(\overline{a}-a_1\)（不管正负），贡献增加 \(\mid\overline{a}-a_1\mid\)。</p>
<p>此时 \(a_2 \gets a_1 + a_2 - \overline{a}\)。想让 \(a_2\) 达到 \(\overline{a}\)，那么就要 \(a_3\) 给它 \(\overline{a}-(a_1+a_2-\overline{a})=2\cdot\overline{a}-(a_1+a_2)\)，贡献增加 \(\mid2\cdot\overline{a}-(a_1+a_2)\mid\)。</p>
<p>可以发现，总答案为</p>
\[\sum_{i=1}^n\left|i \cdot \overline{a}-\sum_{j=1}^ia_j\right|
\]
<p>假如双倍一下，进一步推广，破环破在 \(a_{k+1}\) 与 \(a_k\) 之间的，总答案为</p>
\[\sum_{i=1}^{n}\left|i \cdot \overline{a}-\sum_{j=k+1}^{i+k}a_j\right|
\]
<p>设前缀和数组为 \(s\)，即 \(s_i = \sum\limits_{j=1}^ia_j\)。</p>
<p>答案变形为</p>
\[\sum_{i=1}^{n}\left|i \cdot \overline{a}-s_{i+k}+s_{k}\right|
\]
<p>前面那个东西实在是不顺眼，所以我们让 \(a_i \gets a_i-\overline{a}\) 再计算前缀和 \(s\)，答案变形为：</p>
\[\sum_{i=1}^{n}\left|s_{k}-s_{i+k}\right|
\]
<p>\(s_k\) 定，考虑到 \(s_n=0\)，而因为珈贝了，我们这里的前缀和 \(s\) 的值域是 \(2n\)，\(s_{n+j}=s_{j}\)，所以式子里的 \(s_{i+k}\) 可以取到 \(s_1 \sim s_n\) 的任何值，所以答案也就是</p>
\[\sum_{i=1}^{n}\left|s_{k}-s_i\right|
\]
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">#define int long long
#define abs(x) ((x) &gt; 0 ? (x) : -(x))

int n;
int a[1000001], s[1000001];

signed main() {
    n = read();
    int sum = 0;
    for (int i = 1; i &lt;= n; ++i)
        a[i] = read(), sum += a[i];
    const int aver = sum / n;
    for (int i = 1; i &lt;= n; ++i)
        s[i] = s[i - 1] + a[i] - aver;
    std::sort(s + 1, s + n + 1);
    int ans = 0;
    for (int i = 1; i &lt;= n; ++i)
        ans += abs(s[(n + 1) &gt;&gt; 1] - s[i]);
    printf(&quot;%lld\n&quot;, ans);
    return 0;
}
</code></pre>
<hr />
<h2><a id="soldiers" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Soldiers</h2>
<p><tc><c>0x0808</c><m>Medium-</m><t>数学</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>纵坐标移到中位数容易证明，接下来考虑横坐标。</p>
<p>首先证明一个事：按 \(x\) 坐标排序后，每个点的顺序与最终结果相同。</p>
<blockquote>
<h4><a id="%E8%AF%81%E6%98%8E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>证明</h4>
<p>若交换一组 \((i,j)\)（\(x_i&gt;x_j\) 且 \(a_i&gt;a_j\)）那么答案将减少 \(\Delta=\mid x_i - a_i \mid + \mid  x_j - a_j \mid - \mid x_i - a_j \mid - \mid x_j - a_i \mid\)</p>
<ul>
<li>
<p>若 \(x_j &gt; a_i\) 或 \(x_i &lt; a_j\)：\(\Delta=0\)</p>
</li>
<li>
<p>若 \(a_j&lt;x_j&lt;a_i&lt;x_i\)：\(\Delta=x_i-a_i+x_j-a_j-x_i+a_j+x_j-a_i=2\cdot x_j-2\cdot a_i&lt;0\)</p>
</li>
<li>
<p>若 \(a_j&lt;x_j&lt;x_i&lt;a_i\)：\(\Delta=a_i-x_i+x_j-a_j-x_i+a_j+x_j-a_i=2\cdot x_j-2\cdot x_i&lt;0\)</p>
</li>
<li>
<p>若 \(x_j&lt;a_j&lt;x_i&lt;a_i\)：\(\Delta=a_i-x_i+a_j-x_j-x_i+a_j+x_j-a_i=2\cdot a_j-2\cdot x_i&lt;0\)</p>
</li>
<li>
<p>若 \(x_j&lt;a_j&lt;a_i&lt;x_i\)：\(\Delta=x_i-a_i+a_j-x_j-x_i+a_j+x_j-a_i=2\cdot a_j-2\cdot a_i&lt;0\)</p>
</li>
</ul>
<p>所以是正确的。</p>
</blockquote>
<p>然后就容易了，因为本来 \(x\) 坐标很小或者很大的，到时候相对于其他点就一定可以少移动一点。所以先把这个东西消掉，因此这个时候就处理好，向最右边的看齐，从右到左第 \(i\) 个点的横坐标加上 \(i\)（也可以当成，向最左边的对齐，从左到右第 \(i\) 个点的横坐标减去 \(i\)）。</p>
<p>更理性一点，设最终移到 \( a+1, a+2, \ldots, a+n\)。那么第 \(i\) 个点的贡献是 \(\mid x_i-(a+i) \mid=\mid (x_i-i)-a \mid\)。所以 \(x_i \gets x_i-i\) 即可。</p>
<p>这个时候，就可以照常取中位数然后算答案了。管他上一步是加还是减，相对坐标差不变，答案不变就完了。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">#define abs(x) ((x) &gt; 0 ? (x) : -(x))

int n, x[10001], y[10001];

int main() {
    n = read();
    for (int i = 1; i &lt;= n; ++i)
        x[i] = read(), y[i] = read();
    std::sort(x + 1, x + n + 1);
    for (int i = 1; i &lt;= n; ++i)
        x[i] -= i;
    std::sort(y + 1, y + n + 1);
    std::sort(x + 1, x + n + 1);
    int ans = 0, x0 = x[(n + 1) &gt;&gt; 1], y0 = y[(n + 1) &gt;&gt; 1];
    for (int i = 1; i &lt;= n; ++i)
        ans += abs(x[i] - x0) + abs(y[i] - y0);
    printf(&quot;%d\n&quot;, ans);
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x0801 ~ 0x0804]]></title>
    <link href="oi.afobject.ml/0x08-1.html"/>
    <updated>2022-04-03T23:51:45+08:00</updated>
    <id>oi.afobject.ml/0x08-1.html</id>
    <content type="html"><![CDATA[
<h2><a id="the-pilots-brothers-refrigerator" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Pilots Brothers' Refrigerator</h2>
<p><tc><c>0x0801</c><e>Easy</e><t>状压</t><t>枚举</t><t>模拟</t></tc></p>
<p>给定一个 \(4\times4\) 的 0-1 矩阵，每次选择一个 \((i,j)\)，使得第 \(i\) 行、第 \(j\) 列上所有的数反转。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>枚举每一个位置是否反转，并模拟。时间复杂度 O(能过)。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">bool m[5][5], c[5][5];

int main() {
    for (int i = 1; i &lt;= 4; ++i)
        for (int j = 1; j &lt;= 4; ++j) {
            char q; std::cin &gt;&gt; q;
            m[i][j] = (q == '-');
        }
    int min = 17, minS = 0;
    for (int s = 0; s &lt; 1 &lt;&lt; 16; ++s) {
        memcpy(c, m, sizeof c);
        int cnt = 0;
        for (int i = 0; i &lt; 16; ++i)
            if (s &amp; (1 &lt;&lt; i)) {
                ++cnt;
                const int row = i / 4 + 1, col = i % 4 + 1;
                for (int j = 1; j &lt;= 4; ++j)
                    c[row][j] ^= 1;
                for (int j = 1; j &lt;= 4; ++j)
                    c[j][col] ^= 1;
                c[row][col] ^= 1;
            }
        bool sum = 1;
        for (int i = 1; i &lt;= 4; ++i)
            for (int j = 1; j &lt;= 4; ++j)
                sum &amp;= c[i][j];
        if (sum &amp;&amp; cnt &lt; min)
            min = cnt, minS = s;
    }
    printf(&quot;%d\n&quot;, min);
    for (int i = 0; i &lt; 16; ++i)
        if (minS &amp; (1 &lt;&lt; i))
            printf(&quot;%d %d\n&quot;, i / 4 + 1, i % 4 + 1);
    return 0;
}
</code></pre>
<hr />
<h2><a id="%E5%8D%A0%E5%8D%9Cdiy" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>占卜 DIY</h2>
<p><tc><c>0x0802</c><e>Easy</e><t>模拟</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>？？？？？？？</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">struct Node {
    int num;
    bool state;
};
std::deque&lt;Node&gt; q[14];

int trans(char c) {
    if (c &gt;= '2' &amp;&amp; c &lt;= '9')
        return c - '0';
    switch (c) {
        case '0': return 10;
        case 'J': return 11;
        case 'Q': return 12;
        case 'K': return 13;
        case 'A': return 1;
    }
    return 0;
}

int buc[14];

int main() {
    for (int i = 1; i &lt;= 13; ++i) {
        char c;
        for (int j = 1; j &lt;= 4; ++j) {
            std::cin &gt;&gt; c;
            // front 上，back 下。
            q[i].push_back({trans(c), false});
        }
    }
    while (q[13].size()) {
        auto current = q[13].front();
        q[13].pop_front();
        while (true) {
            const int t = current.num;
            if (t == 13)
                break;
            q[t].push_front({t, true});
            current = q[t].back();
            q[t].pop_back();
        }
    }
    for (int i = 1; i &lt;= 13; ++i)
        while (q[i].size())
            buc[q[i].front().num] += q[i].front().state,
            q[i].pop_front();
    int ans = 0;
    for (int i = 1; i &lt; 13; ++i)
        if (buc[i] == 4)
            ++ans;
    std::cout &lt;&lt; ans &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<hr />
<h2><a id="fractal" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Fractal</h2>
<p><tc><c>0x0803</c><e>Easy</e><t>模拟</t><t>分形</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>？？？？？？？</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n;
int pow3[1001];
char res[1001][1001];

void fractal(int x, int y, int level) {
    if (level == 1) {
        res[x][y] = 'X';
        return;
    }
    const int t = pow3[level - 2];
    fractal(x, y, level - 1);
    fractal(x + (t &lt;&lt; 1), y, level - 1);
    fractal(x, y + (t &lt;&lt; 1), level - 1);
    fractal(x + (t &lt;&lt; 1), y + (t &lt;&lt; 1), level - 1);
    fractal(x + t, y + t, level - 1);
}

int main() {
    pow3[0] = 1;
    for (int i = 1; i &lt;= 7; ++i)
        pow3[i] = pow3[i - 1] * 3;
    while (scanf(&quot;%d&quot;, &amp;n)) {
        if (n == -1)
            break;
        memset(res, ' ', sizeof res);
        fractal(1, 1, n);
        for (int i = 1; i &lt;= pow3[n - 1]; ++i) {
            for (int j = 1; j &lt;= pow3[n - 1]; ++j)
                printf(&quot;%c&quot;, res[i][j]);
            putchar('\n');
        }
        puts(&quot;-&quot;);
    }
    return 0;
}
</code></pre>
<hr />
<h2><a id="raid" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Raid</h2>
<p><tc><c>0x0804</c></tc></p>
<p>疑似只能用玄学算法卡过，最坏情况 \(n^2\)。。。先跳过了。</p>

]]></content>
  </entry>
  
</feed>
