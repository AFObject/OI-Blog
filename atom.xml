<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[OI Blog]]></title>
  <link href="oi.afobject.ml/atom.xml" rel="self"/>
  <link href="oi.afobject.ml/"/>
  <updated>2022-02-22T20:36:03+08:00</updated>
  <id>oi.afobject.ml/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[0xff 算法竞赛进阶指南]]></title>
    <link href="oi.afobject.ml/overview.html"/>
    <updated>2022-01-07T23:06:53+08:00</updated>
    <id>oi.afobject.ml/overview.html</id>
    <content type="html"><![CDATA[
<hr />
<ul>
<li><c>0x0101</c> 表示题目编号。根据书后索引编号。如果有明确来源则会标注，如果是 CCF 系列比赛则标注赛事和年份，除此之外的题目如果在洛谷上有题号会标注洛谷题号（因为洛谷评测比较方便）。</li>
<li><e>Easy</e> 我能很快做出来的题目。<br />
大约对应红 ～ 黄，典型题目：NOIP 2021 A。</li>
<li><m>Medium</m> 我需要充足的思考才能做出来或者能轻易理解思路的题目。<br />
大约对应思维黄 ～ 下位蓝，典型题目：CSP-S 2021 A。</li>
<li><h>Hard</h> 我看题解都蚌埠住的那种。<br />
大约对应上位蓝到黑。</li>
</ul>
<hr />
<ul>
<li>0x00 基本算法</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x01 位运算]]></title>
    <link href="oi.afobject.ml/0x01.html"/>
    <updated>2022-01-08T11:01:10+08:00</updated>
    <id>oi.afobject.ml/0x01.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E8%A1%A5%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>补码</h2>
<ul>
<li>对于 <code>unsigned int</code>：补码等于原码。</li>
<li>对于 <code>signed int</code>：正数部分补码等于原码，负数部分 \([-2^{31}, -1]\) 相当于 <code>unsigned int</code> \([2^{31}+1, 2^{32}]\)。即原来的<strong>负数的绝对值减去 1 后取反</strong>。<br />
\(-45 \to -(00101101)_2 \to \operatorname{rev}(00101101-1)_2 \to (11010011)_2\)。</li>
</ul>
<hr />
<h2><a id="%E6%88%90%E5%AF%B9%E5%8F%98%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>成对变换</h2>
<p>\((0,1), (2,3), (4,5)\) 这些二元组中的一个数可以通过 <code>xor</code> 运算得到另一个数。应用：双向边邻接表。</p>
<hr />
<h2><a id="lowbit%E8%BF%90%E7%AE%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>lowbit 运算</h2>
<p>lowbit 是<strong>二进制下最低位的 1 及其右边的所有 0 构成的数值</strong>。</p>
\[\operatorname{lowbit}(n)=n\ \&amp;\ (-n)
\]
<p>应用：哈希、树状数组等。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x011 位运算基础]]></title>
    <link href="oi.afobject.ml/0x011.html"/>
    <updated>2022-01-07T22:44:17+08:00</updated>
    <id>oi.afobject.ml/0x011.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E5%BF%AB%E9%80%9F%E5%B9%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>快速幂</h2>
<p><tc><c>0x0101</c><e>Easy-</e><t>快速幂</t></tc></p>
<p>求 \(a^b \bmod p\) 的值。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>\(b\) 可以拆分为这样的二进制：\(b=\sum\limits_{i=0}^{n-1} k_i \times 2^i\)（\(k_i \in \{0, 1\}\)）。</p>
<p>因此 \(a^b = \prod\limits_{i=0}^{n-1} a^{k_i \times 2^{i}}\)。</p>
<p>可以看成递推：\(p_i=a^{2^i}\)，则 \(a^b = \prod\limits_{i=0}^{n-1} p_{i}^{k_i}\)，其中 \(p_{i}= p_{i-1}^2\)。</p>
<p>做的时候直接把数组免了。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int pow(int a, int b, int p) {
	int ans = 1 % p;
	while (b) {
		if (b &amp; 1)
			ans = (ans * a) % p;
		a = (a * a) % p;
		b &gt;&gt;= 1;
	}
	return ans;
}
</code></pre>
<hr />
<h2><a id="raising-modulo-numbers" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Raising Modulo Numbers</h2>
<p><tc><c>0x0102</c><e>Easy-</e><t>快速幂</t></tc></p>
<p>给你 \(N\) 组数，让你求 \(\sum a_i^{b_i} \bmod M\)（\(N, M \le 4.5 \times 10^4\)）。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>暴力。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n, p, a, b, T;
signed main() {
	T = read();
	while (T--) {
		p = read(), n = read();
		int ans = 0;
		while (n--) {
			a = read(), b = read();
			ans = (ans + pow(a, b, p)) % p;
		}
		printf(&quot;%lld\n&quot;, ans);
	}
}
</code></pre>
<hr />
<h2><a id="64%E4%BD%8D%E6%95%B4%E6%95%B0%E4%B9%98%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>64 位整数乘法</h2>
<p><tc><c>0x0103</c><e>Easy-</e><t>快速幂</t></tc></p>
<p>求 \(a \times b \bmod p\) 的值。\(1 \le a,b,p \le 10^{18}\)。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>除非用 <code>__int128</code>，否则必须要将 \(a,b\) 拆分成更小的数再合并求积。这时就可以用到位运算了。</p>
<p>和快速幂几乎完全一样，改几个符号而已。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int mul(int a, int b, int p) {
	int ans = 0;
	while (b) {
		if (b &amp; 1)
			ans = (ans + a) % p;
		a = (a &lt;&lt; 1) % p;
		b &gt;&gt;= 1;
	}
	return ans;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x012 二进制状态压缩]]></title>
    <link href="oi.afobject.ml/0x012.html"/>
    <updated>2022-01-07T22:44:57+08:00</updated>
    <id>oi.afobject.ml/0x012.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E6%9C%80%E7%9F%ADhamilton%E8%B7%AF%E5%BE%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>最短 Hamilton 路径</h2>
<p><tc><c>0x0104</c><c>LG1171</c><m>Medium</m><t>状压</t><t>DP</t></tc></p>
<p>在一张点数小于等于 \(20\) 的带权无向图中找出一条从 \(0\) 到 \(n-1\) <strong>不重不漏地经过每一个点</strong>且<strong>边权和最短</strong>的路径。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>很容易想到用一个二进制数来表示已路过的点的状态（路径状态）。</p>
<p>令 \(f(s,i)\) 为路径状态为 \(s\)，当前点在 \(i\) 的最短路。然后转移即可。</p>
\[f(s,i) = \min_{s' \to s}\{f(s',k) + w(k,i)\}
\]
<p>注意细节：\(s'\) 能通向 \(s\) 需要满足 <strong>\(k\) 包含在 \(s'\) 中</strong>，即 \(k\) 包含在 \(s\) 中且 \(k \neq i\)。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n;
int w[21][21];
int dis[1 &lt;&lt; 21][21];

int main() {
    memset(dis, 0x3f, sizeof dis);
	dis[1][0] = 0;
	for (int s = 2; s &lt; (1 &lt;&lt; n); ++s) {
		for (int i = 0; i &lt; n; ++i) {
			if (!((s &gt;&gt; i) &amp; 1)) continue; // 要求 s 包含 i。
			for (int k = 0; k &lt; n; ++k) { // 选择上一个点。
				if ((s &gt;&gt; k) &amp; 1 &amp;&amp; k != i) // 要求 s 包含 k 且 k 不等于 i。
					dis[s][i] = std::min(dis[s][i], dis[s ^ (1 &lt;&lt; i)][k] + w[k][i]);
			}
		}
	}
	printf(&quot;%d\n&quot;, dis[(1 &lt;&lt; n) - 1][n - 1]);
	return 0;
}
</code></pre>
<hr />
<h2><a id="%E8%B5%B7%E5%BA%8A%E5%9B%B0%E9%9A%BE%E7%BB%BC%E5%90%88%E7%97%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>起床困难综合症</h2>
<p><tc><c>0x0105</c><c>NOI 2014</c><m>Medium</m><t>位运算</t><t>贪心</t></tc></p>
<p>\([0, m]\) 之间选择一个数，使得经过 \(n\) 次位运算后值最大，求最大值。\(m \le 10^9\)，\(n \le 10^5\)。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>很牛的一点：<strong>题目中这些操作在二进制中都不会产生进位。</strong></p>
<p>所以每一位分讨，结果能是 1 就是 1，原数能是 0 就是 0（因为要满足 \(\le m\) 的条件）。</p>
<p>即如果只有填 1 结果才能是 1，且当前还 \(\le m\) 的情况下，就填 1。否则一律填 0。</p>
<p>从高到低分位讨论。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n, m, arg[1000001];
std::string op[1000001];

bool calc(int k, bool val) {
	for (int i = 1; i &lt;= n; ++i) {
		if (op[i] == &quot;AND&quot;)
			val &amp;= (arg[i] &gt;&gt; k) &amp; 1;
		else if (op[i] == &quot;OR&quot;)
			val |= (arg[i] &gt;&gt; k) &amp; 1;
		else
			val ^= (arg[i] &gt;&gt; k) &amp; 1;
	}
	return val;
}

int main() {
	std::cin &gt;&gt; n &gt;&gt; m;
	for (int i = 1; i &lt;= n; ++i)
		std::cin &gt;&gt; op[i] &gt;&gt; arg[i];
		
	int sel = 0, ans = 0;
	for (int i = 30; i &gt;= 0; --i) {
		if (sel + (1 &lt;&lt; i) &lt;= m &amp;&amp;
			calc(i, 0) == 0 &amp;&amp; calc(i, 1) == 1)
			sel += (1 &lt;&lt; i), ans += (1 &lt;&lt; i);
		else if (calc(i, 0))
			ans += (1 &lt;&lt; i);
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x02 递推与递归]]></title>
    <link href="oi.afobject.ml/0x02.html"/>
    <updated>2022-01-15T10:33:03+08:00</updated>
    <id>oi.afobject.ml/0x02.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E5%AE%8F%E8%A7%82%E6%8F%8F%E8%BF%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>宏观描述</h2>
<h3><a id="%E9%80%92%E5%BD%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>递归</h3>
<p>从原大问题出发到小问题，然后将小问题推广到大问题。</p>
<p>缩小、求解、扩展。</p>
<p>Key Points：</p>
<ul>
<li>自身调用自身</li>
<li>回溯时还原现场。</li>
</ul>
<h3><a id="%E9%80%92%E6%8E%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>递推</h3>
<p>正向，由小问题直接推到大问题。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x021 递推与递归的简单应用]]></title>
    <link href="oi.afobject.ml/0x021.html"/>
    <updated>2022-01-15T10:36:36+08:00</updated>
    <id>oi.afobject.ml/0x021.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8C%87%E6%95%B0%E5%9E%8B%E6%9E%9A%E4%B8%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>递归实现指数型枚举</h2>
<p><tc><c>0x0201</c><e>Easy-</e><t>递归</t><t>搜索</t></tc></p>
<pre class="line-numbers"><code class="language-cpp">bool c[21];
void recursive(int t) {
	if (t == n + 1) {
		for (int i = 1; i &lt;= n; ++i)
			if (c[i])
				printf(&quot;%d &quot;, i);
		putchar('\n');
		return;
	}
	c[t] = true;
	recursive(t + 1);
	c[t] = false;
	recursive(t + 1);
}
</code></pre>
<h2><a id="%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E7%BB%84%E5%90%88%E5%9E%8B%E6%9E%9A%E4%B8%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>递归实现组合型枚举</h2>
<p><tc><c>0x0202</c><e>Easy-</e><t>递归</t><t>搜索</t></tc></p>
<pre class="line-numbers"><code class="language-cpp">bool c[21];
void recursive(int t, int sel) {
	if (sel &gt; m || sel + n - t + 1 &lt; m)
		return;
	if (t == n + 1) {
		for (int i = 1; i &lt;= n; ++i)
			if (c[i])
				printf(&quot;%d &quot;, i);
		putchar('\n');
		return;
	}
	c[t] = true;
	recursive(t + 1, sel + 1);
	c[t] = false;
	recursive(t + 1, sel);
}
</code></pre>
<h2><a id="%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%88%97%E5%9E%8B%E6%9E%9A%E4%B8%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>递归实现排列型枚举</h2>
<p><tc><c>0x0203</c><e>Easy-</e><t>递归</t><t>搜索</t></tc></p>
<pre class="line-numbers"><code class="language-cpp">bool c[21];
int sel[21];
void recursive(int t) {
	if (t == n + 1) {
		for (int i = 1; i &lt;= n; ++i)
			printf(&quot;%d &quot;, sel[i]);
		putchar('\n');
		return;
	}
	for (int i = 1; i &lt;= n; ++i) {
		if (!c[i]) {
			sel[t] = i;
			c[i] = true;
			recursive(t +  1);c[i] = false;
		}
	}
}
</code></pre>
<hr />
<h2><a id="%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>费解的开关</h2>
<p><tc><c>0x0204</c><m>Medium</m><t>结论</t><t>贪心</t></tc></p>
<p>\(5\times 5\) 的 01 矩阵中，点击一个位置，它及它上下左右格内的数都会变化，最少多少次点击变成全 0？</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p><strong>考虑特殊情况：</strong> 假如不能动第一行，则对于第一行的任意一个数，如果它是 1，那么只能点击它下面的那个格子。</p>
<p>又有：<strong>点击的顺序不影响最终的结果。</strong> 一个格子被翻转的次数等于它四周的格子被点按次数之和。所以可以以任意顺序考虑点击的位置。</p>
<p>因此只用枚举第一行的 \(2^5\) 种状态即可。后面的方案都是确定的。假如最后不都为 0 那么这种做法就是寄的，继续搜索求解。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>第一次在 OI 里写异常处理。</p>
<pre class="line-numbers"><code class="language-cpp">int T;
int m[7][7];
int t[7][7];

int cnt = 0;
void doOper(int x, int y) {
	t[x][y] ^= 1;
	t[x - 1][y] ^= 1;
	t[x + 1][y] ^= 1;
	t[x][y - 1] ^= 1;
	t[x][y + 1] ^= 1;
	++cnt;
	if (cnt &gt; 6)
		throw -1;
}

int main() {
	scanf(&quot;%d&quot;, &amp;T);
	while (T--) {
		for (int i = 1; i &lt;= 5; ++i)
			for (int j = 1; j &lt;= 5; ++j)
				scanf(&quot;%1d&quot;, &amp;m[i][j]);
		int ans = 0x3f3f3f3f;
		for (int s = 0; s &lt; 32; ++s) {
			cnt = 0;
			try {
				for (int i = 1; i &lt;= 5; ++i)
					for (int j = 1; j &lt;= 5; ++j)
						t[i][j] = m[i][j];
				for (int i = 1, s0 = s; s0; s0 &gt;&gt;= 1, ++i)
					if (s0 &amp; 1)
						doOper(1, i);
				for (int r = 2; r &lt;= 5; ++r) {
					for (int c = 1; c &lt;= 5; ++c)
						if (!t[r - 1][c])
							doOper(r, c);
				}
			} catch (int e) {
				continue;
			}
			int sum = 1;
			for (int i = 1; i &lt;= 5; ++i)
				sum &amp;= t[5][i];
			if (sum)
				ans = std::min(ans, cnt);
		}
		printf(&quot;%d\n&quot;, (ans == 0x3f3f3f3f) ? -1 : ans);
	}
	return 0;
}
</code></pre>
<hr />
<h2><a id="strange-towers-of-hanoi" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Strange Towers of Hanoi</h2>
<p><tc><c>0x0205</c><m>Medium</m><t>递推</t><t>DP</t></tc></p>
<p>求 \(n\) 盘 4 塔的汉诺塔步数。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>考虑 \(n\) 盘 3 塔：</p>
<ul>
<li>\(n-1\) 盘：A \(\to\) B</li>
<li>第 \(n\) 盘：A \(\to\) C</li>
<li>\(n-1\) 盘：B \(\to\) C</li>
</ul>
<p>因此 \(f_3(n)=2 \times f_3(n-1) + 1\)，其中 \(f_3(1)=1\)。可以知道 \(f_3(n)=2^n-1\)。</p>
<p>再考虑 \(n\) 盘 4 塔：</p>
\[f_4(n) \le \min_{1 \le i \lt n} \{2 \times f_4(i) + f_3(n-i)\}
\]
<p>注意此处使用小于等于号。</p>
<p>参照具体数学上证明等于的方法：</p>
<p>我们迟早都必须要移动最下面的那 \(n-i\) 个盘子移动到 D 柱，当我们这么做的时候，上面 \(i\) 个必须已经在某个柱子上。而把下面的这 \(n-i\) 个盘子摆好以后，又要用 \(f_4(i)\) 次移动将上面的盘子放置在它上方（胡言乱语 /tuu）。因此至少需要有 \(\min_{1 \le i \lt n} \{2 \times f_4(i) + f_3(n-i)\}\) 次移动。</p>
\[\therefore f_4(n) = \min_{1 \le i \lt n} \{2 \times f_4(i) + f_3(n-i)\}
\]
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">#define f3(x) ((1 &lt;&lt; (x)) - 1)

int f4[13];

int main() {
    f4[1] = 1;
    for (int x = 2; x &lt;= 12; ++x) {
    	f4[x] = 0x3f3f3f3f;
    	for (int i = 1; i &lt; x; ++i)
    		f4[x] = std::min(f4[x], 2 * f4[i] + f3(x - i));
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x022 分治]]></title>
    <link href="oi.afobject.ml/0x022.html"/>
    <updated>2022-01-15T22:34:54+08:00</updated>
    <id>oi.afobject.ml/0x022.html</id>
    <content type="html"><![CDATA[
<h2><a id="sumdiv" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sumdiv</h2>
<p><tc><c>0x0206</c><c>LG1593</c><m>Medium</m><t>数论</t><t>分治</t><t>快速幂</t></tc></p>
<p>求 \(a^b\) 的因子和 \(\bmod 9901\)。\(a, b \le 5 \times 10^7\)。</p>
<h2><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h2>
<p>假设 \(a = \prod p_i^{c_i}\)，则 \(a^b=\prod p_i^{c_i \times b}\) 因子和为</p>
\[\prod{\sum_{k=0}^{c_i \times b} {p_i}^k}
\]
<p>求个 \(p\) 是 \(\sqrt a\) 级别的，现在要快速求 \(\sum_{k=0}^{c_i \times b} {p_i}^k\)。</p>
<p>考虑使用等比数列求和公式：</p>
\[\begin{aligned}
S&amp;=1+p+p^2+p^3+\cdots+p^k\\
p\cdot S&amp;=p+p^2+p^3+\cdots+p^k+p^{k+1}\\
S&amp;=\frac{p^{k+1}-1}{p-1}
\end{aligned}
\]
<p>但要取模所以不能除啊……</p>
<p>于是，开始分治（\(k \in \mathbb N\)）！</p>
\[\begin{aligned}
\sum_{i=0}^{2k+1}p^i &amp;= \sum_{i=0}^k p^i+ p^{k+1} \cdot \sum_{i=0}^k p^i \\
&amp;=(1+p^{k+1}) \cdot\sum_{i=0}^k p^i\\

\sum_{i=0}^{2k}p^i &amp;= \sum_{i=0}^{k-1} p^i+ p^{k} \cdot \sum_{i=0}^{k-1} p^i+p^{2k} \\
&amp;=(1+p^k) \cdot\sum_{i=0}^{k-1} p^i+p^{2k}
\end{aligned}
\]
<p>拆完了！\(\log\) 时间内可以求到结果。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>随时取模；特判个 \(0\)。</p>
<pre class="line-numbers"><code class="language-cpp">#define MOD 9901

int a, b;
std::map&lt;int, int&gt; m;

int pow(int a, int b, int p = MOD) {
	int ans = 1 % MOD;
	while (b) {
		if (b &amp; 1)
			ans = (ans * a) % MOD;
		a = (a * a) % MOD;
		b &gt;&gt;= 1;
	}
	return ans;
}

int sum(int p, int c) {
	if (c == 0) return 1;
	if (c == 1) return p + 1;
	const int k = c / 2;
	if (c &amp; 1) {
		const int t = (1 + pow(p, k + 1)) % MOD;
		return (t * sum(p, k)) % MOD;
	} else {
		const int t = (1 + pow(p, k)) % MOD;
		return (t * sum(p, k - 1) + pow(p, 2 * k)) % MOD; 
	}
}

int main() {
	a = read(), b = read();
	for (int i = 2; i * i &lt;= a; ) {
		if (a % i == 0)
			++m[i], a /= i;
		else
			++i;
	}
	if (a != 1)
		++m[a];
    if (!a) return puts(&quot;0&quot;), 0;
	int ans = 1;
	for (auto [p, k] : m) {
		ans = (ans * sum(p % MOD, k * b)) % MOD;
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x023 分形]]></title>
    <link href="oi.afobject.ml/0x023.html"/>
    <updated>2022-01-18T08:06:55+08:00</updated>
    <id>oi.afobject.ml/0x023.html</id>
    <content type="html"><![CDATA[
<h2><a id="fractal-streets" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Fractal Streets</h2>
<p><tc><c>0x0207</c><e>Easy+</e><t>递归</t><t>模拟</t><t>数学</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>一个 \(N\) 级城市可以分为 4 个 \(N-1\) 级小城市。以此为依据进行递推。</p>
<p><strong>以城市的中心为原点，建立平面直角坐标系。</strong></p>
<p>首先我们令 \(k = \lfloor \frac {i-1} {4^{n-1}} \rfloor\)（实现的时候所有 \(i\) 自动减一）。\(k=0\) 在第二象限，\(k=1\) 在第一象限，\(k=2\) 在第四象限，\(k=3\) 在第三象限。</p>
<p>以第一、四象限的城市为标准图形。<strong>第二象限的是把标准图形沿 \(y\) 轴翻折然后逆时针旋转 \(90^{\circ}\)</strong>，就能把编号顺序和标准图形对应上，第三象限同理，是<strong>沿 \(y\) 轴翻折然后顺时针旋转 \(90^{\circ}\)</strong>。</p>
<p>设以标准图形求出来的是 \((x,y)\)，\(\Delta = 2^{N-2}\)。</p>
<table>
<thead>
<tr>
<th style="text-align: center">\(k\)</th>
<th style="text-align: center">坐标</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">\(\quad0\quad\)</td>
<td style="text-align: center">\((-y-\Delta,-x+\Delta)\)</td>
</tr>
<tr>
<td style="text-align: center">\(\quad1\quad\)</td>
<td style="text-align: center">\((x+\Delta,y+\Delta)\)</td>
</tr>
<tr>
<td style="text-align: center">\(\quad2\quad\)</td>
<td style="text-align: center">\((x+\Delta,y-\Delta)\)</td>
</tr>
<tr>
<td style="text-align: center">\(\quad3\quad\)</td>
<td style="text-align: center">\((y-\Delta,x-\Delta)\)</td>
</tr>
</tbody>
</table>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>退钱，精度问题卡了巨久，，，</p>
<p>「所有房屋在格子中间」这条有点烦，可以把每个格子长度设为 2，然后房屋在正中间。最后答案乘以 5。</p>
<p>虽然开了 <code>__int128</code> 以后大概不用这样。</p>
<pre class="line-numbers"><code class="language-cpp">#define sq(x) ((x) * (x))
#define int __int128
#define x first
#define y second

int T, n, s, d;

int read() {
    int ans = 0, neg = 1; char ch = getchar();
    while (ch &lt; '0' || ch &gt; '9') { if (ch == '-') neg = -1; ch = getchar(); }
    while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') { ans *= 10; ans += (ch - '0'); ch = getchar(); }
    return ans * neg;
}

std::pair&lt;int, int&gt; solve(int n, int i) {
	if (n == 0) return std::make_pair(0, 0);
	if (n == 1) {
		if (i == 0) return std::make_pair(-1, 1);
		if (i == 1) return std::make_pair(1, 1);
		if (i == 2) return std::make_pair(1, -1);
		if (i == 3) return std::make_pair(-1, -1);
	}
	const int k = i / (1ll &lt;&lt; (2 * n - 2)),
				 r = i % (1ll &lt;&lt; (2 * n - 2)),
				 d = (1ll &lt;&lt; (n - 2)) * 2ll;
	auto a = solve(n - 1, r);
	if (k == 0) return std::make_pair(-a.y - d, -a.x + d);
	if (k == 1) return std::make_pair(a.x + d, a.y + d);
	if (k == 2) return std::make_pair(a.x + d, a.y - d);
	if (k == 3) return std::make_pair(a.y - d, a.x - d);
	return std::make_pair(0, 0);
}

signed main() {
	T = read();
	while (T--) {
		n = read(), s = read(), d = read();
		auto l = solve(n, s - 1), r = solve(n, d - 1);
		printf(&quot;%.0lf\n&quot;, (double)sqrt(sq(r.x - l.x) + sq(r.y - l.y)) * 5);
	}
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x031 前缀和]]></title>
    <link href="oi.afobject.ml/0x031.html"/>
    <updated>2022-01-18T11:54:19+08:00</updated>
    <id>oi.afobject.ml/0x031.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E6%BF%80%E5%85%89%E7%82%B8%E5%BC%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>激光炸弹</h2>
<p><tc><c>0x0301</c><c>HNOI 2003</c><e>Easy</e><t>前缀和</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>使用二维前缀和。</p>
\[\begin{aligned}
&amp;\operatorname{sum}((x_1,y_1),(x_2,y_2)) \\
&amp; =
\operatorname{pre}(x_2,y_2) -
\operatorname{pre}(x_1-1,y_2) -\operatorname{pre}(x_2,y_1-1) +
\operatorname{pre}(x_1-1,y_1-1)
\end{aligned}
\]
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>思维没有任何难度，主要是实现上。题意不清楚，也没解释是什么坐标系。</p>
<ol>
<li>
<blockquote>
<p>若目标位于爆破正方形的边上，该目标不会被摧毁。</p>
</blockquote>
<p>显然对于 \(m\) 没有任何影响。因为目标在整点处，正方形相当于包围着它们的边，只不过加了 \(0.5\) 的 padding。</p>
</li>
<li>
<blockquote>
<p>\(0 \le x_i, y_i \le 5 \times 10^3\)。</p>
</blockquote>
<p>所以区域范围是 \((0,0)\) 到 \((5\times 10^3, 5 \times 10^3)\)。</p>
</li>
</ol>
<p>因此遍历正方形左上角的范围应该是 \((0,0)\) 到 \((5\times10^3-m+1,5\times10^3-m+1)\)。</p>
<p>细节挺多的，除了数组边界问题（其实全 +1 更方便但忘了懒得改了），还有尤其是关于 \(m\) 的那条一开始想对就对了，一开始想错很难发现。所以避免在脑子不清醒时做题！</p>
<pre class="line-numbers"><code class="language-cpp">int n, m;
int pre[5001][5001];

int sum(int x1, int y1, int x2, int y2) {
	return pre[x2][y2] - (x1 ? pre[x1 - 1][y2] : 0) - (y1 ? pre[x2][y1 - 1] : 0) + ((x1 &amp;&amp; y1) ? pre[x1 - 1][y1 - 1] : 0);
}

int main() {
	n = read(), m = read();
	int max = 0;
	while (n--) {
		int x = read(), y = read();
		pre[x][y] += read();
		max = std::max(max, pre[x][y]);
	}
	for (int r = 0; r &lt;= 5000; ++r)
		for (int c = 0; c &lt;= 5000; ++c) {
			if (!r &amp;&amp; !c) continue;
			else if (!r) pre[r][c] += pre[r][c - 1];
			else if (!c) pre[r][c] += pre[r - 1][c];
			else pre[r][c] += pre[r - 1][c] + pre[r][c - 1] - pre[r - 1][c - 1];
		}
	for (int x = 0; x + m - 1 &lt;= 5000; ++x)
		for (int y = 0; y + m - 1 &lt;= 5000; ++y)
			max = std::max(max, sum(x, y, x + m - 1, y + m - 1));
	printf(&quot;%d\n&quot;, max);
	return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x032 差分]]></title>
    <link href="oi.afobject.ml/0x032.html"/>
    <updated>2022-01-19T07:55:42+08:00</updated>
    <id>oi.afobject.ml/0x032.html</id>
    <content type="html"><![CDATA[
<h2><a id="incdec-sequence" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>IncDec Sequence</h2>
<p><tc><c>0x0302</c><e>Easy</e><t>差分</t></tc></p>
<p>给定个长度为 \(n\) 的数列，每次可以选择一个区间同加 \(1\) 或减 \(1\)，要求最终所有数一样，求最小操作次数和满足最小操作次数的方案数。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>比较显然的差分：每次操作是对差分数列 \(c\) 中任两个数一个加 \(1\)，一个减 \(1\)。最终要求差分数组的除第一项、末项均为 \(0\)。</p>
<p>分析一下样例：<code>1 1 2 2 (0)</code></p>
<p>差分数组为：<code>1 0 1 0 -2</code></p>
<p>两种方案为：</p>
<ul>
<li>\(c_1 \gets c_1+1\)，\(c_3 \gets c_3-1\)：<code>2 0 0 0 -2</code></li>
<li>\(c_3 \gets c_3-1,c_5 \gets c_5+1\)：<code>1  0 0 0 -1</code></li>
</ul>
<p>观察到：</p>
<ul>
<li><strong>差分数组的第一个数的种数就是最后数列的种数</strong>；</li>
<li>差分数组的和始终保持为 \(0\)。</li>
</ul>
<h4><a id="%E7%AC%AC%E4%B8%80%E5%B0%8F%E9%97%AE%EF%BC%9A%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第一小问：最小操作次数</h4>
<p>那就是<strong>尽量在 \([2,n]\) 中正、负配对</strong>，配对不过来再考虑用上首项和末项。</p>
<p>令 \(p = \sum_{c=2}^{n} \vert c_i \vert [c_i &lt; 0]\)，\(q = \sum_{c=2}^{n} c_i[c_i &gt;0]\)。</p>
<ol>
<li>能正负配对的对数应该是 \(\min\{p,q\}\)。还不够的，就要拿首、末来凑了。</li>
<li>所以还需要的操作次数是此时的 \(\sum_{c=2}^{n} \vert c_i \vert\)，即 \(\vert p-q \vert\)。</li>
</ol>
<h4><a id="%E7%AC%AC%E4%BA%8C%E5%B0%8F%E9%97%AE%EF%BC%9A%E6%95%B0%E5%88%97%E7%A7%8D%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第二小问：数列种数</h4>
<p>上述第 1 步不会对 \(c_1\) 产生影响，关键是第二步如何消灭中间的数。</p>
<p>其实很容易发现，最终 \(c_1\) 的值域范围是：</p>
<ul>
<li>如果 \([2,n]\) 留下的数全是正数
<ul>
<li>最小：\(c_1-\vert p-q \vert\)。全拿 \(c_1\) 来抵了。</li>
<li>最大：\(c_1\)。不会更多。</li>
</ul>
</li>
<li>如果 \([2,n]\) 留下的全是负数
<ul>
<li>最小：\(c_1\)。</li>
<li>最大：\(c_1+ \vert p-q \vert\)。</li>
</ul>
</li>
</ul>
<p>因此数列种数就是第一小问求得的 \(\vert p-q \vert +1\)。</p>
<p>这波啊，之前为了方便在差分数组末尾加的数也没必要了。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>时间 \(\Theta(n)\)，空间 \(\Theta(1)\)。</p>
<pre class="line-numbers"><code class="language-cpp">#define int long long

int n;
signed main() {
	n = read();
	int p = 0, q = 0, last = 0, c;
	for (int i = 1; i &lt;= n; ++i) {
		c = read() - last, last += c;
		if (i &gt; 1) {
			if (c &gt; 0) p += c;
			else q -= c;
		}
	}
	printf(&quot;%lld\n%lld\n&quot;, std::min(p, q) + abs(p - q), abs(p - q) + 1);
	return 0;
}
</code></pre>
<hr />
<h2><a id="tallest-cow" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Tallest Cow</h2>
<p><tc><c>0x0303</c><c>USACO</c><c>LG2879</c><e>Easy</e><t>差分</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>sb 诈骗题，假设所有牛都最高，然后把每个区间内的牛砍一刀就行了。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>判重。</p>
<pre class="line-numbers"><code class="language-cpp">#define MP std::make_pair

int n, h, r;
int c[100001];

std::set&lt;std::pair&lt;int, int&gt;&gt; s;

signed main() {
	n = read(), h = read(), h = read(), r = read();
	while (r--) {
		int x = read(), y = read();
		if (x &gt; y) std::swap(x, y);
		if (s.find(MP(x, y)) == s.end()) {
			--c[x + 1], ++c[y];
			s.insert(MP(x, y));
		}
	}
	int a = h;
	for (int i = 1; i &lt;= n; ++i) {
		a += c[i];
		printf(&quot;%d\n&quot;, a);
	}
	return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x04 二分]]></title>
    <link href="oi.afobject.ml/0x04.html"/>
    <updated>2022-01-19T17:24:58+08:00</updated>
    <id>oi.afobject.ml/0x04.html</id>
    <content type="html"><![CDATA[
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gymucbb50ej30wc0dkabf.jpg" alt="" /></p>
<h2><a id="%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E4%B8%8A%E7%9A%84%E4%BA%8C%E5%88%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>整数集合上的二分</h2>
<p>现在开始更换成主流二分写法：</p>
<pre class="line-numbers"><code class="language-cpp">int l, r;
while (l &lt; r) {
    int mid = (l + r) &gt;&gt; 1;
    if (check(mid)) r = mid;
    else l = mid + 1;
}

while (l &lt; r) {
    int mid = (l + r + 1) &gt;&gt; 1;
    if (check(mid)) l = mid;
    else r = mid - 1;
}
</code></pre>
<p>两种写法中 \(mid\) 部分不同。</p>
<p>我们一定要选取一个正确的 \(mid\) 值，使得<strong>二分过程中任何一组 \((l, r)\) 都不同</strong>。否则，就会陷入死循环。</p>
<p>例如，在 \([2, 3]\) 进行二分：</p>
<ul>
<li>如果我们把 \(mid\) 选在 \(2\)（<code>(2 + 3) &gt;&gt; 1</code>），并且转移是 \(l \gets mid\) 的话，就会陷入死循环；</li>
<li>如果选在 \(3\)（<code>(2 + 3 + 1) &gt;&gt; 1</code>），且转移是 \(r \gets mid\) 的话，也会陷入死循环。</li>
</ul>
<p>因此：</p>
<ul>
<li>但凡选择了 \(l \gets mid + 1\)，\(r \gets mid\)，就必须选择 <code>(l + r) &gt;&gt; 1</code>；</li>
<li>但凡选择了 \(l \gets mid\)，\(r \gets mid - 1\)，就必须选择 <code>(l + r + 1) &gt;&gt; 1</code>。</li>
</ul>
<p>至于转移方式的选择，就要看 \(mid\) 算在右半边还是算在左半边了。</p>
<hr />
<h2><a id="%E4%BA%8C%E5%88%86%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二分的默认值</h2>
<ul>
<li><code>(l + r) &gt;&gt; 1</code> 型二分不会搜到 \(r\)，可以把默认值放在 \(r\) 处。</li>
<li><code>(l + r + 1) &gt;&gt; 1</code> 型二分不会搜到 \(l\)，可以把默认值放在 \(l\) 处。</li>
</ul>
<hr />
<h2><a id="%E5%AE%9E%E6%95%B0%E5%9F%9F%E4%B8%8A%E7%9A%84%E4%BA%8C%E5%88%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实数域上的二分</h2>
<p>可以采取这种方便的写法：</p>
<pre class="line-numbers"><code class="language-cpp">for (int i = 0; i &lt; 100; ++i) {
    double mid = (l + r) / 2;
    if (check(mid)) r = mid;
    else l = mid;
}
</code></pre>
<hr />
<h2><a id="%E4%B8%89%E5%88%86%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三分法</h2>
<p><tc><c>LG3382</c></tc></p>
<p>在 \([l, r]\) 内任意取两个点 \(mid_l, mid_r\)。</p>
<ul>
<li>若前者小于后者，则要么最高点在它们中间，要么在它们右边。\(l \gets mid_l\)。</li>
<li>反之，则 \(r \gets mid_r\)。</li>
</ul>
<p>注意实现时的数据类型应为 <code>double</code>。</p>
<pre class="line-numbers"><code class="language-cpp">for (int i = 1; i &lt;= 1000000; ++i) {
	double lMid = (r - l) / 3 + l;
	double rMid = r - (r - l) / 3;
	if (f(lMid) &lt; f(rMid)) l = lMid;
	else r = rMid;
}
</code></pre>
<hr />
<h2><a id="best-cow-fences" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Best Cow Fences</h2>
<p><tc><c>0x0401</c><c>USACO</c><e>Easy</e><t>二分答案</t><t>前缀和</t></tc></p>
<p>给定正整数数列 \(A\)（\(N \le 10^5\)），求一个平均数最大的、长度不小于 \(L\) 的连续子段。</p>
<h2><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h2>
<p>平均数最大是 naive 套路了，每个数都减去平均数数列和就是 \(0\)。二分的过程中全部减去二分值 \(x\)，如果有区间和是 \(\ge 0\) 的，就说明存在平均数大于 \(\ge x\) 的区间。</p>
<p>然后来个最大子段和（前缀和求法，其中求 \(\max_{j=1}^{i}\operatorname{pre}(j)\) 改为 \(\max_{j=1}^{i-L}\operatorname{pre}(j)\)）操作操作就行了。</p>
<h2><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h2>
<p>卡精度屑题属实没什么意思 /qd</p>
<pre class="line-numbers"><code class="language-cpp">int n, len;
double a[100001], sum[100001];

bool check(double x) {
	double ans = -1e10, min = 1e10;
	for (int i = 1; i &lt;= n; ++i) {
		sum[i] = sum[i - 1] + a[i] - x;
		if (i &gt;= len)
			min = std::min(min, sum[i - len]),
			ans = std::max(ans, sum[i] - min);
	}
	return ans &gt;= 0;
}

signed main() {
	std::cin &gt;&gt; n &gt;&gt; len;
	for (int i = 1; i &lt;= n; ++i)
		std::cin &gt;&gt; a[i];
	double l = -20000001, r = 20000001;
	while (r - l &gt; 1e-5) {
		double mid = (l + r) / 2;
		if (check(mid)) l = mid;
		else r = mid;
	}
	std::cout &lt;&lt; int(r * 1000) &lt;&lt; std::endl;
	return 0;
}
</code></pre>
<hr />
<h2><a id="innovative-business" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Innovative Business</h2>
<p><tc><c>0x0402</c><e>Easy+</e><t>交互</t><t>二分</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>虽然原图不具有传递性但最后的结果具有传递性。所以可以进行二分。二分插入排序的方式。</p>
<p>诈骗题。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>二分没复习到位，调了巨久（悲</p>
<pre class="line-numbers"><code class="language-cpp">
class Solution {
public:
	std::vector&lt;int&gt; specialSort(int n) {
		std::vector&lt;int&gt; ans = {-1, 1}; // -1 占位符。
		for (int i = 2; i &lt;= n; ++i) {
			int l = 0, r = i - 1; // 搜到谁代表插在谁后面。(l + r + 1) &gt;&gt; 1 型二分不会搜到 l，所以用 l 当默认值。
			while (l &lt; r) {
				const int mid = (l + r + 1) &gt;&gt; 1;
				if (compare(i, ans[mid])) r = mid - 1; // i &lt; mid，i 不可能插在 mid 后面，mid 不可能是答案。
				else l = mid; // i &gt; mid，i 可能插在 mid 后面。
			}
			ans.insert(ans.begin() + l + 1, i);
		}
		ans.erase(ans.begin());
		return ans;
	}
} s;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x051 离散化]]></title>
    <link href="oi.afobject.ml/0x051.html"/>
    <updated>2022-01-23T10:52:57+08:00</updated>
    <id>oi.afobject.ml/0x051.html</id>
    <content type="html"><![CDATA[
<p>即把一堆值域巨大的数映射到更小的有限集合中。</p>
<p>一般有以下几个步骤：</p>
<ul>
<li>排序；</li>
<li>去重；</li>
<li>得到原数在去重数组中的排名（第几小）。</li>
</ul>
<pre class="line-numbers"><code class="language-cpp">for (int i = 1; i &lt;= n; ++i)
    b[i] = a[i];
std::sort(b + 1, b + n + 1);
const int c = std::unique(b + 1, b + n + 1) - b;
for (int i = 1; i &lt;= n; ++i)
    printf(&quot;%d &quot;, (int)(std::lower_bound(b + 1, b + c + 1, a[i]) - b));
</code></pre>
<hr />
<h2><a id="cinema" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Cinema</h2>
<p><tc><c>0x0501</c><c>CF670C</c><e>Easy-</e><t>排序</t><t>离散化</t></tc></p>
<p>有 \(n\) 个人和 \(m\) 场电影，一个人只会一种语言，一场电影会有原声语言和字幕语言。选择一场电影，在最大化能理解原声的人数的情况下最大化能理解字幕的人数。</p>
<p>其中语言用 \(1\) 到 \(10^9\) 的数来表示。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>首先离散化语言，并统计每种语言的人数。</p>
<p>把电影按照第一关键字（理解其原声的人数）和第二关键字（理解其字母的人数）排序。当然直接 \(O(n)\) 做也是可以的。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n, m;
std::vector&lt;int&gt; lang;
int a[200001];
int d0[200001], d1[200001], d2[200001];
int buc[600001];

bool comp(int lhs, int rhs) {
    if (buc[d1[lhs]] == buc[d1[rhs]])
        return buc[d2[lhs]] &gt; buc[d2[rhs]];
    return buc[d1[lhs]] &gt; buc[d1[rhs]];
}

int main() {
    n = read();
    for (int i = 1; i &lt;= n; ++i)
        a[i] = read(), lang.push_back(a[i]);
    m = read();
    for (int i = 1; i &lt;= m; ++i)
        d1[i] = read(), lang.push_back(d1[i]);
    for (int i = 1; i &lt;= m; ++i)    
        d2[i] = read(), lang.push_back(d2[i]);
    std::sort(lang.begin(), lang.end());
    auto p = std::unique(lang.begin(), lang.end());
    for (int i = 1; i &lt;= n; ++i)
        ++buc[std::lower_bound(lang.begin(), p, a[i]) - lang.begin()];
    for (int i = 1; i &lt;= m; ++i)
        d0[i] = i,
        d1[i] = std::lower_bound(lang.begin(), p, d1[i]) - lang.begin(),
        d2[i] = std::lower_bound(lang.begin(), p, d2[i]) - lang.begin();
    std::sort(d0 + 1, d0 + m + 1, comp);
    printf(&quot;%d\n&quot;, d0[1]);
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x052 中位数]]></title>
    <link href="oi.afobject.ml/0x052.html"/>
    <updated>2022-01-23T11:45:04+08:00</updated>
    <id>oi.afobject.ml/0x052.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>货仓选址</h2>
<p><tc><c>0x0502</c><e>Easy-</e><t>数学</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>先排序，然后开始「换根」。</p>
<p>假如从建在 \(i\) 处转移到建在 \(i + 1\) 处，则 \(i\) 左边的商店很倒霉，右边的商店获益。反之同理。</p>
<p>最好使得左右商店均衡。</p>
<p>因此如果是奇数就建在中位数处，否则哪怕左右移动 1 毫米就会有超过一半的商店开始叫了。</p>
<p>如果是偶数，同理，建在中间的两个商店的区间内就行了。</p>
<p>答案是排序后的</p>
\[\sum_{i=1}^n \lvert a_i-a_{\lceil \frac n 2 \rceil} \rvert
\]
<hr />
<h2><a id="%E4%B8%83%E5%A4%95%E7%A5%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>七夕祭</h2>
<p><tc><c>0x0503</c><m>Medium+</m><t>前缀和</t><t>数学</t></tc></p>
<p>\(n \times m\) 的方格中，有 \(t\) 个点为「目标点」。通过一定次数的<strong>相邻</strong>上下、左右格内的交换，使得<strong>每行、每列内的目标点数相同</strong>。但这里比较特殊，一行或一列可以看成一个<strong>环</strong>，首行和末行在同一列上的格子可以交换，首列和末列在同一行上的格子可以交换。</p>
<p>求最少的交换次数。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>拆分问题：</p>
<ul>
<li>通过最少次数的左右交换使每列目标点数相同。</li>
<li>通过最少次数的上下交换使每行目标点数相同。</li>
</ul>
<p>这两个互不干涉。</p>
<blockquote>
<h4><a id="%E7%AE%80%E5%8C%96%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>简化问题</h4>
<p>一条长度为 \(n\) 的数组 \(a\)，要求最终每个数都相等。一次操作可以将相邻两个数一个 \(+1\) 一个 \(-1\)，求最小的操作次数。</p>
<hr />
<ul>
<li>首先要求 \(n \mid \sum a_i\)，否则显然无解。</li>
<li>否则，从第一个数开始考虑：
<ul>
<li>如果多了，给 2；</li>
<li>少了，2 给。</li>
</ul>
</li>
<li>同理继续。如果出现负数也无所谓，反正操作顺序可以任意调换。</li>
</ul>
<p>计算答案：</p>
<ul>
<li>由第一个数发起的操作次数为 \(\lvert a_1 - d \rvert\)，其中 \(d = \dfrac{\sum a_i}{n}\)；</li>
<li>由第二个数发起的操作次数为 \(\lvert a_1 + a_2 - 2 \cdot d \rvert\)；</li>
</ul>
<p><strong>总操作次数为 \(\sum\limits_{i=1}^n \lvert \operatorname{pre_a}(i)-i \cdot d \rvert\)。</strong></p>
<p>如果一开始每个人就减去 \(d\)（设减去后的数组为 \(b\)），则<strong>总操作次数就是 \(\sum_\limits{i=1}^n\lvert \operatorname{pre_b}(i)_ \rvert\)。</strong></p>
</blockquote>
<p>与本题的任意一个子问题的区别就在于本题可以成环。很容易想到经典的破环成链，下面来验证正确性。</p>
<p>我们观察到在简化问题中，<strong>即使允许首项和末项之间的操作，也不会对最优结果产生任何影响</strong>。一个数比 \(d\) 多的部分就雷打不动要移走，移走的时候直接顺着 \(1,2,3, \ldots ,n\) 的顺序就行了，没必要非得直接跳到 \(n\)。所以<strong>破环成链</strong>是正确的。</p>
<p>当破环破在第 \(k\) 个数之后时，则长成这样：</p>
<table>
<thead>
<tr>
<th style="text-align: center">转化后的 \(b\) 数组</th>
<th>\(b_{k+1}\)</th>
<th>\(b_{k+2}\)</th>
<th style="text-align: left">\(b_n\)</th>
<th style="text-align: left">\(b_1\)</th>
<th style="text-align: left">\(b_k\)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">前缀和 \(p\) 数组</td>
<td>\(p_{k+1}-p_k\)</td>
<td>\(p_{k+2}-p_k\)</td>
<td style="text-align: left">\(p_n-p_k\)</td>
<td style="text-align: left">\(p_1+p_n-p_k\)</td>
<td style="text-align: left">\(p_n\)</td>
</tr>
</tbody>
</table>
<p>很容易发现，总操作次数是 \(\sum\limits_{i=1}^n \lvert p_i-p_k \rvert\)。</p>
<p>震惊，就是上一题的货仓选址！将 \(p\) 排序后，\(k\) 应取中位数。</p>
<p>神 仙 题！</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>大数据题都开 <code>long long</code>。</p>
<pre class="line-numbers"><code class="language-cpp">#define int long long

#define abs(x) ((x) &gt; 0 ? (x) : -(x))

int n, m, t;
int r[100001], c[100001];

int p[100001];
int solve(int n, int a[]) {
    int sum = 0;
    for (int i = 1; i &lt;= n; ++i)
        sum += a[i];
    if (sum % n)
        return -1;
    const int d = sum / n;
    for (int i = 1; i &lt;= n; ++i)
        p[i] = p[i - 1] + a[i] - d;
    std::sort(p + 1, p + n + 1);
    int ans = 0;
    for (int i = 1; i &lt;= n; ++i)
        ans += abs(p[i] - p[(n + 1) / 2]);
    return ans;
}

signed main() {
    n = read(), m = read(), t = read();
    while (t--)
        ++r[read()], ++c[read()];
    int x = solve(n, r), y = solve(m, c);
    if (x == -1 &amp;&amp; y == -1) puts(&quot;impossible&quot;);
    else if (x == -1) printf(&quot;column %lld\n&quot;, y);
    else if (y == -1) printf(&quot;row %lld\n&quot;, x);
    else printf(&quot;both %lld\n&quot;, x + y);
    return 0;
}
</code></pre>
<hr />
<h2><a id="running-median" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Running Median</h2>
<p><tc><c>0x0503</c><e>Easy</e><t>对顶堆</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>维护两个堆（<code>std::priority_queue</code>），第一个大根堆维护 \(1 \sim \lfloor \dfrac n 2 \rfloor\)，第二个小根堆维护  \(\lfloor \dfrac n 2 \rfloor + 1 \sim n\)。第二个堆的首项为中位数。</p>
<p>当任意一个堆的个数超了的时候，移到另外一个去。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">void solve() {
    std::priority_queue&lt;int, std::vector&lt;int&gt;, std::less&lt;int&gt;&gt; q1;
    std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt; q2;
    int x = read();
    q2.push(x), printf(&quot;%d &quot;, x);
    for (int i = 2; i &lt;= n; ++i) {
        int x = read();
        if (x &lt; q2.top()) q1.push(x);
        else q2.push(x);
        if (q1.size() &gt; (i &gt;&gt; 1))
            q2.push(q1.top()), q1.pop();
        if (q2.size() &gt; (i + 1) &gt;&gt; 1)
            q1.push(q2.top()), q2.pop();
        if (i &amp; 1)
            printf(&quot;%d &quot;, q2.top());
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x053 快速排序与 kth-element]]></title>
    <link href="oi.afobject.ml/0x053.html"/>
    <updated>2022-01-24T20:02:17+08:00</updated>
    <id>oi.afobject.ml/0x053.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>快速排序</h2>
<p><tc><c>LG1177</c></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>在区间内 rand 一个数，比它小的放左边，大的放右边。</p>
<p>可以使用三路快速排序的优化：分为 <strong>小于基准｜等于基准｜大于基准</strong> 三类。</p>
<h3><a id="%E4%B8%89%E8%B7%AF%E4%BC%98%E5%8C%96%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三路优化实现</h3>
<pre class="line-numbers"><code class="language-cpp">void qSort(int l, int r) {
    if (l &gt;= r) return;

    int s = a[(l + r) / 2];
    int x = l, y = l, z = r;
    // y：左侧指针  z：右侧指针
    // x：存数指针
    while (y &lt; z + 1) {
        if (a[y] &lt; s) std::swap(a[x++], a[y++]); // 左侧指针数合法，入库
        else if (a[y] &gt; s) std::swap(a[z--], a[y]); // 左侧指针数不合法，右边调一个过来，咕着下一轮循环再检查
        else ++y; // 左侧指针数卡线，放过
    }
    // 循环结束：
    // 所有小于 s 的数都被压在了 [l, x);
    // 所有大于 s 的数都被压在了 (z, r]。
    
    qSort(l, x - 1);
    qSort(z + 1, r);
}
</code></pre>
<hr />
<h2><a id="kth-element" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>kth-element</h2>
<p><tc><c>LG1923</c></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>快排排一半。</p>
<h3><a id="%E4%B8%89%E8%B7%AF%E4%BC%98%E5%8C%96%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三路优化实现</h3>
<p>注意一些细节。</p>
<pre class="line-numbers"><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

int n, k, a[5000001];

int read() {
    int ans = 0, neg = 1; char ch = getchar();
    while (ch &lt; '0' || ch &gt; '9') { if (ch == '-') neg = -1; ch = getchar(); }
    while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') { ans *= 10; ans += (ch - '0'); ch = getchar(); }
    return ans * neg;
}

int kthElement(int l, int r, int k) {
    if (l &gt;= r) return a[l];

    int s = a[(l + r) / 2];
    int x = l, y = l, z = r;

    while (y &lt; z + 1) {
        if (a[y] &lt; s) std::swap(a[x++], a[y++]);
        else if (a[y] &gt; s) std::swap(a[z--], a[y]);
        else ++y;
    }
    
    if (l + k - 1 &lt; x) return kthElement(l, x - 1, k);
    else if (l + k - 1 &gt; z) return kthElement(z + 1, r, l + k - 1 - z);
    else return s;
}

int main() {
    n = read(), k = read() + 1;
    for (int i = 1; i &lt;= n; ++i)
        a[i] = read();
    printf(&quot;%d\n&quot;, kthElement(1, n, k));
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x054 逆序对]]></title>
    <link href="oi.afobject.ml/0x054.html"/>
    <updated>2022-02-17T22:48:13+08:00</updated>
    <id>oi.afobject.ml/0x054.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>归并排序求逆序对</h2>
<p><tc><c>LG1908</c></tc></p>
<pre class="line-numbers"><code class="language-cpp">int ans = 0;
void mergeSort(int l, int r) {
    if (l &gt;= r) return;
    const int mid = (l + r) &gt;&gt; 1;
    mergeSort(l, mid);
    mergeSort(mid + 1, r);

    int p = l, pl = l, pr = mid + 1;
    while (pl &lt;= mid &amp;&amp; pr &lt;= r)
        if (a[pl] &lt;= a[pr]) t[p++] = a[pl++];
        else t[p++] = a[pr++], ans += mid - pl + 1;
    while (pl &lt;= mid) t[p++] = a[pl++];
    while (pr &lt;= r) t[p++] = a[pr++];
    for (int i = l; i &lt;= r; ++i) a[i] = t[i];
}
</code></pre>
<hr />
<h2><a id="ultra-quicksort" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Ultra-QuickSort</h2>
<p><tc><c>0x0505</c><e>Easy-</e><t>逆序对</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>大眼观察答案就是逆序对。</p>
<p>一次交换少一个逆序对，啊对对对，显然有构成逆序对的相邻的两个。</p>
<hr />
<h2><a id="%E5%A5%87%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>奇数码问题</h2>
<p><tc><c>0x0506</c><m>Medium</m><t>逆序对</t></tc></p>
<p>给两个 \(n \times n\) 的数字华容道，问一个能否变成另外一个。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>先忽略 0 把这俩写成一串数（8 个）；</p>
<ul>
<li>若左右移动 0 的位置，则这串数不变；</li>
<li>若上下移动 0 的位置，则相当于将一个数后移 \(n-1\) 个位置。</li>
</ul>
<p>上下移动的操作中逆序对的个数的奇偶性不会改变（这个数与 \(n-1\) 个数发生了相对位置改变，每处相对位置改变会增加或减少一个逆序对，而 \(n-1\) 是偶数）。</p>
<p>因此这两串数逆序对个数的奇偶性相同是<strong>必要</strong>的。充分性猜一下大概是可以找出一种移动 0 的方案的。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">signed main() {
    while (std::cin &gt;&gt; n) {
        for (int i = 1, j = 1; i &lt;= n * n; ++i) {
            std::cin &gt;&gt; a[j];
            if (a[j]) ++j;
        }
        int ans1 = mergeSort(1, n * n - 1);
        for (int i = 1, j = 1; i &lt;= n * n; ++i) {
            std::cin &gt;&gt; a[j];
            if (a[j]) ++j;
        }
        int ans2 = mergeSort(1, n * n - 1);
        puts(((ans1 - ans2) % 2) ? &quot;NIE&quot; : &quot;TAK&quot;);
    }
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ABC236]]></title>
    <link href="oi.afobject.ml/abc236.html"/>
    <updated>2022-01-23T20:24:58+08:00</updated>
    <id>oi.afobject.ml/abc236.html</id>
    <content type="html"><![CDATA[
<p>Rated, 4/8, 776 \(\to\) 977</p>
<h2><a id="e" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>E</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LG PMOI R2 Div.2]]></title>
    <link href="oi.afobject.ml/lg-pmoi-r2.html"/>
    <updated>2022-02-15T23:27:04+08:00</updated>
    <id>oi.afobject.ml/lg-pmoi-r2.html</id>
    <content type="html"><![CDATA[
<h2><a id="b" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>B</h2>
<h2><a id="c" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>C</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x06 倍增]]></title>
    <link href="oi.afobject.ml/0x06.html"/>
    <updated>2022-02-19T13:19:02+08:00</updated>
    <id>oi.afobject.ml/0x06.html</id>
    <content type="html"><![CDATA[
<p>倍增：将状态空间划分成若干个 2 的次幂的大小。</p>
<h2><a id="%E9%93%BA%E5%9E%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>铺垫</h2>
<p>给定一个数列 \(A\) 和若干次询问，每次给出一个 \(T\)，求 \(k_{\max}\ s.t.\ \sum_{i=1}^k \le T\)。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<h4><a id="%E6%96%B9%E6%A1%881%EF%BC%9A%E5%9C%A8%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%AD-naive%E4%BA%8C%E5%88%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>方案 1：在前缀和中 naive 二分</h4>
<p>复杂度恒定是 <strong>\(\log n\)</strong> 把大概。</p>
<h4><a id="%E6%96%B9%E6%A1%882%EF%BC%9A%E5%80%8D%E5%A2%9E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>方案 2：倍增</h4>
<p>这个 \(k\) 是要找的这个前缀的长度，<strong>每次尝试往 \(k\) 里面加 \(2\) 的次幂（\(2^p\)）</strong> 就行了。如果加了以后符合要求那么 \(k \gets k + 2^p\)，\(p \gets p+1\)，否则不加且 \(p \gets p - 1\)。\(p &lt; 0\) 的时候结束。</p>
<p>区别就是复杂度是 <strong>\(\log \text{答案}\)</strong> 差不多。这玩意相对于 \(\log\) 感觉有一定常数（差不多 3）。我也不清楚为什么要这么做。就是这样。</p>
<p>感觉有一种平凡优化这里不写了。</p>
<hr />
<h2><a id="genius-acm" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Genius ACM</h2>
<p><tc><c>0x0601</c><h>Hard</h><t>数学</t><t>排序</t><t>倍增</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>首先 \(\sum\limits_{i=1}^{m}(a_i - b_i)^2 = \sum\limits_{i=1}^{m} a_i^2 + \sum\limits_{i=1}^{m} b_i^2 -\sum\limits_{i=1}^{m} a_i b_i\)，所以要使两两的乘积最小。</p>
<blockquote>
<h4><a id="%E6%8E%92%E5%BA%8F%E4%B8%8D%E7%AD%89%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>排序不等式</h4>
<ol>
<li>给定 \(a,b\) 两个数列，证明：当 \(a_i,b_i\) 均不降时，\(\sum a_ib_i\) 最大。</li>
</ol>
<p>简略证明：</p>
<ul>
<li>假设 \(x_1\le x_2,x_3 \le x_4\)，由于 \((x_1-x_2)(x_3-x_4) \ge 0\)，则 \(x_1x_4+x_2x_3 \ge x_1x_3+x_2x_4\)（1）。</li>
<li>假定 \(a\) 不降，且 \(b\) 乱序（非单调不降），设存在 \(b_i, b_j\) 乱序，且它们分别对应 \(a_i, a_j\)（\(b_i&gt;b_j\)，\(a_i &lt; a_j\)）由（1），\(b_i a_j + b_ja_i&gt;b_ia_i + b_ja_j\)，将 \(b_i, b_j\) 交换结果更优。不断交换直到 \(b\) 不降，结果最优。</li>
<li>假定 \(b\) 不降，且 \(a\) 乱序（非单调不降），同理。</li>
</ul>
<p>所以要求 \(a,b\) 均不降。</p>
<hr />
<ol start="2">
<li>在（1）的条件下，当 \(a,b\) 中的一个倒序时，证明：此时 \(\sum a_ib_i\) 最大。</li>
</ol>
<p>简略证明：</p>
<ul>
<li>假定 \(a\) 不降，且 \(b\) 乱序（非单调不升），设存在 \(b_i, b_j\) 非逆序，且它们分别对应 \(a_i, a_j\)（\(b_i&lt;b_j\)，\(a_i &lt; a_j\)）由（1），\(b_i a_j + b_ja_i &lt; b_ia_i + b_ja_j\)，将 \(b_i, b_j\) 交换结果更优。不断交换直到 \(b\) 不升，结果最优。</li>
<li>假定 \(b\) 不降，且 \(a\) 乱序（非单调不升），同理。</li>
<li>得证。</li>
</ul>
</blockquote>
<p>由<strong>排序不等式</strong>，知应当最大对最大，第二大对第二大……最小对最小，此时的 \(\sum (a_i-b_i)^2\) 就是「校验值」。</p>
<p>但这并不是重点。</p>
<p>问题转化为固定一个 \(L\)，求最小的 \(R &gt; L\) 使得 \(f([L, R]) \le T\)。要求「校验值」，必须排序，至少用时 \(O(n \log n)\)。然后 \(n \le 5 \times 10^5\)，好好好，如果每段都很少那么二分屁用没有（\(n\) 级别段，每一段找 \(R\) 二分 \(\log n\) 次总排序 \(n \log n\) 级，感觉得卡成 \(n^2 \log n\)，寄了）。</p>
<p>😅 倍增，固定一个左端点往右扩展，复杂度 \(\sum len \log len\)（块数次倍增，每次倍增对一段排序，排序的总时间 \(n \log n\)，归并以及计算「校验值」的总时间差不多 \(O(n)\) 带点常数）左右吧，总复杂度大约 \(n \log n\) 可以接受（吧），自带巨大常数但是时限 10s。</p>
<blockquote>
<p>776 告诉我 \(\sum len \log len \le n \log n\)。</p>
</blockquote>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<ol>
<li>固定一个 \(l\)</li>
<li>倍增求 \(r\)
<ol>
<li>对未排序的部分进行归并排序</li>
<li>求出「校验值」</li>
<li>根据「校验值」大小判断当前的 \(r\) 是否满足条件</li>
<li>回到 1，直到倍增结束（\(p=0\)）</li>
</ol>
</li>
<li>回到 1，直到得到结果（\(r=n\)）</li>
</ol>
<p>谢邀，人在太平间，写吐了</p>
<pre class="line-numbers"><code class="language-cpp">#define int long long

int T, n, m, k;
// a 原数组不动
// t 是排好序的
// q 是辅助
// copy 是缓存
int a[5000001], t[5000001], q[5000001], copy[5000001];

void mergeSort(int l0, int l, int r) {
    r = std::min(r, n);
    for (int i = l; i &lt;= r; ++i)
        t[i] = a[i];
    
    std::sort(t + l, t + r + 1);

    int lp = l0, tp = l0, rp = l;
    while (lp &lt; l &amp;&amp; rp &lt;= r)
        if (t[lp] &lt; t[rp]) q[tp++] = t[lp++];
        else q[tp++] = t[rp++];
    while (lp &lt; l) q[tp++] = t[lp++];
    while (rp &lt;= r) q[tp++] = t[rp++];

    for (int i = l0; i &lt;= r; ++i)
        t[i] = q[i];
}

int captcha(int l, int r) {
    r = std::min(r, n);
    int ans = 0;
    for (int i = 0; i &lt; m &amp;&amp; l &lt; r; ++i, --r, ++l)
        ans += (t[r] - t[l]) * (t[r] - t[l]);
    return ans;
}

signed main() {
    T = read();
    while (T--) {
        n = read(), m = read(), k = read();
        for (int i = 1; i &lt;= n; ++i)
            a[i] = read();
        int l0 = 1, ans = 0; // 1
        while (l0 &lt;= n) {
            int l = l0, p = 1; bool r = false;
            while (p) {
                for (int i = l0; i &lt; l + p; ++i)
                    copy[i] = t[i]; // 保存当前的快照，以在 c &gt; k 时得以返回上一状态
                mergeSort(l0, l, l + p - 1); // 2.1
                const int c = captcha(l0, l + p - 1); // 2.2
                if (c &lt;= k) { // 2.3
                    l += p;
                    if (l &gt; n) break; // 2.4
                    if (!r)
                        p &lt;&lt;= 1;
                } else {
                    p &gt;&gt;= 1;
                    r = true;
                    for (int i = l0; i &lt; l + p; ++i)
                        t[i] = copy[i];
                }
            }
            ++ans;
            l0 = l;
        }
        printf(&quot;%lld\n&quot;, ans); // 3
    }
}
</code></pre>
<hr />
<h2><a id="st%E8%A1%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ST 表</h2>
<p><tc><c>LG3865</c></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>\(f(l,k)\) 为 \([l, l + 2^k)\) 的和。</p>
<ul>
<li>\(\forall i, f(i,0) = a_i\)。</li>
<li>\(f(l,k) = f(l,k-1)+f(l+2^{k-1},k-1)\)</li>
</ul>
<p>求和：令 \(k=\log_2(r-l+1)\)。</p>
<p>\(f(l,r) = f(l,k)+f(r-2^k+1,k)\)（这两个区间能覆盖 \([l, r]\)）。</p>
<p>静态最大值 / 最小值同理。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现（最大值）</h3>
<pre class="line-numbers"><code class="language-cpp">int n, q;
int f[5000001][31];

int query(int l, int r) {
    const int k = log2(r - l + 1);
    return std::max(f[l][k], f[r - (1 &lt;&lt; k) + 1][k]);
}

void cal() {
    for (int i = 1; i &lt;= n; ++i)
        f[i][0] = read();
    for (int k = 1; k &lt;= 30; ++k)
        for (int i = 1; i + (1 &lt;&lt; (k - 1)) &lt;= n; ++i)
            f[i][k] = std::max(f[i][k - 1], f[i + (1 &lt;&lt; (k - 1))][k - 1]);
}
</code></pre>

]]></content>
  </entry>
  
</feed>
