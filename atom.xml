<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[OI Blog]]></title>
  <link href="oi.afobject.ml/atom.xml" rel="self"/>
  <link href="oi.afobject.ml/"/>
  <updated>2022-01-19T17:21:56+08:00</updated>
  <id>oi.afobject.ml/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[0xff 算法竞赛进阶指南]]></title>
    <link href="oi.afobject.ml/overview.html"/>
    <updated>2022-01-07T23:06:53+08:00</updated>
    <id>oi.afobject.ml/overview.html</id>
    <content type="html"><![CDATA[
<hr />
<ul>
<li><c>0x0101</c> 表示题目编号。根据书后索引编号。如果有明确来源则会标注，如果是 CCF 系列比赛则标注赛事和年份，除此之外的题目如果在洛谷上有题号会标注洛谷题号（因为洛谷评测比较方便）。</li>
<li><e>Easy</e> 我能很快做出来的题目。<br />
大约对应红 ～ 黄，典型题目：NOIP 2021 A。</li>
<li><m>Medium</m> 我需要充足的思考才能做出来或者能轻易理解思路的题目。<br />
大约对应思维黄 ～ 下位蓝，典型题目：CSP-S 2021 A。</li>
<li><h>Hard</h> 我看题解都蚌埠住的那种。<br />
大约对应上位蓝到黑。</li>
</ul>
<hr />
<ul>
<li>0x00 基本算法</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x00 基本算法]]></title>
    <link href="oi.afobject.ml/0x00.html"/>
    <updated>2022-01-07T23:05:09+08:00</updated>
    <id>oi.afobject.ml/0x00.html</id>
    <content type="html"><![CDATA[
<ul>
<li>0x01 位运算</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x01 位运算]]></title>
    <link href="oi.afobject.ml/0x01.html"/>
    <updated>2022-01-08T11:01:10+08:00</updated>
    <id>oi.afobject.ml/0x01.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E8%A1%A5%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>补码</h2>
<ul>
<li>对于 <code>unsigned int</code>：补码等于原码。</li>
<li>对于 <code>signed int</code>：正数部分补码等于原码，负数部分 \([-2^{31}, -1]\) 相当于 <code>unsigned int</code> \([2^{31}+1, 2^{32}]\)。即原来的<strong>负数的绝对值减去 1 后取反</strong>。<br />
\(-45 \to -(00101101)_2 \to \operatorname{rev}(00101101-1)_2 \to (11010011)_2\)。</li>
</ul>
<hr />
<h2><a id="%E6%88%90%E5%AF%B9%E5%8F%98%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>成对变换</h2>
<p>\((0,1), (2,3), (4,5)\) 这些二元组中的一个数可以通过 <code>xor</code> 运算得到另一个数。应用：双向边邻接表。</p>
<hr />
<h2><a id="lowbit%E8%BF%90%E7%AE%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>lowbit 运算</h2>
<p>lowbit 是<strong>二进制下最低位的 1 及其右边的所有 0 构成的数值</strong>。</p>
\[\operatorname{lowbit}(n)=n\ \&amp;\ (-n)
\]
<p>应用：哈希、树状数组等。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x011 位运算基础]]></title>
    <link href="oi.afobject.ml/0x011.html"/>
    <updated>2022-01-07T22:44:17+08:00</updated>
    <id>oi.afobject.ml/0x011.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E5%BF%AB%E9%80%9F%E5%B9%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>快速幂</h2>
<p><tc><c>0x0101</c><e>Easy-</e><t>快速幂</t></tc></p>
<p>求 \(a^b \bmod p\) 的值。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>\(b\) 可以拆分为这样的二进制：\(b=\sum\limits_{i=0}^{n-1} k_i \times 2^i\)（\(k_i \in \{0, 1\}\)）。</p>
<p>因此 \(a^b = \prod\limits_{i=0}^{n-1} a^{k_i \times 2^{i}}\)。</p>
<p>可以看成递推：\(p_i=a^{2^i}\)，则 \(a^b = \prod\limits_{i=0}^{n-1} p_{i}^{k_i}\)，其中 \(p_{i}= p_{i-1}^2\)。</p>
<p>做的时候直接把数组免了。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int pow(int a, int b, int p) {
	int ans = 1 % p;
	while (b) {
		if (b &amp; 1)
			ans = (ans * a) % p;
		a = (a * a) % p;
		b &gt;&gt;= 1;
	}
	return ans;
}
</code></pre>
<hr />
<h2><a id="raising-modulo-numbers" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Raising Modulo Numbers</h2>
<p><tc><c>0x0102</c><e>Easy-</e><t>快速幂</t></tc></p>
<p>给你 \(N\) 组数，让你求 \(\sum a_i^{b_i} \bmod M\)（\(N, M \le 4.5 \times 10^4\)）。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>暴力。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n, p, a, b, T;
signed main() {
	T = read();
	while (T--) {
		p = read(), n = read();
		int ans = 0;
		while (n--) {
			a = read(), b = read();
			ans = (ans + pow(a, b, p)) % p;
		}
		printf(&quot;%lld\n&quot;, ans);
	}
}
</code></pre>
<hr />
<h2><a id="64%E4%BD%8D%E6%95%B4%E6%95%B0%E4%B9%98%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>64 位整数乘法</h2>
<p><tc><c>0x0103</c><e>Easy-</e><t>快速幂</t></tc></p>
<p>求 \(a \times b \bmod p\) 的值。\(1 \le a,b,p \le 10^{18}\)。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>除非用 <code>__int128</code>，否则必须要将 \(a,b\) 拆分成更小的数再合并求积。这时就可以用到位运算了。</p>
<p>和快速幂几乎完全一样，改几个符号而已。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int mul(int a, int b, int p) {
	int ans = 0;
	while (b) {
		if (b &amp; 1)
			ans = (ans + a) % p;
		a = (a &lt;&lt; 1) % p;
		b &gt;&gt;= 1;
	}
	return ans;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x012 二进制状态压缩]]></title>
    <link href="oi.afobject.ml/0x012.html"/>
    <updated>2022-01-07T22:44:57+08:00</updated>
    <id>oi.afobject.ml/0x012.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E6%9C%80%E7%9F%ADhamilton%E8%B7%AF%E5%BE%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>最短 Hamilton 路径</h2>
<p><tc><c>0x0104</c><c>LG1171</c><m>Medium</m><t>状压</t><t>DP</t></tc></p>
<p>在一张点数小于等于 \(20\) 的带权无向图中找出一条从 \(0\) 到 \(n-1\) <strong>不重不漏地经过每一个点</strong>且<strong>边权和最短</strong>的路径。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>很容易想到用一个二进制数来表示已路过的点的状态（路径状态）。</p>
<p>令 \(f(s,i)\) 为路径状态为 \(s\)，当前点在 \(i\) 的最短路。然后转移即可。</p>
\[f(s,i) = \min_{s' \to s}\{f(s',k) + w(k,i)\}
\]
<p>注意细节：\(s'\) 能通向 \(s\) 需要满足 <strong>\(k\) 包含在 \(s'\) 中</strong>，即 \(k\) 包含在 \(s\) 中且 \(k \neq i\)。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n;
int w[21][21];
int dis[1 &lt;&lt; 21][21];

int main() {
    memset(dis, 0x3f, sizeof dis);
	dis[1][0] = 0;
	for (int s = 2; s &lt; (1 &lt;&lt; n); ++s) {
		for (int i = 0; i &lt; n; ++i) {
			if (!((s &gt;&gt; i) &amp; 1)) continue; // 要求 s 包含 i。
			for (int k = 0; k &lt; n; ++k) { // 选择上一个点。
				if ((s &gt;&gt; k) &amp; 1 &amp;&amp; k != i) // 要求 s 包含 k 且 k 不等于 i。
					dis[s][i] = std::min(dis[s][i], dis[s ^ (1 &lt;&lt; i)][k] + w[k][i]);
			}
		}
	}
	printf(&quot;%d\n&quot;, dis[(1 &lt;&lt; n) - 1][n - 1]);
	return 0;
}
</code></pre>
<hr />
<h2><a id="%E8%B5%B7%E5%BA%8A%E5%9B%B0%E9%9A%BE%E7%BB%BC%E5%90%88%E7%97%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>起床困难综合症</h2>
<p><tc><c>0x0105</c><c>NOI 2014</c><m>Medium</m><t>位运算</t><t>贪心</t></tc></p>
<p>\([0, m]\) 之间选择一个数，使得经过 \(n\) 次位运算后值最大，求最大值。\(m \le 10^9\)，\(n \le 10^5\)。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>很牛的一点：<strong>题目中这些操作在二进制中都不会产生进位。</strong></p>
<p>所以每一位分讨，结果能是 1 就是 1，原数能是 0 就是 0（因为要满足 \(\le m\) 的条件）。</p>
<p>即如果只有填 1 结果才能是 1，且当前还 \(\le m\) 的情况下，就填 1。否则一律填 0。</p>
<p>从高到低分位讨论。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n, m, arg[1000001];
std::string op[1000001];

bool calc(int k, bool val) {
	for (int i = 1; i &lt;= n; ++i) {
		if (op[i] == &quot;AND&quot;)
			val &amp;= (arg[i] &gt;&gt; k) &amp; 1;
		else if (op[i] == &quot;OR&quot;)
			val |= (arg[i] &gt;&gt; k) &amp; 1;
		else
			val ^= (arg[i] &gt;&gt; k) &amp; 1;
	}
	return val;
}

int main() {
	std::cin &gt;&gt; n &gt;&gt; m;
	for (int i = 1; i &lt;= n; ++i)
		std::cin &gt;&gt; op[i] &gt;&gt; arg[i];
		
	int sel = 0, ans = 0;
	for (int i = 30; i &gt;= 0; --i) {
		if (sel + (1 &lt;&lt; i) &lt;= m &amp;&amp;
			calc(i, 0) == 0 &amp;&amp; calc(i, 1) == 1)
			sel += (1 &lt;&lt; i), ans += (1 &lt;&lt; i);
		else if (calc(i, 0))
			ans += (1 &lt;&lt; i);
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x02 递推与递归]]></title>
    <link href="oi.afobject.ml/16422139834989.html"/>
    <updated>2022-01-15T10:33:03+08:00</updated>
    <id>oi.afobject.ml/16422139834989.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E5%AE%8F%E8%A7%82%E6%8F%8F%E8%BF%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>宏观描述</h2>
<h3><a id="%E9%80%92%E5%BD%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>递归</h3>
<p>从原大问题出发到小问题，然后将小问题推广到大问题。</p>
<p>缩小、求解、扩展。</p>
<p>Key Points：</p>
<ul>
<li>自身调用自身</li>
<li>回溯时还原现场。</li>
</ul>
<h3><a id="%E9%80%92%E6%8E%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>递推</h3>
<p>正向，由小问题直接推到大问题。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x021 递推与递归的简单应用]]></title>
    <link href="oi.afobject.ml/16422141961714.html"/>
    <updated>2022-01-15T10:36:36+08:00</updated>
    <id>oi.afobject.ml/16422141961714.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8C%87%E6%95%B0%E5%9E%8B%E6%9E%9A%E4%B8%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>递归实现指数型枚举</h2>
<p><tc><c>0x0201</c><e>Easy-</e><t>递归</t><t>搜索</t></tc></p>
<pre class="line-numbers"><code class="language-cpp">bool c[21];
void recursive(int t) {
	if (t == n + 1) {
		for (int i = 1; i &lt;= n; ++i)
			if (c[i])
				printf(&quot;%d &quot;, i);
		putchar('\n');
		return;
	}
	c[t] = true;
	recursive(t + 1);
	c[t] = false;
	recursive(t + 1);
}
</code></pre>
<h2><a id="%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E7%BB%84%E5%90%88%E5%9E%8B%E6%9E%9A%E4%B8%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>递归实现组合型枚举</h2>
<p><tc><c>0x0202</c><e>Easy-</e><t>递归</t><t>搜索</t></tc></p>
<pre class="line-numbers"><code class="language-cpp">bool c[21];
void recursive(int t, int sel) {
	if (sel &gt; m || sel + n - t + 1 &lt; m)
		return;
	if (t == n + 1) {
		for (int i = 1; i &lt;= n; ++i)
			if (c[i])
				printf(&quot;%d &quot;, i);
		putchar('\n');
		return;
	}
	c[t] = true;
	recursive(t + 1, sel + 1);
	c[t] = false;
	recursive(t + 1, sel);
}
</code></pre>
<h2><a id="%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%88%97%E5%9E%8B%E6%9E%9A%E4%B8%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>递归实现排列型枚举</h2>
<p><tc><c>0x0203</c><e>Easy-</e><t>递归</t><t>搜索</t></tc></p>
<pre class="line-numbers"><code class="language-cpp">bool c[21];
int sel[21];
void recursive(int t) {
	if (t == n + 1) {
		for (int i = 1; i &lt;= n; ++i)
			printf(&quot;%d &quot;, sel[i]);
		putchar('\n');
		return;
	}
	for (int i = 1; i &lt;= n; ++i) {
		if (!c[i]) {
			sel[t] = i;
			c[i] = true;
			recursive(t +  1);c[i] = false;
		}
	}
}
</code></pre>
<hr />
<h2><a id="%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>费解的开关</h2>
<p><tc><c>0x0204</c><m>Medium</m><t>结论</t><t>贪心</t></tc></p>
<p>\(5\times 5\) 的 01 矩阵中，点击一个位置，它及它上下左右格内的数都会变化，最少多少次点击变成全 0？</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p><strong>考虑特殊情况：</strong> 假如不能动第一行，则对于第一行的任意一个数，如果它是 1，那么只能点击它下面的那个格子。</p>
<p>又有：<strong>点击的顺序不影响最终的结果。</strong> 一个格子被翻转的次数等于它四周的格子被点按次数之和。所以可以以任意顺序考虑点击的位置。</p>
<p>因此只用枚举第一行的 \(2^5\) 种状态即可。后面的方案都是确定的。假如最后不都为 0 那么这种做法就是寄的，继续搜索求解。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>第一次在 OI 里写异常处理。</p>
<pre class="line-numbers"><code class="language-cpp">int T;
int m[7][7];
int t[7][7];

int cnt = 0;
void doOper(int x, int y) {
	t[x][y] ^= 1;
	t[x - 1][y] ^= 1;
	t[x + 1][y] ^= 1;
	t[x][y - 1] ^= 1;
	t[x][y + 1] ^= 1;
	++cnt;
	if (cnt &gt; 6)
		throw -1;
}

int main() {
	scanf(&quot;%d&quot;, &amp;T);
	while (T--) {
		for (int i = 1; i &lt;= 5; ++i)
			for (int j = 1; j &lt;= 5; ++j)
				scanf(&quot;%1d&quot;, &amp;m[i][j]);
		int ans = 0x3f3f3f3f;
		for (int s = 0; s &lt; 32; ++s) {
			cnt = 0;
			try {
				for (int i = 1; i &lt;= 5; ++i)
					for (int j = 1; j &lt;= 5; ++j)
						t[i][j] = m[i][j];
				for (int i = 1, s0 = s; s0; s0 &gt;&gt;= 1, ++i)
					if (s0 &amp; 1)
						doOper(1, i);
				for (int r = 2; r &lt;= 5; ++r) {
					for (int c = 1; c &lt;= 5; ++c)
						if (!t[r - 1][c])
							doOper(r, c);
				}
			} catch (int e) {
				continue;
			}
			int sum = 1;
			for (int i = 1; i &lt;= 5; ++i)
				sum &amp;= t[5][i];
			if (sum)
				ans = std::min(ans, cnt);
		}
		printf(&quot;%d\n&quot;, (ans == 0x3f3f3f3f) ? -1 : ans);
	}
	return 0;
}
</code></pre>
<hr />
<h2><a id="strange-towers-of-hanoi" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Strange Towers of Hanoi</h2>
<p><tc><c>0x0205</c><m>Medium</m><t>递推</t><t>DP</t></tc></p>
<p>求 \(n\) 盘 4 塔的汉诺塔步数。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>考虑 \(n\) 盘 3 塔：</p>
<ul>
<li>\(n-1\) 盘：A \(\to\) B</li>
<li>第 \(n\) 盘：A \(\to\) C</li>
<li>\(n-1\) 盘：B \(\to\) C</li>
</ul>
<p>因此 \(f_3(n)=2 \times f_3(n-1) + 1\)，其中 \(f_3(1)=1\)。可以知道 \(f_3(n)=2^n-1\)。</p>
<p>再考虑 \(n\) 盘 4 塔：</p>
\[f_4(n) \le \min_{1 \le i \lt n} \{2 \times f_4(i) + f_3(n-i)\}
\]
<p>注意此处使用小于等于号。</p>
<p>参照具体数学上证明等于的方法：</p>
<p>我们迟早都必须要移动最下面的那 \(n-i\) 个盘子移动到 D 柱，当我们这么做的时候，上面 \(i\) 个必须已经在某个柱子上。而把下面的这 \(n-i\) 个盘子摆好以后，又要用 \(f_4(i)\) 次移动将上面的盘子放置在它上方（胡言乱语 /tuu）。因此至少需要有 \(\min_{1 \le i \lt n} \{2 \times f_4(i) + f_3(n-i)\}\) 次移动。</p>
\[\therefore f_4(n) = \min_{1 \le i \lt n} \{2 \times f_4(i) + f_3(n-i)\}
\]
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">#define f3(x) ((1 &lt;&lt; (x)) - 1)

int f4[13];

int main() {
    f4[1] = 1;
    for (int x = 2; x &lt;= 12; ++x) {
    	f4[x] = 0x3f3f3f3f;
    	for (int i = 1; i &lt; x; ++i)
    		f4[x] = std::min(f4[x], 2 * f4[i] + f3(x - i));
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x022 分治]]></title>
    <link href="oi.afobject.ml/16422572946324.html"/>
    <updated>2022-01-15T22:34:54+08:00</updated>
    <id>oi.afobject.ml/16422572946324.html</id>
    <content type="html"><![CDATA[
<h2><a id="sumdiv" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sumdiv</h2>
<p><tc><c>0x0206</c><c>LG1593</c><m>Medium</m><t>数论</t><t>分治</t><t>快速幂</t></tc></p>
<p>求 \(a^b\) 的因子和 \(\bmod 9901\)。\(a, b \le 5 \times 10^7\)。</p>
<h2><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h2>
<p>假设 \(a = \prod p_i^{c_i}\)，则 \(a^b=\prod p_i^{c_i \times b}\) 因子和为</p>
\[\prod{\sum_{k=0}^{c_i \times b} {p_i}^k}
\]
<p>求个 \(p\) 是 \(\sqrt a\) 级别的，现在要快速求 \(\sum_{k=0}^{c_i \times b} {p_i}^k\)。</p>
<p>考虑使用等比数列求和公式：</p>
\[\begin{aligned}
S&amp;=1+p+p^2+p^3+\cdots+p^k\\
p\cdot S&amp;=p+p^2+p^3+\cdots+p^k+p^{k+1}\\
S&amp;=\frac{p^{k+1}-1}{p-1}
\end{aligned}
\]
<p>但要取模所以不能除啊……</p>
<p>于是，开始分治（\(k \in \mathbb N\)）！</p>
\[\begin{aligned}
\sum_{i=0}^{2k+1}p^i &amp;= \sum_{i=0}^k p^i+ p^{k+1} \cdot \sum_{i=0}^k p^i \\
&amp;=(1+p^{k+1}) \cdot\sum_{i=0}^k p^i\\

\sum_{i=0}^{2k}p^i &amp;= \sum_{i=0}^{k-1} p^i+ p^{k} \cdot \sum_{i=0}^{k-1} p^i+p^{2k} \\
&amp;=(1+p^k) \cdot\sum_{i=0}^{k-1} p^i+p^{2k}
\end{aligned}
\]
<p>拆完了！\(\log\) 时间内可以求到结果。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>随时取模；特判个 \(0\)。</p>
<pre class="line-numbers"><code class="language-cpp">#define MOD 9901

int a, b;
std::map&lt;int, int&gt; m;

int pow(int a, int b, int p = MOD) {
	int ans = 1 % MOD;
	while (b) {
		if (b &amp; 1)
			ans = (ans * a) % MOD;
		a = (a * a) % MOD;
		b &gt;&gt;= 1;
	}
	return ans;
}

int sum(int p, int c) {
	if (c == 0) return 1;
	if (c == 1) return p + 1;
	const int k = c / 2;
	if (c &amp; 1) {
		const int t = (1 + pow(p, k + 1)) % MOD;
		return (t * sum(p, k)) % MOD;
	} else {
		const int t = (1 + pow(p, k)) % MOD;
		return (t * sum(p, k - 1) + pow(p, 2 * k)) % MOD; 
	}
}

int main() {
	a = read(), b = read();
	for (int i = 2; i * i &lt;= a; ) {
		if (a % i == 0)
			++m[i], a /= i;
		else
			++i;
	}
	if (a != 1)
		++m[a];
    if (!a) return puts(&quot;0&quot;), 0;
	int ans = 1;
	for (auto [p, k] : m) {
		ans = (ans * sum(p % MOD, k * b)) % MOD;
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x031 前缀和]]></title>
    <link href="oi.afobject.ml/16424780591373.html"/>
    <updated>2022-01-18T11:54:19+08:00</updated>
    <id>oi.afobject.ml/16424780591373.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E6%BF%80%E5%85%89%E7%82%B8%E5%BC%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>激光炸弹</h2>
<p><tc><c>0x0301</c><c>HNOI 2003</c><e>Easy</e><t>前缀和</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>使用二维前缀和。</p>
\[\begin{aligned}
&amp;\operatorname{sum}((x_1,y_1),(x_2,y_2)) \\
&amp; =
\operatorname{pre}(x_2,y_2) -
\operatorname{pre}(x_1-1,y_2) -\operatorname{pre}(x_2,y_1-1) +
\operatorname{pre}(x_1-1,y_1-1)
\end{aligned}
\]
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>思维没有任何难度，主要是实现上。题意不清楚，也没解释是什么坐标系。</p>
<ol>
<li>
<blockquote>
<p>若目标位于爆破正方形的边上，该目标不会被摧毁。</p>
</blockquote>
<p>显然对于 \(m\) 没有任何影响。因为目标在整点处，正方形相当于包围着它们的边，只不过加了 \(0.5\) 的 padding。</p>
</li>
<li>
<blockquote>
<p>\(0 \le x_i, y_i \le 5 \times 10^3\)。</p>
</blockquote>
<p>所以区域范围是 \((0,0)\) 到 \((5\times 10^3, 5 \times 10^3)\)。</p>
</li>
</ol>
<p>因此遍历正方形左上角的范围应该是 \((0,0)\) 到 \((5\times10^3-m+1,5\times10^3-m+1)\)。</p>
<p>细节挺多的，除了数组边界问题（其实全 +1 更方便但忘了懒得改了），还有尤其是关于 \(m\) 的那条一开始想对就对了，一开始想错很难发现。所以避免在脑子不清醒时做题！</p>
<pre class="line-numbers"><code class="language-cpp">int n, m;
int pre[5001][5001];

int sum(int x1, int y1, int x2, int y2) {
	return pre[x2][y2] - (x1 ? pre[x1 - 1][y2] : 0) - (y1 ? pre[x2][y1 - 1] : 0) + ((x1 &amp;&amp; y1) ? pre[x1 - 1][y1 - 1] : 0);
}

int main() {
	n = read(), m = read();
	int max = 0;
	while (n--) {
		int x = read(), y = read();
		pre[x][y] += read();
		max = std::max(max, pre[x][y]);
	}
	for (int r = 0; r &lt;= 5000; ++r)
		for (int c = 0; c &lt;= 5000; ++c) {
			if (!r &amp;&amp; !c) continue;
			else if (!r) pre[r][c] += pre[r][c - 1];
			else if (!c) pre[r][c] += pre[r - 1][c];
			else pre[r][c] += pre[r - 1][c] + pre[r][c - 1] - pre[r - 1][c - 1];
		}
	for (int x = 0; x + m - 1 &lt;= 5000; ++x)
		for (int y = 0; y + m - 1 &lt;= 5000; ++y)
			max = std::max(max, sum(x, y, x + m - 1, y + m - 1));
	printf(&quot;%d\n&quot;, max);
	return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x023 分形]]></title>
    <link href="oi.afobject.ml/16424644153749.html"/>
    <updated>2022-01-18T08:06:55+08:00</updated>
    <id>oi.afobject.ml/16424644153749.html</id>
    <content type="html"><![CDATA[
<h2><a id="fractal-streets" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Fractal Streets</h2>
<p><tc><c>0x0207</c><e>Easy+</e><t>递归</t><t>模拟</t><t>数学</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>一个 \(N\) 级城市可以分为 4 个 \(N-1\) 级小城市。以此为依据进行递推。</p>
<p><strong>以城市的中心为原点，建立平面直角坐标系。</strong></p>
<p>首先我们令 \(k = \lfloor \frac {i-1} {4^{n-1}} \rfloor\)（实现的时候所有 \(i\) 自动减一）。\(k=0\) 在第二象限，\(k=1\) 在第一象限，\(k=2\) 在第四象限，\(k=3\) 在第三象限。</p>
<p>以第一、四象限的城市为标准图形。<strong>第二象限的是把标准图形沿 \(y\) 轴翻折然后逆时针旋转 \(90^{\circ}\)</strong>，就能把编号顺序和标准图形对应上，第三象限同理，是<strong>沿 \(y\) 轴翻折然后顺时针旋转 \(90^{\circ}\)</strong>。</p>
<p>设以标准图形求出来的是 \((x,y)\)，\(\Delta = 2^{N-2}\)。</p>
<table>
<thead>
<tr>
<th style="text-align: center">\(k\)</th>
<th style="text-align: center">坐标</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">\(\quad0\quad\)</td>
<td style="text-align: center">\((-y-\Delta,-x+\Delta)\)</td>
</tr>
<tr>
<td style="text-align: center">\(\quad1\quad\)</td>
<td style="text-align: center">\((x+\Delta,y+\Delta)\)</td>
</tr>
<tr>
<td style="text-align: center">\(\quad2\quad\)</td>
<td style="text-align: center">\((x+\Delta,y-\Delta)\)</td>
</tr>
<tr>
<td style="text-align: center">\(\quad3\quad\)</td>
<td style="text-align: center">\((y-\Delta,x-\Delta)\)</td>
</tr>
</tbody>
</table>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>退钱，精度问题卡了巨久，，，</p>
<p>「所有房屋在格子中间」这条有点烦，可以把每个格子长度设为 2，然后房屋在正中间。最后答案乘以 5。</p>
<p>虽然开了 <code>__int128</code> 以后大概不用这样。</p>
<pre class="line-numbers"><code class="language-cpp">#define sq(x) ((x) * (x))
#define int __int128
#define x first
#define y second

int T, n, s, d;

int read() {
    int ans = 0, neg = 1; char ch = getchar();
    while (ch &lt; '0' || ch &gt; '9') { if (ch == '-') neg = -1; ch = getchar(); }
    while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') { ans *= 10; ans += (ch - '0'); ch = getchar(); }
    return ans * neg;
}

std::pair&lt;int, int&gt; solve(int n, int i) {
	if (n == 0) return std::make_pair(0, 0);
	if (n == 1) {
		if (i == 0) return std::make_pair(-1, 1);
		if (i == 1) return std::make_pair(1, 1);
		if (i == 2) return std::make_pair(1, -1);
		if (i == 3) return std::make_pair(-1, -1);
	}
	const int k = i / (1ll &lt;&lt; (2 * n - 2)),
				 r = i % (1ll &lt;&lt; (2 * n - 2)),
				 d = (1ll &lt;&lt; (n - 2)) * 2ll;
	auto a = solve(n - 1, r);
	if (k == 0) return std::make_pair(-a.y - d, -a.x + d);
	if (k == 1) return std::make_pair(a.x + d, a.y + d);
	if (k == 2) return std::make_pair(a.x + d, a.y - d);
	if (k == 3) return std::make_pair(a.y - d, a.x - d);
	return std::make_pair(0, 0);
}

signed main() {
	T = read();
	while (T--) {
		n = read(), s = read(), d = read();
		auto l = solve(n, s - 1), r = solve(n, d - 1);
		printf(&quot;%.0lf\n&quot;, (double)sqrt(sq(r.x - l.x) + sq(r.y - l.y)) * 5);
	}
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x032 差分]]></title>
    <link href="oi.afobject.ml/16425501421616.html"/>
    <updated>2022-01-19T07:55:42+08:00</updated>
    <id>oi.afobject.ml/16425501421616.html</id>
    <content type="html"><![CDATA[
<h2><a id="incdec-sequence" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>IncDec Sequence</h2>
<p><tc><c>0x0302</c><e>Easy</e><t>差分</t></tc></p>
<p>给定个长度为 \(n\) 的数列，每次可以选择一个区间同加 \(1\) 或减 \(1\)，要求最终所有数一样，求最小操作次数和满足最小操作次数的方案数。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>比较显然的差分：每次操作是对差分数列 \(c\) 中任两个数一个加 \(1\)，一个减 \(1\)。最终要求差分数组的除第一项、末项均为 \(0\)。</p>
<p>分析一下样例：<code>1 1 2 2 (0)</code></p>
<p>差分数组为：<code>1 0 1 0 -2</code></p>
<p>两种方案为：</p>
<ul>
<li>\(c_1 \gets c_1+1\)，\(c_3 \gets c_3-1\)：<code>2 0 0 0 -2</code></li>
<li>\(c_3 \gets c_3-1,c_5 \gets c_5+1\)：<code>1  0 0 0 -1</code></li>
</ul>
<p>观察到：</p>
<ul>
<li><strong>差分数组的第一个数的种数就是最后数列的种数</strong>；</li>
<li>差分数组的和始终保持为 \(0\)。</li>
</ul>
<h4><a id="%E7%AC%AC%E4%B8%80%E5%B0%8F%E9%97%AE%EF%BC%9A%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第一小问：最小操作次数</h4>
<p>那就是<strong>尽量在 \([2,n]\) 中正、负配对</strong>，配对不过来再考虑用上首项和末项。</p>
<p>令 \(p = \sum_{c=2}^{n} \vert c_i \vert [c_i &lt; 0]\)，\(q = \sum_{c=2}^{n} c_i[c_i &gt;0]\)。</p>
<ol>
<li>能正负配对的对数应该是 \(\min\{p,q\}\)。还不够的，就要拿首、末来凑了。</li>
<li>所以还需要的操作次数是此时的 \(\sum_{c=2}^{n} \vert c_i \vert\)，即 \(\vert p-q \vert\)。</li>
</ol>
<h4><a id="%E7%AC%AC%E4%BA%8C%E5%B0%8F%E9%97%AE%EF%BC%9A%E6%95%B0%E5%88%97%E7%A7%8D%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第二小问：数列种数</h4>
<p>上述第 1 步不会对 \(c_1\) 产生影响，关键是第二步如何消灭中间的数。</p>
<p>其实很容易发现，最终 \(c_1\) 的值域范围是：</p>
<ul>
<li>如果 \([2,n]\) 留下的数全是正数
<ul>
<li>最小：\(c_1-\vert p-q \vert\)。全拿 \(c_1\) 来抵了。</li>
<li>最大：\(c_1\)。不会更多。</li>
</ul>
</li>
<li>如果 \([2,n]\) 留下的全是负数
<ul>
<li>最小：\(c_1\)。</li>
<li>最大：\(c_1+ \vert p-q \vert\)。</li>
</ul>
</li>
</ul>
<p>因此数列种数就是第一小问求得的 \(\vert p-q \vert +1\)。</p>
<p>这波啊，之前为了方便在差分数组末尾加的数也没必要了。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>时间 \(\Theta(n)\)，空间 \(\Theta(1)\)。</p>
<pre class="line-numbers"><code class="language-cpp">#define int long long

int n;
signed main() {
	n = read();
	int p = 0, q = 0, last = 0, c;
	for (int i = 1; i &lt;= n; ++i) {
		c = read() - last, last += c;
		if (i &gt; 1) {
			if (c &gt; 0) p += c;
			else q -= c;
		}
	}
	printf(&quot;%lld\n%lld\n&quot;, std::min(p, q) + abs(p - q), abs(p - q) + 1);
	return 0;
}
</code></pre>
<hr />
<h2><a id="tallest-cow" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Tallest Cow</h2>
<p><tc><c>0x0303</c><c>USACO</c><c>LG2879</c><e>Easy</e><t>差分</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>sb 诈骗题，假设所有牛都最高，然后把每个区间内的牛砍一刀就行了。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>判重。</p>
<pre class="line-numbers"><code class="language-cpp">#define MP std::make_pair

int n, h, r;
int c[100001];

std::set&lt;std::pair&lt;int, int&gt;&gt; s;

signed main() {
	n = read(), h = read(), h = read(), r = read();
	while (r--) {
		int x = read(), y = read();
		if (x &gt; y) std::swap(x, y);
		if (s.find(MP(x, y)) == s.end()) {
			--c[x + 1], ++c[y];
			s.insert(MP(x, y));
		}
	}
	int a = h;
	for (int i = 1; i &lt;= n; ++i) {
		a += c[i];
		printf(&quot;%d\n&quot;, a);
	}
	return 0;
}
</code></pre>

]]></content>
  </entry>
  
</feed>
