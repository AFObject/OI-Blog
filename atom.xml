<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[OI Blog]]></title>
  <link href="oi.afobject.ml/atom.xml" rel="self"/>
  <link href="oi.afobject.ml/"/>
  <updated>2022-08-06T23:50:38+08:00</updated>
  <id>oi.afobject.ml/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[ABC262]]></title>
    <link href="oi.afobject.ml/abc262.html"/>
    <updated>2022-08-03T22:26:17+08:00</updated>
    <id>oi.afobject.ml/abc262.html</id>
    <content type="html"><![CDATA[
<p>Rated, 4/8, 1007 \(\to\) 1044</p>
<h2><a id="d-i-hate-non-integer-number" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>D I Hate Non-integer Number</h2>
<p><tc><m>Medium *1213</m><t>DP</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>显然事需要枚举选出的数的个数 \(i\) 的。将所有数模 \(i\)，要求选出来的数和为 0。</p>
<p>开始 dp。</p>
<p>设 \(f(k,s,d)\) 为，在前 \(k\) 个数中选取 \(d\) 个数，且总和为 \(s\)。转移非常显然，\(f(k,s,d)=f(k-1,s-a_k\bmod i,d-1)+f(k-1,s,d)\)。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">#define int long long

int n, a[101], b[101];
int dp[101][101][101];

signed main() {
    n = read();
    for (int i = 1; i &lt;= n; ++i) a[i] = read();
    int ans = n;
    for (int i = 2; i &lt;= n; ++i) {
        int sum = 0;
        for (int j = 1; j &lt;= n; ++j)
            b[j] = a[j] % i, sum = (sum + b[j] + i) % i;
        for (int s = 0; s &lt; i; ++s)
            for (int k = 1; k &lt;= n; ++k)
                for (int d = 1; d &lt;= n; ++d)
                    dp[k][s][d] = 0;
        for (int j = 1; j &lt;= n; ++j)
            for (int k = j; k &lt;= n; ++k)
                ++dp[k][b[j]][1];

        for (int k = 1; k &lt;= n; ++k)
            for (int d = 2; d &lt;= std::min(k, i); ++d)
                for (int s = 0; s &lt; i; ++s)
                    dp[k][s][d] = (dp[k - 1][(s - b[k] + i) % i][d - 1] + dp[k - 1][s][d]) % 998244353;
        ans = (ans + dp[n][0][i]) % 998244353;
    }
    printf(&quot;%lld\n&quot;, ans);
}
</code></pre>
<hr />
<h2><a id="e-red-and-blue-graph" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>E Red and Blue Graph</h2>
<p><tc><m>Medium *1719</m><t>图论</t><t>组合</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>设 \(X\) 为连接红点和红点的边的条数，\(Y\) 为连接红点和蓝点的边的条数。所有红点的度数总和为 \(R=2X+Y\)，因此 \(R\) 与 \(Y\) 同奇偶。想要 \(Y\) 为偶数，让 \(R\) 为偶数即可。</p>
<p>让 \(R\) 为偶数，就是只能有偶数个奇点被选入红点。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>复习：</p>
<ol>
<li>组合数：\(\displaystyle \binom{n}{m}=\dfrac{n!}{(n-m)!\cdot m!}\)</li>
<li>有理数取模：\(\dfrac ab \bmod p=a\cdot b^{p-2}\)</li>
</ol>
<pre class="line-numbers"><code class="language-cpp">#define int long long
#define MOD 998244353

int n, m, k;
int deg[200001];

int fact[200001];
int qpow(int a, int b) {
    int ans = 1;
    while (b) {
        if (b &amp; 1) ans = (ans * a) % MOD;
        a = (a * a) % MOD;
        b &gt;&gt;= 1;
    }
    return ans;
}

int binom(int a, int b) {
    return (fact[a] * qpow((fact[a - b] * fact[b]) % MOD, MOD - 2)) % MOD;
}


signed main() {
    n = read(), m = read(), k = read();

    fact[0] = 1;
    for (int i = 1; i &lt;= n; ++i)
        fact[i] = (fact[i - 1] * i) % MOD;

    while (m--) {
        int u = read(), v = read();
        ++deg[u]; ++deg[v];
    }
    int odd = 0;
    for (int i = 1; i &lt;= n; ++i) if (deg[i] &amp; 1) ++odd;
    int ans = 0;
    for (int d = 0; d &lt;= std::min(odd, k); d += 2) {
        if (k - d &lt;= n - odd)
            ans = (ans + binom(odd, d) * binom(n - odd, k - d)) % MOD;
    }
    printf(&quot;%lld\n&quot;, ans);
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x171 堆与贪心]]></title>
    <link href="oi.afobject.ml/0x171.html"/>
    <updated>2022-07-29T22:00:10+08:00</updated>
    <id>oi.afobject.ml/0x171.html</id>
    <content type="html"><![CDATA[
<h2><a id="supermarket" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Supermarket</h2>
<p><tc><c>0x1701</c><m>Medium</m><t>贪心</t><t>反悔贪心</t><t>堆</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>对于第 \(t\) 天，我们尽量要去选前 \(t\) 大的卖掉，但是不能有过期的。</p>
<p>首先先满足要求，不能有过期的，那就按时间顺序从小到大排个序，从头开始取，不会有问题。但是显然是不优的，那就要在贪心过程中调整策略，当碰到一个恰好要在那一个时刻过期且未被选中的商品，显然是要比原方案优的，把它顶上去。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>欢迎来到不开 ll 见祖宗系列</p>
<pre class="line-numbers"><code class="language-cpp">#define int long long
#define pii std::pair&lt;int, int&gt;

std::priority_queue&lt;pii, std::vector&lt;pii&gt;, std::greater&lt;pii&gt;&gt; q;

signed main() {
    n = read();
    for (int i = 1; i &lt;= n; i++)
        a[i].first = read(), a[i].second = read();
    std::sort(a + 1, a + n + 1);
    for (int i = 1; i &lt;= n; i++) {
        if (q.size() &lt; a[i].first) q.push({a[i].second, a[i].first});
        else if (q.size() == a[i].first) {
            if (a[i].second &gt; q.top().first)
                q.pop(), q.push({a[i].second, a[i].first});
        }
    }
    int ans = 0;
    while (q.size()) ans += q.top().first, q.pop();
    printf(&quot;%lld\n&quot;, ans);
}
</code></pre>
<hr />
<h2><a id="sequence" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sequence</h2>
<p><tc><c>0x1702</c><m>Medium+</m><t>贪心</t><t>排序</t><t>堆</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>考虑 \(M=2\)。两个序列分别排序，第一小是 \(a_1+b_1\)。第二大是 \(a_1+b_2\) 或 \(a_2+b_1\) 中的一个。假设是前一个，那么第三大就是 \(a_2+b_1, a_1+b_3, a_2+b_2\) 中的一个。以此类推，后面我不想写了。</p>
<p>考虑重复的问题：把路径画出来分配一下。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h4xgd4f8jwj20u00ydacv.jpg" alt="" /></p>
<p>反正就是</p>
\[\begin{aligned}
(i,j,true) &amp;\to (i,j+1,true) \\
(i,j,false) &amp;\to \begin{cases}
(i+1,j+1, false)\\
(i,j+1,true)\end{cases}
\end{aligned}
\]
<p>当扩展到 \(M&gt;2\) 时，先求前两个，再结合第三个，……，懒得写了，结束。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int m, n;
std::vector&lt;int&gt; d[2001];

struct Node {
    int val, i, j;
    bool k;
    bool operator &lt; (const Node &amp;rhs) const {
        return val &gt; rhs.val;
    }
};

std::vector&lt;int&gt; cal(std::vector&lt;int&gt; &amp;a, std::vector&lt;int&gt; &amp;b) {
    std::priority_queue&lt;Node&gt; q;
    q.push((Node){a[1] + b[1], 1, 1, false});
    std::vector&lt;int&gt; ans;
    ans.push_back(0);
    while (!q.empty()) {
        Node x = q.top(); q.pop();
        ans.push_back(x.val);
        if (ans.size() == n + 1) break;
        if (!x.k &amp;&amp; x.i + 1 &lt;= n) q.push((Node){a[x.i + 1] + b[x.j], x.i + 1, x.j, false});
        if (x.j + 1 &lt;= n) q.push((Node){a[x.i] + b[x.j + 1], x.i, x.j + 1, true});
    }
    return ans;
}

int T;
int main() {
    T = read();
    while (T--) {
        m = read(), n = read();
        for (int i = 1; i &lt;= m; ++i) {
            d[i].clear();
            d[i].push_back(0);
            for (int j = 1; j &lt;= n; ++j)
                d[i].push_back(read());
            std::sort(d[i].begin() + 1, d[i].end());
        }
        if (m == 1) {
            for (int i = 1; i &lt;= n; ++i)
                printf(&quot;%d &quot;, d[1][i]);
            putchar('\n');
            continue;
        }
        auto ans = cal(d[1], d[2]);
        for (int i = 3; i &lt;= m; ++i)
            ans = cal(ans, d[i]);
        for (int i = 1; i &lt;= n; ++i)
            printf(&quot;%d &quot;, ans[i]);
        putchar('\n');
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ABC261]]></title>
    <link href="oi.afobject.ml/abc261.html"/>
    <updated>2022-07-23T22:27:19+08:00</updated>
    <id>oi.afobject.ml/abc261.html</id>
    <content type="html"><![CDATA[
<p>[6/8] Rated, 3/8, 1031 \(\to\) 1007，这下这下了</p>
<h2><a id="e-many-operations" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>E Many Operations</h2>
<p><tc><m>Medium *1261</m><t>位运算</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>看一下朴素算法劣在哪里，主要就是明明知道通过的是哪几个运算符，而且之前也算过一遍，但因为一开始的数不一样，还得重算一遍。</p>
<p>解决这个问题，可以从「一开始的数」入手，如果把一开始的数抽象化一点，二进制一位一位看，这样就能更好地利用之前算好的结果。</p>
<p>提前预处理一下每一位上 0 或 1 通过前若干个运算符后的结果，然后算答案的时候先拆位，分别计算再合并。</p>
<p>拆那</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>也可以写成在线做法捏。</p>
<pre class="line-numbers"><code class="language-cpp">int x, n;
int d[200001][31][2];

int main() {
    n = read(), x = read();
    for (int i = 0; i &lt;= 30; ++i)
        d[0][i][1] = 1, d[0][i][0] = 0;
    for (int i = 1; i &lt;= n; ++i) {
        int t = read(), p = read();
        for (int j = 0; j &lt;= 30; ++j) {
            d[i][j][0] = d[i - 1][j][0]; 
            d[i][j][1] = d[i - 1][j][1];
            if (t == 1)
                d[i][j][0] &amp;= ((p &gt;&gt; j) &amp; 1),
                d[i][j][1] &amp;= ((p &gt;&gt; j) &amp; 1);
            else if (t == 2)
                d[i][j][0] |= ((p &gt;&gt; j) &amp; 1),
                d[i][j][1] |= ((p &gt;&gt; j) &amp; 1);
            else if (t == 3)
                d[i][j][0] ^= ((p &gt;&gt; j) &amp; 1),
                d[i][j][1] ^= ((p &gt;&gt; j) &amp; 1);
        }
    }
    for (int i = 1; i &lt;= n; ++i) {
        int ans = 0;
        for (int j = 0; j &lt;= 30; ++j)
            ans += d[i][j][((x &gt;&gt; j) &amp; 1)] &lt;&lt; j;
        printf(&quot;%d\n&quot;, ans);
        x = ans;
    }
    return 0;
}
</code></pre>
<hr />
<h2><a id="d-flipping-and-bonus" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>D Flipping and Bonus</h2>
<p><tc><m>Medium *801</m><t>DP</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>设 \(f(i,j)\) 为第 \(i\) 轮游戏后计数器为 \(j\) 的最大收益。</p>
<p>怎么转移捏？\(f(i-1,j-1)\) 肯定是可以过来的，过程中加上 \(x_i\) 和对应的 Bonus。另外当 \(j=0\) 时从 \(f(i-1,t)\) 都可以过来，其中 \(0 \le t &lt;i\)，收益为 \(0\)。</p>
<p>然后捏麻麻地压掉一维，就这</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>呃呃，压维的过程比想象的要复杂，有很多要考虑，建议直接偷懒</p>
<pre class="line-numbers"><code class="language-cpp">#define int long long

int n, m;
int x[5001], y[5001];
int dp[2][5001];

signed main() {
    n = read(), m = read();
    for (int i = 1; i &lt;= n; i++) x[i] = read();
    for (int i = 1, t; i &lt;= m; i++) t = read(), y[t] = read();

    for (int i = 1; i &lt;= n; i++) {
        for (int k = 0; k &lt; i; k++)
            dp[i &amp; 1][0] = std::max(dp[i &amp; 1][0], dp[(i ^ 1) &amp; 1][k]);
        for (int k = i; k; k--)
            dp[i &amp; 1][k] = dp[(i ^ 1) &amp; 1][k - 1] + x[i] + y[k];
    }

    int ans = 0;
    for (int i = 0; i &lt;= n; ++i) {
        ans = std::max(ans, dp[n &amp; 1][i]);
    }
    printf(&quot;%lld\n&quot;, ans);
}
</code></pre>
<hr />
<h2><a id="f-sorting-color-balls" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>F Sorting Color Balls</h2>
<p><tc><m>Medium *1587</m><t>逆序对</t></tc></p>
<p>给定两个数列 \(X\) 和 \(C\)，可以同时交换相邻的两个，若 \(C\) 不同则代价为 \(1\)，求使得 \(X\) 升序最小的代价。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>差一点点就是逆序对问题了，看看怎么解决 \(C\) 相同时的问题。</p>
<p>你求出来的所有逆序对，其中多余了 \(C\) 相同的逆序对，那直接把 \(C\) 相同的逆序对拎出来减掉不就好了？</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>还真不开 ll 见祖宗是吧</p>
<pre class="line-numbers"><code class="language-cpp">#define int long long

int n;
std::vector&lt;int&gt; _, x, c[1000001];

int cal(std::vector&lt;int&gt; &amp;v, int l, int r) {
    if (l &gt;= r) return 0;
    const int mid = (l + r) &gt;&gt; 1;
    int ans = cal(v, l, mid) + cal(v, mid + 1, r);
    int ql = l, qr = mid + 1;
    for (int i = l; i &lt;= r; ++i) {
        if ((v[ql] &lt;= v[qr] &amp;&amp; ql &lt;= mid) || qr == r + 1) _[i] = v[ql++];
        else _[i] = v[qr++], ans += mid - ql + 1;
    }
    for (int i = l; i &lt;= r; ++i) v[i] = _[i];
    return ans;
}

signed main() {
    n = read();
    _.resize(n);
    for (int i = 0; i &lt; n; ++i) _[i] = read();
    for (int i = 0; i &lt; n; ++i) x.push_back(read());
    for (int i = 0; i &lt; n; ++i) c[_[i]].push_back(x[i]);
    int ans = cal(x, 0, n - 1);
    for (int i = 1; i &lt;= n; ++i) ans -= cal(c[i], 0, c[i].size() - 1);
    printf(&quot;%lld\n&quot;, ans);
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x16 Trie]]></title>
    <link href="oi.afobject.ml/0x16-.html"/>
    <updated>2022-07-19T23:03:21+08:00</updated>
    <id>oi.afobject.ml/0x16-.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E5%89%8D%E7%BC%80%E7%BB%9F%E8%AE%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前缀统计</h2>
<p><tc><c>0x1601</c><e>Easy</e><t>Trie</t></tc></p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>都什么年代，还在用传统指针写法？</p>
<pre class="line-numbers"><code class="language-cpp">int n, m;
char s[5000001];

struct Node {
    int num;
    Node *sons[26];
} f;
void add(Node &amp;x, char *s, int t, int len) {
    if (t &gt;= len) {
        ++x.num;
        return;
    }
    const int T = s[t] - 'a';
    if (x.sons[T] == NULL)
        x.sons[T] = new Node();
    add(*x.sons[T], s, t + 1, len);
}
int find(Node &amp;x, char *s, int t, int len) {
    if (t &gt;= len) return x.num;
    const int T = s[t] - 'a';
    if (x.sons[T] == NULL)
        return x.num;
    return x.num + find(*x.sons[T], s, t + 1, len);
}
int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    while (n--) {
        scanf(&quot;%s&quot;, s);
        const int len = strlen(s);
        add(f, s, 0, len);
    }
    while (m--) {
        scanf(&quot;%s&quot;, s);
        const int len = strlen(s);
        printf(&quot;%d\n&quot;, find(f, s, 0, len));
    }
}
</code></pre>
<hr />
<h2><a id="the-xor-largest-pair" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>The XOR Largest Pair</h2>
<p><tc><c>0x1602</c><e>Easy+</e><t>Trie</t><t>位运算</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>首先全部插一个 0-1 Trie 里面（从高位到低位），然后反着来查找就好了。可以边插入边查询。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>正常写法。</p>
<p><code>t</code> 里面记的全是编号，相当于指针，<code>tot</code> 就是一个发配编号的东西。这个题里面不需要额外维护什么东西，只用检查这个节点存不存在，不像上一个题还得计数。</p>
<pre class="line-numbers"><code class="language-cpp">int n;

int t[10000001][2], tot = 1;

void insert(int x) {
    for (int i = 30, p = 1; i &gt;= 0; --i) {
        const int g = (x &gt;&gt; i) &amp; 1;
        if (!t[p][g]) t[p][g] = ++tot;
        p = t[p][g];
    }
}

int search(int x) {
    int ans = 0;
    for (int i = 30, p = 1; i &gt;= 0; --i) {
        const int g = (x &gt;&gt; i) &amp; 1;
        if (t[p][!g]) p = t[p][!g], ans += 1 &lt;&lt; i;
        else p = t[p][g];
    }
    return ans;
}

int main() {
    n = read();
    int max = 0;
    while (n--) {
        int a = read();
        insert(a);
        max = std::max(max, search(a));
    }
    printf(&quot;%d\n&quot;, max);
}
</code></pre>
<hr />
<h2><a id="the-xor-longest-path" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>The XOR Longest Path</h2>
<p><tc><c>0x1603</c><e>Easy+</e><t>Trie</t><t>位运算</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>以下用「叉」代表 XOR。</p>
<p>一个数叉自己等于零，一个数叉零等于自己，所以两点之间的距离就等于（根到一端的叉和）叉（根到另一端的叉和）。</p>
<p>把所有的根到一端的叉和塞到上一题里面就好了。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n;

// 上题代码

int d[100001];
std::vector&lt;std::pair&lt;int, int&gt; &gt; e[100001];
void dfs(int x, int fa) {
    for (auto t : e[x]) {
        if (t.first == fa) continue;
        d[t.first] = d[x] ^ t.second;
        dfs(t.first, x);
    }
}

int main() {
    n = read();
    for (int i = 1; i &lt; n; ++i) {
        int u = read(), v = read(), w = read();
        e[u].push_back({v, w});
        e[v].push_back({u, w});
    }
    dfs(0, -1);
    int max = 0;
    for (int i = 0; i &lt; n; ++i) {
        insert(d[i]);
        max = std::max(max, search(d[i]));
    }
    printf(&quot;%d\n&quot;, max);
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ABC259]]></title>
    <link href="oi.afobject.ml/abc259.html"/>
    <updated>2022-07-09T22:15:54+08:00</updated>
    <id>oi.afobject.ml/abc259.html</id>
    <content type="html"><![CDATA[
<p>[6/8] Rated, 4/8, 987 \(\to\) 1031</p>
<p>A 和 B 春春闹潭。</p>
<h2><a id="f-select-edges" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>F Select Edges</h2>
<p><tc><m>Medium *1961</m><t>DP</t><t>树</t><t>搜索</t><t>贪心</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>一眼就是类似树形 dp 的东西。</p>
<p>计算以 \(u\) 为子树时的答案的时候，需要考虑：</p>
<ol>
<li>\(u\) 的父亲和 \(u\) 是否已经相连，占掉 \(u\) 的一个连接名额？所以加一个状态。</li>
<li>对于每一个儿子结点 \(v\)，是否连接 \(u\) 和 \(v\)？如果连接，则 \(v\) 的连接名额就要减少一个（I 型）；如果不连接，直接跳过这条边，在以 \(v\) 为根的一棵全新的子树上继续计算（II 型）。</li>
</ol>
<p>对于以上第二点继续讨论：这样的话能算出如果选了结点 \(v\)，以这个结点 \(v\) 为根的子树能带来的对答案的贡献。但是会有 \(d\) 的限制，这个限制对 I 型无效，所以一定要贪心地选择前 \(d\) 个收益最高的 II 型。</p>
<p>「收益最高」指的是什么？绝对值最高吗？不是吧。指的是 II 型相对于 I 型带来的更多的收益，也就是它们的差值。</p>
<p>比如有两个 I 型分别为 \(1\) 和 \(114514\)，它们对应的 II 型分别为 \(1919810\) 和 \(1919811\)，\(d=1\)，现在要选择一个 II 型。显然本来的 I 型就有 \(114515\) 了，把第一个还是第二个替换成 II 型？显然是前者，因为差值更大。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>直接用一个 <code>std::vector</code> 存一下所有 II - I 的差值，然后 <code>std::sort</code> 排序即可。</p>
<p>我用的是记忆化搜索的写法来写的，赛时改来改去有点混乱。当然也可以用接近普通 dp 的写法来写（\(f(x,t)\) 代表是否连接 \(f_x\to x\) 的状态为 \(t\) 时，以 \(x\) 为根的子树带来的最大答案）。</p>
<pre class="line-numbers"><code class="language-cpp">#define int long long

struct Edge {
    int v, w;
};

int n, d[300005];
std::vector&lt;Edge&gt; e[300005];

int dp[300005][2];

int f(int x, int lim, int fa) {
    if (lim &lt; 0) return -1e9;
    if (e[x].size() == 0) return 0;
    if (dp[x][lim != d[x]] != -1) return dp[x][lim != d[x]];
    
    std::vector&lt;int&gt; v;
    int ans = 0;
    for (Edge g : e[x]) {
        if (g.v == fa) continue;
        int l1 = f(g.v, d[g.v] - 1, x) + g.w;
        int l2 = f(g.v, d[g.v], x);
        ans += l2;
        v.push_back(l1 - l2);
    }
    std::sort(v.begin(), v.end(), std::greater&lt;int&gt;());
    for (int i = 0; i &lt; v.size(); ++i)
        if (v[i] &gt; 0 &amp;&amp; i &lt; lim) ans += v[i];

    dp[x][lim != d[x]] = ans;
    std::vector&lt;int&gt;().swap(v); // 动态清零😆！
    return ans;
}

int deg[3000001];
signed main() {
    memset(dp, -1, sizeof dp);
    n = read();
    for (int i = 1; i &lt;= n; ++i) d[i] = read();
    for (int i = 1; i &lt; n; ++i) {
        int u = read(), v = read(), w = read();
        ++deg[u]; ++deg[v];
        e[u].push_back({v, w});
        e[v].push_back({u, w});
    }
    int rt = 0;
    for (int i = n; i &gt;= 1; --i) if (deg[i] == 1) rt = i;
    printf(&quot;%lld\n&quot;, f(1, d[1], 0));
}
</code></pre>
<hr />
<h2><a id="e-lcm-on-whiteboard" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>E LCM on Whiteboard</h2>
<p><tc><m>Medium *1370</m><t>数论</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>当一个都不删的时候，答案应当是 \(\displaystyle\prod p^{\max\{e(p)\}}\)。</p>
<p>当一个数 \(a\) 的某一个质因数 \(p\) 的指数在所有 \(n\) 个数中最大（且没有并列）时，我们称「\(a\) 占有 \(p\)」。</p>
<p>当删除一个数 \(a\) 的时候，对于每个出现过的质数 \(p\)，\(\max\{e(p)\}\) 可能会有变化。我们很容易可以得到去掉某一个数时，整体的变化情况：有且仅有 \(a\) 占有的质数，在 LCM 表达式中其右上角的指数会变少。现在的问题是在于如何快速找到<strong>有几种不同的变化情况</strong>。显然，看看一共有多少个数「占有」至少一个质因数就行了，别忘了，当存在一个不占有任何质因子的数时，答案要加上一（即原 LCM）。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">#define int long long

int n;
std::map&lt;int, int&gt; max, pos;
std::set&lt;int&gt; s;

signed main() {
    n = read();
    for (int i = 1, m, e, p; i &lt;= n; i++) {
        m = read();
        while (m--) {
            p = read(), e = read();
            if (e &gt; max[p]) max[p] = e, pos[p] = i;
            else if (e == max[p] &amp;&amp; pos.find(p) != pos.end()) pos.erase(pos.find(p)); // 注意！当出现相等的时候，双方都不占有这个质因数，要从 map 中去掉。
        }
    }

    for (auto [x, y] : pos)
        s.insert(y);
    printf(&quot;%lu\n&quot;, s.size() + (s.size() != n));
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x15 字符串]]></title>
    <link href="oi.afobject.ml/0x15-.html"/>
    <updated>2022-07-03T23:13:38+08:00</updated>
    <id>oi.afobject.ml/0x15-.html</id>
    <content type="html"><![CDATA[
<h2><a id="0x151-kmp%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>0x151 KMP 模式匹配</h2>
<p>目的：匹配字符串 A 在字符串 B 中各次出现的位置。</p>
<h3><a id="%E4%B8%80%E4%BA%9B%E5%AE%9A%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一些定义</h3>
<p>\(S_{l\dots r}\)：S 字符串中 \([l,r]\) 范围内的子串。</p>
<p>\(next(i)\)：<strong>满足 \(A_{1 \ldots j}=A_{i-j+1\ldots i}\) 的最大的 \(j\)（\(0\le j&lt;i\)）</strong>。</p>
<pre class="line-numbers"><code class="language-text">   1  j       i
   |  |       |
A: ABCD....ABCD....
</code></pre>
<p>为了方便表述，称 \(A_{1 \ldots j}\) 为 \(next(i)\) 的「前字符串」，\(A_{i-j+1\ldots i}\) 为「后字符串」。</p>
<p>\(f(i)\)：<strong>满足 \(A_{1 \ldots j}=B_{i-j+1\ldots i}\) 的最大的 \(j\)（\(0 \le j\le i\)）</strong>。</p>
<pre class="line-numbers"><code class="language-text">   1  j      i
   |  |      |
A: ABCD...........
B: .......ABCD....
</code></pre>
<p>为了方便表述，称 \(A_{1 \ldots j}\) 为 \(f(i)\) 「前字符串」，\(B_{i-j+1\ldots i}\) 为「后字符串」。</p>
<h3><a id="%E8%AE%A1%E7%AE%97next%E6%95%B0%E7%BB%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>计算 next 数组</h3>
<p>首选考虑找一找有没有递推的方式，效率高一些。初始值是 \(next(1)=0\)。</p>
<p>在计算 \(next(i)\) 时，假定 \(next(1 \ldots i-1)\) 都已经计算完毕。</p>
<p>\(next(i)\) 可能是哪些值？从最极端最大的来看，就是 \(i\)，但是显然定义不允许。那就只能缩一点了，很容易想到 \(next(i-1)+1\) 必然是一个可能的结果。有没有更大的呢？如果有更大的，那么 \(next(i)\) 的前、后字符串各砍最后一个字符就变成 \(next(i-1)\) 的前、后字符串了，导致 \(next(i-1)\) 不是最大，矛盾。因此 \(next(i)\) 的最大可能值即为 \(next(i-1)+1\)。（I）</p>
<p>但是如果它不太行——即最后一个字符无法对应——那就要找一找有没有替代方案了。与上面类似，继续缩小范围，考虑到前、后字符串完全相同，相同长度的前后缀也相同，那么进一步缩小到 \(next(next(i-1))+1\) 就行了。同样可以反证这是除了 \(next(i-1)+1\) 以外最大的。（II）</p>
<p>进一步整理，得出如下的算法框架：</p>
<ol>
<li>\(next(1) \gets 0, j\gets 0\)</li>
<li>对于每个 \(i\)，检查 \(A_{j+1}\) 是否等于 \(A_i\)：
<ol>
<li>如果是，\(j \gets j + 1\)，且 \(next(i) \gets j\)（对应上文步骤 I）；</li>
<li>如果不是，\(j \gets next(j)\)，重复直到 \(j=0\)，则 \(next(i) \gets 0\)（对应上文步骤 II）。</li>
</ol>
</li>
</ol>
<p>上面酸的非常重要的点就是一轮循环完以后，\(j\) 的值等于 \(next(i-1)\)，这有助于下一轮循环的计算。</p>
<h3><a id="%E8%AE%A1%E7%AE%97f%E6%95%B0%E7%BB%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>计算 f 数组</h3>
<p>完全一样，计算 \(f(i)\) 时最大的可能就是 \(f(i-1)+1\)，否则就缩到 \(next(f(i-1))+1\)。</p>
<p>注意，\(f\) 数组允许 \(f(i)=i\) 的情况发生，因此 \(f(1)\gets 1\) 即可。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p><tc><c>LG3375</c></tc></p>
<pre class="line-numbers"><code class="language-cpp">char a[1000001], b[1000001];
int next[1000001];

int main() {
    scanf(&quot;%s\n%s&quot;, b + 1, a + 1);
    const int A = strlen(a + 1), B = strlen(b + 1);

    next[1] = 0;
    for (int i = 2, j = 0; i &lt;= A; ++i) {
        while (a[j + 1] != a[i] &amp;&amp; j &gt; 0)
            j = next[j];
        if (a[j + 1] == a[i]) ++j;
        next[i] = j;
    }
    for (int i = 2, j = 1; i &lt;= B; ++i) {
        while (a[j + 1] != b[i] &amp;&amp; j &gt; 0)
            j = next[j];
        if (a[j + 1] == b[i]) ++j;
        if (j == A)
            printf(&quot;%d\n&quot;, i - A + 1);
    }
    for (int i = 1; i &lt;= A; printf(&quot;%d&quot;, next[i]), putchar(&quot; \n&quot;[i == A]), ++i);
    return 0;
}
</code></pre>
<hr />
<h2><a id="period" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Period</h2>
<p><tc><c>0x1501</c><h>Hard</h><t>KMP</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>问题 1：对于一个长度为 \(len\) 的字符串 \(a\)，什么样的 \(d\) 可以成为它的某个循环元长度？</p>
<p>需要满足如下要求：</p>
<ul>
<li>\(d \mid len\)（显然）；</li>
<li>\(a_{1 \ldots len - d} = a_{d + 1 \ldots i}\)。</li>
</ul>
<pre class="line-numbers"><code class="language-plain_text">     DBJDBJDBJ
s_1: ^^^^^^
     DBJDBJDBJ
s_2:    ^^^^^^

len = 9, d = 3
</code></pre>
<p>下面证明第二条的充分性。令 \(s_1=a_{1 \ldots len - d},s_2= a_{d + 1 \ldots i}\)。</p>
<p>显然，当 \(s_1=s_2\) 时，\(s_1\) 的前 \(d\) 位和 \(s_2\) 的前 \(d\) 位是相同的。由于 \(s_1,s_2\) 是从同一字符串中截取出来的，这也就代表着 \(s_1\) 的第二个 \(d\) 位（\(d+1 \ldots 2d\)）与 \(s_2\) 的前 \(d\) 位相同。又因为 \(s_1=s_2\)，所以 \(s_1\) 的第二个 \(d\) 位和 \(s_2\) 的第二个 \(d\) 位相同……以此类推，\(s_1\)、\(s_2\) 每 \(d\) 位都相同，结束。</p>
<pre class="line-numbers"><code class="language-plain_text">     DBJDBJDBJ
s_1: ---±±±
     DBJDBJDBJ
s_2:    ---+++
</code></pre>
<p>这代表着可以只用管首、尾，再加上一个整除就行。联想到 KMP 算法中 \(next\) 数组也是只用管首尾的。<strong>\(s_1, s_2\) 可以分别对应原本的字符串的 \(next\) 值的一个候选项的「前、后字符串」</strong>。</p>
<p>如果 \(g\) 是原字符串 \(next\) 值的某个候选项，并且 \(len-g \mid len\)，那么 \(g\) 就是原字符串的一个循环元的长度。最大的 \(g\) 就是最大循环元的长度。</p>
<p>事实上，要么没有这样的 \(g\)，要么 \(g=next(len)\)。我不会严格证明，但举个例子：</p>
<pre class="line-numbers"><code class="language-plain_text">ABCDEABCDEABCDE
^^^^^^^^^^
-----------
ABCDEABCDEABCDE
     ^^^^^^^^^^
</code></pre>
<p>对于上面这个 \(len=15, g_{\max}=10\) 的例子，我们假设 \(g_{\max} \neq next(len)\)，那么一定找得出大于 \(10\) 的 \(next\) 候选项存在。显然你是找不到的，因为下面的 \(s_2\) 的开头的那个 <code>A</code> 就是第二个 <code>A</code>。假设循环节中出现了 <code>A</code> 也没用，如果真的能做到前后字符串相等的话那么它早就是最大的 \(g\) 了。（感性理解）</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int T, n;
char s[1000001];
int next[1000001];

int main() {
    scanf(&quot;%d&quot;, &amp;T);
    for (int i = 1; i &lt;= T; ++i) {
        printf(&quot;Test case #%d\n&quot;, i);
        scanf(&quot;%d\n%s&quot;, &amp;n, s + 1);
        next[1] = 0;
        for (int i = 2, j = 0; i &lt;= n; ++i) {
            while (j &amp;&amp; s[j + 1] != s[i]) j = next[j];
            if (s[i] == s[j + 1]) ++j;
            next[i] = j;
        }
        for (int i = 2; i &lt;= n; ++i)
            if (i % (i - next[i]) == 0 &amp;&amp; i / (i - next[i]) &gt; 1)
                printf(&quot;%d %d\n&quot;, i, i / (i - next[i]));
        putchar('\n');
    }
    return 0;
}
</code></pre>
<hr />
<h2><a id="%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>最小表示法</h2>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<pre class="line-numbers"><code class="language-plain">S = bacacabc, i = 2, j = 4, k = 3
  i     i+k 
  = = = &gt;
b[a c a c a b c b a]c a c a b c
      j     j+k
      = = = &lt;
b a c[a c a b c b a c a]c a b c
</code></pre>
<p>首先复制一遍，然后开始比较 \(1\ldots n\) 与 \(2 \ldots n+1\)。如果其中的一个比另一个大，就代表这个<br />
显然不是最小表示法，同时感性理解，还有一长串会被否定（如上图中 \(i\) 到 \(i+k\) 开头的字符串都不可能是最小表示法）。然后就可以 \(i\) 和 \(j\) 两个指针来回跳来跳去。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p><tc><c>LG1368</c></tc></p>
<pre class="line-numbers"><code class="language-cpp">int main() {
    n = read();
    for (int i = 1; i &lt;= n; ++i) s[i] = read();
    for (int i = n + 1; i &lt;= n &lt;&lt; 1; i++)
        s[i] = s[i - n];
    int i = 1, j = 2, k;
    while (i &lt;= n &amp;&amp; j &lt;= n) {
        k = 0;
        while (s[i + k] == s[j + k] &amp;&amp; k &lt; n) ++k;
        if (k == n) break;
        if (s[i + k] &gt; s[j + k]) {
            i = i + k + 1;
            if (i == j) ++i;
        } else {
            j = j + k + 1;
            if (i == j) ++j;
        }
    }
    for (int d = std::min(i, j); d &lt; std::min(i, j) + n; ++d)
        printf(&quot;%d &quot;, s[d]);
    putchar('\n');
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RingtoneHY V2 项目详解]]></title>
    <link href="oi.afobject.ml/16549586469772.html"/>
    <updated>2022-06-11T22:44:06+08:00</updated>
    <id>oi.afobject.ml/16549586469772.html</id>
    <content type="html"><![CDATA[
<h2><a id="1%E5%89%8D%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1 前言</h2>
<p>RingtoneHY V2 项目开源在 GitHub 仓库： <a href="https://github.com/AFObject/RingtoneHY">AFObject/RingtoneHY</a>，前身是 2020 年疫情期间的初版，在 2022 年网课期间进行了完全重构，是一款 macOS 原生 App，用于在网课期间提供模拟校园铃声的功能。</p>
<p>前有 C+++ 对抗 ClickIDE，后有 RingtoneHY 对抗 HYRing，好啊！!1</p>
<p>本项目的开发经历了一个完整的流程，在本文中进行详细的阐述。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h34osrcyi4j21by0qqq79.jpg" alt="" /><br />
（图 1.1 社团课演示文稿截图）</p>
<p>因为是小程序，整个的开发路子基本都是按照我之前总结的这个来，没有大的改动。</p>
<hr />
<h2><a id="2%E7%AB%8B%E9%A1%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2 立项</h2>
<p>究其原因是：</p>
<ol>
<li>班主任及多名任课教师在晨会 / 课上提到相关内容；</li>
<li>懒得在 iPad 上设闹钟；</li>
<li>秀 / 锻炼一下自己的码力。</li>
</ol>
<p>有了 20 年 V1 版本的经验，在开发之前将本次开发的主要内容确定为：</p>
<ul>
<li>增强 UI 界面的美观性、易用性；</li>
<li>动态编辑铃声的功能；</li>
<li>在实现功能的同时试试看简化、优化代码，至少让我自己满意。</li>
</ul>
<hr />
<h2><a id="3%E6%A8%A1%E5%9E%8B%E6%90%AD%E5%BB%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3 模型搭建</h2>
<blockquote>
<p>Code: <a href="https://github.com/AFObject/RingtoneHY/blob/main/RingtoneHY/TaskStorage.swift">RingtoneHY/TaskStorage.swift</a></p>
<p>Reference:</p>
<ol>
<li><a href="https://stackoverflow.com/questions/24217586/structure-vs-class-in-swift-language">StackOverflow 24217586</a></li>
</ol>
</blockquote>
<h3><a id="3-1%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%B4%E6%8A%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.1 模型的基本维护</h3>
<p>因为早就想好了，上来就直接写数据结构。</p>
<p>我们在这个 App 里需要维护的是什么？（一个<strong>星期</strong>中）【（每一<strong>天</strong>的）【（每一节<strong>课 / 任务</strong>的）【（开始、结束<strong>时间</strong>的）【时、分、秒和铃声】】】】。</p>
<p>上面这一句话的排版有点乱，但已经很明确了——对于每个加粗的部分，都写一个结构体来保存数据。</p>
<pre class="line-numbers"><code class="language-swift">struct Time { // 一个响铃时间点
    var hour: Int
    var minute: Int
    var music: Int
}
struct Task { // 一天
    var start: Time
    var end: Time
    var name: String
}
struct TaskList { // 一天的任务列表
    var tasks: [Task]
}
struct TaskStorage { // 一周七天，七个任务列表的集合
    var lists: [TaskList]
}
</code></pre>
<p>这是整个 <code>TaskStorage.swift</code> 150 行的精髓。接下来就要考虑的是细枝末节的东西：如何将数据变成系统可读的格式保存在本地？如何快速地新建一个结构体？如何配置默认日程表？……</p>
<ul>
<li>Q1：如何将数据变成系统可读的格式保存在本地？</li>
<li>A1：对于每个结构体，使其遵守 <code>Codable</code> 协议。使用 <code>JSONEncoder</code> / <code>JSONDecoder</code> 来解 / 编码数据。最后写几个方便操作的结构体内函数。</li>
</ul>
<pre class="line-numbers"><code class="language-swift">var data: Data {
    return try! JSONEncoder().encode(self)
}
    
static func from(data: Data?) -&gt; TaskStorage {
    if let data = data {
        do {
            return try JSONDecoder().decode(TaskStorage.self, from: data)
        } catch {
            print(error)
        }
    }
    return .default
}
</code></pre>
<ul>
<li>Q2：如何快速地新建一个结构体？</li>
<li>A2：在每个结构体内写好方便的构造函数。例如下面这段，输入一个五位数字串，自动转换成一个时间点的结构体。</li>
</ul>
<pre class="line-numbers"><code class="language-swift">init(_ string: String) {
    hour = Int(string.prefix(2)) ?? 0
    minute = Int((string as NSString).substring(with: NSMakeRange(2, 2))) ?? 0
    music = Int(string.suffix(1)) ?? 0
}
</code></pre>
<ul>
<li>Q3：如何配置默认日程表？</li>
<li>A3：在 <code>TaskStorage</code> 内写一个常量即可。例如：</li>
</ul>
<pre class="line-numbers"><code class="language-swift">static var `default`: TaskStorage {
    let ver1 = TaskList(tasks: [
        Task(&quot;07401&quot;, &quot;07450&quot;, &quot; 点名 &quot;),
        Task(&quot;08001&quot;, &quot;08402&quot;, &quot; 第 1 节课 &quot;), // trimmed
        Task(&quot;16051&quot;, &quot;16452&quot;, &quot; 第 9 节课 &quot;)
    ])
    let ver2 = TaskList(tasks: [
        Task(&quot;07401&quot;, &quot;07450&quot;, &quot; 点名 &quot;),
        Task(&quot;08001&quot;, &quot;08402&quot;, &quot; 第 1 节课 &quot;), // trimmed
        Task(&quot;15451&quot;, &quot;16252&quot;, &quot; 第 9 节课 &quot;)
    ])
    return TaskStorage(lists: [.empty, .empty, ver1, ver1, ver1, ver1, ver2, .empty])
}
</code></pre>
<h3><a id="3-2%E9%87%8D%E4%B8%AD%E4%B9%8B%E9%87%8D%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.2 重中之重：为什么不用面向对象？</h3>
<p>注意我在上文中自始至终贯穿了「结构体」一词。为什么我不把 <code>struct</code> 换成 <code>class</code>？</p>
<p>温习一遍：<code>struct</code> 是值，而 <code>class</code> 是引用。</p>
<blockquote>
<p>When you make a copy of a value type, it copies all the data from the thing you are copying into the new variable. They are 2 separate things and changing one does not affect the other. [1]</p>
</blockquote>
<p>我要维护的东西，再简单不过，就是几个时间点罢了。请问这些时间点何德何能逼着我去用引用类型来维护它？想象一下，我要把周二的课程表拷贝到周一的课程表上面去，我所希望的，仅是它们两个是值相同的不同的两个结构体，而不是什么别的。</p>
<p>用一个形象的比喻：Class 是活物，它可以灵活变通，有生有死也有变化；Struct 是死物，它只能长那样，我虽然可以改变它的值，但它永远只包含这些值，没有生命。可不希望这些课程表亦或是时间点的结构体变成活的，然后在运行的时候跳出来干些预料之外的事情！</p>
<hr />
<h2><a id="4%E4%B8%BB%E7%95%8C%E9%9D%A2%E4%B8%8E%E9%93%83%E5%A3%B0%E6%8A%A5%E6%97%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4 主界面与铃声报时</h2>
<blockquote>
<p>Code: <a href="https://github.com/AFObject/RingtoneHY/blob/main/RingtoneHY/ViewController.swift">RingtoneHY/ViewController.swift</a></p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h34r8cr0bbj20g20buaam.jpg" alt="" /></p>
<p>这是整个 App 的核心功能，也是最简单最易实现的，因为有去年的基础。</p>
<p>当然得有 ViewController（这回用了系统的 Visual Effect 模糊背景），还得有 Storyboard。</p>
<p>算法：每天开始运行时，或是更改设置时，从保存的日程表中拉取数据，把所有的时间节点排好序放进一个队列里，每 2 秒（<code>Timer</code>）获取一次系统时间（可以自己写一些东西方便实现），到时间了就响铃（<code>AVFoundation</code> 库），并把队首弹出。</p>
<pre class="line-numbers"><code class="language-swift">let timer = Timer(timeInterval: 2.0, target: self, selector: #selector(updateTime), userInfo: nil, repeats: true)
RunLoop.current.add(timer, forMode: .default)
</code></pre>
<pre class="line-numbers"><code class="language-swift">private var queue: [(Time, String, Bool)] = []
private func initializeQueue() {
    storedWeekday = DateManager.weekday
    let list = TaskStorage.shared.lists[DateManager.weekday]
    queue = []
    for i in list.tasks {
        if i.start.music &gt; 0 &amp;&amp; i.start &gt; .now {
            queue.append((i.start, i.name, true))
        }
        if i.end.music &gt; 0 &amp;&amp; i.end &gt; .now {
            queue.append((i.end, i.name, false))
        }
    }
    queue.sort(by: { lhs, rhs in
        lhs.0 &lt; rhs.0
    })
}
</code></pre>
<pre class="line-numbers"><code class="language-swift">@objc func updateTime() {
    dateLabel.stringValue = &quot;\(DateManager.month) 月 \(DateManager.day) 日 / 周 \(String.weekdayName(of: DateManager.weekday))&quot;
    timeLabel.stringValue = Time.now.timeString
    
    if DateManager.weekday != storedWeekday {
        initializeQueue()
    }
    
    while queue.count &gt; 0 &amp;&amp; queue.first!.0 &lt; .now {
        queue.removeFirst()
    }
    if let current = queue.first {
        if Time.timeEqual(current.0, .now) {
            AVAudioPlayer.ring(type: current.0.music)
            queue.removeFirst()
        }
    }
    if let current = queue.first {
        taskLabel.stringValue = &quot;下一项：\(current.0.timeString) \(current.1)\(current.2 ? &quot;开始&quot; : &quot;结束&quot;)&quot;
    } else {
        taskLabel.stringValue = &quot;今日无其他日程&quot;
    }
}
</code></pre>
<hr />
<h2><a id="5%E8%AE%BE%E7%BD%AE%E7%95%8C%E9%9D%A2%EF%BC%9A-swiftui%E7%9A%84%E6%AD%A3%E7%89%87%E5%BC%80%E5%A7%8B%EF%BC%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>5 设置界面：SwiftUI 的正片开始！</h2>
<p>设置界面，狗都不用 <code>AppKit</code> 中的控件！从现在开始，使用 SwiftUI。</p>
<blockquote>
<p>Code:</p>
<ul>
<li><a href="https://github.com/AFObject/RingtoneHY/blob/main/RingtoneHY/ViewController.swift">RingtoneHY/ViewController.swift</a></li>
<li><a href="https://github.com/AFObject/RingtoneHY/blob/main/RingtoneHY/TaskListView.swift">RingtoneHY/TaskListView.swift</a></li>
<li><a href="https://github.com/AFObject/RingtoneHY/blob/main/RingtoneHY/SettingsView.swifts">RingtoneHY/SettingsView.swift</a></li>
</ul>
</blockquote>
<h3><a id="5-1-appkit%E4%B8%8E-swiftui%E7%9A%84%E8%A1%94%E6%8E%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>5.1 AppKit 与 SwiftUI 的衔接</h3>
<p>老样子，用 <code>NSHostingController</code>。保存设置后让设置界面消失是当时的一个难点，这种问题直接在更高一层的 <code>ViewController</code> 中宏观控制就行了（否则为啥叫它 <code>Controller</code>）。</p>
<pre class="line-numbers"><code class="language-swift">@IBAction func showSettings(_ sender: Any?) {
    settingsController = NSHostingController(rootView: SettingsView(onCompletion: {
        self.settingsController?.dismiss(nil)
        self.initializeQueue()
    }))
    self.presentAsSheet(settingsController!)
}  
</code></pre>
<h3><a id="5-2-swiftui%E7%95%8C%E9%9D%A2%E7%BB%93%E6%9E%84%E7%9A%84%E6%90%AD%E5%BB%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>5.2 SwiftUI 界面结构的搭建</h3>
<p>老样子，你之前数据结构部分怎么套娃，现在也怎么套。接下来贴出的代码都是核心省略版。</p>
<pre class="line-numbers"><code class="language-swift">import SwiftUI

struct SettingsView: View {
    var onCompletion: () -&gt; () = {} // 配合 5.1 中的衔接部分
    @State private var taskStorage: TaskStorage = .default
    
    var body: some View {
        VStack {
            ScrollView {
                Form {
                    ForEach(1...7, id: \.self) { i in
                        Section {
                            Text(verbatim: &quot;周&quot; + .weekdayName(of: i))
                                .font(.title)
                            TaskListView(taskList: $taskStorage.lists[i]) // 套娃！
                        }
                        Divider()
                    }
                }.padding()
            }.frame(width: 540, height: 360)
                .onAppear {
                    taskStorage = .shared
                }
                .onChange(of: taskStorage) { newValue in
                    UserDefaults.standard.set(taskStorage.data, forKey: .storageKey)
                } // 重要！保存数据至本地。
        }
    }
}
</code></pre>
<pre class="line-numbers"><code class="language-swift">import SwiftUI

struct TaskView: View {
    @Binding var task: Task
    var body: some View {
        VStack(alignment: .leading) { // ... trimmed
        }.sheet(isPresented: $editing) { // 套娃！
                TaskEditView(task: $task)
            }
    }
}

struct TimeEditView: View { // 底层套娃
    var label: String
    @Binding var time: Time
    var body: some View {
        HStack {
            DatePicker(label, selection:
                Binding(get: {
                    Calendar.current.date(from: DateComponents(hour: time.hour, minute: time.minute))!
                }, set: { date in
                    let components = Calendar.current.dateComponents([.hour, .minute], from: date)
                    time.hour = components.hour!
                    time.minute = components.minute!
                }), displayedComponents: .hourAndMinute
            ) // DatePicker 编辑时间
            Picker(&quot;铃声&quot;, selection: $time.music) {
                ForEach(0...3, id: \.self) { i in
                    Text(verbatim: .audioName(of: i)).tag(i)
                }
            } // 普通 Picker 编辑铃声
        }
    }
}

struct TaskEditView: View {
    @Binding var task: Task
    @Environment(\.presentationMode) var presentationMode
    var body: some View {
        VStack {
            TextField(&quot;任务名称&quot;, text: $task.name)
            TimeEditView(label: &quot;起始时间&quot;, time: $task.start) // 套娃！
            TimeEditView(label: &quot;结束时间&quot;, time: $task.end) // 套娃！
            Spacer()
            HStack {
                Spacer()
                Button(&quot;完成&quot;) {
                    presentationMode.wrappedValue.dismiss()
                }
            }
        }.frame(width: 300, height: 120).padding()
    }
}

struct TaskListView: View, TaskViewManager {
    @Binding var taskList: TaskList
    @State private var newTask: Task = Task(&quot;08001&quot;, &quot;08402&quot;, &quot;新任务&quot;)
    @State private var editing = false
    
    let rows = Array(repeating: GridItem(), count: 3)
    var body: some View {
        LazyVGrid(columns: rows) {
            ForEach($taskList.tasks) { i in
                TaskView(task: i, manager: self) // 套娃！
            }
            Button(action: addItem) // ... trimmed
        }.frame(width: 500, alignment: .leading)
            .sheet(isPresented: $editing, onDismiss: {
                taskList.tasks.append(newTask)
                newTask = Task(&quot;08001&quot;, &quot;08402&quot;, &quot; 新任务 &quot;)
            }) {
                TaskEditView(task: $newTask) // 新建任务时的套娃！
            }
    }
    
    func addItem() {
        editing = true
    }
}
</code></pre>
<p>以上的代码即可完成编辑界面的 UI 基本功能。可以看出，SwiftUI 的一大特点就是通过套娃来节省代码量（别的地方也挺常见的），你只需要良好地完成单一界面的一个功能，并设置一个接口（例如支持同步修改的 <code>@Binding var ...</code>）就可以在别的任意地方调用它。</p>
<p>被省略的代码中还有一部分实现了任务的删除操作。与添加操作不同的是，任务的删除操作是针对单个任务的，它的按钮也放在单个任务的显示控件内。所以我另外写了一个协议（<code>TaskManager</code>），让它可以通知它的 Superview（不知表述是否准确）来控制它。一样的思路，还是想方设法把控制权交给上一级试图。</p>
<p>此外，SwiftUI 中的 <code>onChange(of:perform:)</code> 也是相当重要的一个功能。因为前文中我们使用了结构体，所以就可以放心大胆的使用它了，只要值有修改，立刻就会触发它！</p>
<hr />
<h2><a id="6%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%8F%91%E5%B8%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>6 测试与发布</h2>
<p>本项目的功能主体开发用时 3 天左右，测试与发布前准备用时也是 3 天左右，也可见其重要性。</p>
<p>首先就是自己个人的使用了。用了一天，主要是两个问题：一个是不断需要鼠标去点才能看到时间，所以我补了自动置顶的功能；还有一个是长的音频不能自动停止，所以我补了点击窗口停止铃声的功能。</p>
<p>在完成全部功能并在本机（macOS 12 Monterey）上测试完运行良好后，我修改了部分代码使其支持 macOS 11 Big Sur（这时还跳了坑，有些 SwiftUI 的东西在两个平台上实现得完全不一样），并在家里的旧电脑上测试成功。这个时候才能不动代码，开始发布前期的准备工作。</p>
<p>发布前的准备工作主要有两项：一是 App Icon 的设计；二是用户手册的编写与打包。</p>
<p>前者，在 Apple Developer 官网上就可以得到设计资源与设计建议。去年的图标我是网上嫖的，这次我照着去年的样子，自己用 PS 重新画了一遍，添加了阴影等细节，算是半个原创吧（笑）。至于用户手册的编写，用尽量书面化的语言、尽量完备地讲全软件的使用方式和 FAQ 即可，我选择了用 LaTeX 编辑。</p>
<p>耗时一共一个礼拜不到，显然算是极小的项目；但积累的经验应该是不少的。最终发布也没有引起什么波澜，方便了自己和一小部分人。</p>
<hr />
<h2><a id="7%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>7 总结</h2>
<p>本文写于 6 月 11 日至 12 日凌晨，感谢 macOS 13 的台前调度能让我专注地赶在 nth 之前写完这个东西（不是）。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h34r26jx6ij21c00u0ahl.jpg" alt="" /></p>
<p>用上我之前复活纪念的那篇文章的话，这可能是我第一个从头到尾自己做的、良好运行的 App，即使简单但很有意义。不过这大概也是初中能写的最后一个小项目了，之后也没什么时间，希望能记住这次开发带来的宝贵经验吧。</p>
<p>如果全文含有表述不准确或者明显错误的内容，请务必指出！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x14 Hash]]></title>
    <link href="oi.afobject.ml/0x14-.html"/>
    <updated>2022-06-10T22:13:57+08:00</updated>
    <id>oi.afobject.ml/0x14-.html</id>
    <content type="html"><![CDATA[
<h2><a id="snowflake-snow-snowflakes" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Snowflake Snow Snowflakes</h2>
<p><tc><c>0x1401</c><e>Easy+</e><t>Hash</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>我们目标的 Hash 函数要满足：</p>
<ul>
<li>对于每个数是平等的；</li>
<li>能尽量区分出不同的雪花。</li>
</ul>
<p>因此可以构造出 Hash 函数 \(H(a_{i,1},a_{i,2},\ldots,a_{i,6})=(\sum_{j=1}^6a_{i,j}+\prod_{j=1}^6a_{i,j}) \bmod P\)。</p>
<p>对于每一个 Hash 值，期望的项目数是 \(\dfrac N P\)。每个块内比一比，最终的时间复杂度是 \(P \cdot \left(\dfrac N P\right)^2= \dfrac{N^2}P\)）。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>Hash 的实现注意：</p>
<ul>
<li>当 Hash 值计算过程中可能超过 <code>int</code> 范围（如乘积等）时，先转一下 <code>long long</code>；</li>
<li>能不开新空间就不开新空间，少用指针（适用所有题目）。</li>
</ul>
<pre class="line-numbers"><code class="language-cpp">#define P 99991

int n;

struct Snowflake {
    int a[6];
    int hashValue() {
        int sum = 0, prod = 1;
        for (int i = 0; i &lt; 6; ++i) 
            sum = (sum + a[i]) % P, prod = ((long long)prod * a[i]) % P;
        return (sum + prod) % P;
    }
    bool operator == (const Snowflake&amp; other) const {
        for (int s = 0; s &lt; 6; ++s) {
            bool flag = true;
            for (int i = 0; i &lt; 6; ++i)
                if (a[(s + i) % 6] != other.a[i])
                    flag = false;
            if (flag) return true;
            flag = true;
            for (int i = 0; i &lt; 6; ++i)
                if (a[(s + i) % 6] != other.a[5 - i])
                    flag = false;
            if (flag) return true;
        }
        return false;
    }
};

std::vector&lt;Snowflake&gt; v[100001];

int main() {
    n = read();
    while (n--) {
        Snowflake t;
        for (int i = 0; i &lt; 6; ++i)
            t.a[i] = read() % P;
        const int val = t.hashValue();
        for (auto x : v[val])
            if (x == t)
                return puts(&quot;Twin snowflakes found.&quot;), 0;
        v[val].push_back(t);
    }
    return puts(&quot;No two snowflakes are alike.&quot;), 0;
}
</code></pre>
<hr />
<h2><a id="%E5%85%94%E5%AD%90%E4%B8%8E%E5%85%94%E5%AD%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>兔子与兔子</h2>
<p><tc><c>0x1402</c><e>Easy</e><t>Hash</t><t>字符串</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>书上讲的非常详细。例如串 <code>abcxyz</code>，在 27 进制下将它表示为 <code>1 2 3 24 25 26</code>。想要取出 <code>bcx</code> 的哈希值，则用 <code>abcx</code> 的哈希值减去 <code>a000</code> 的哈希值。其中 <code>a000</code> 代表 <code>a</code> 的哈希值在 27 进制下左移 3 位。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">char s[1000001];
unsigned long long x[1000001], p[1000001];

#define B 131

int main() {
    scanf(&quot;%s&quot;, s + 1);
    const int len = strlen(s + 1);
    p[0] = 1;
    for (int i = 1; i &lt;= len; ++i) {
        x[i] = x[i - 1] * B + s[i];
        p[i] = p[i - 1] * B;
    }
    int q = read();
    while (q--) {
        int l1 = read(), r1 = read(), l2 = read(), r2 = read();
        const auto h1 = x[r1] - x[l1 - 1] * p[r1 - l1 + 1];
        const auto h2 = x[r2] - x[l2 - 1] * p[r2 - l2 + 1];
        puts(h1 == h2 ? &quot;Yes&quot; : &quot;No&quot;);
    }
    return 0;
}
</code></pre>
<hr />
<h2><a id="palindrome" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Palindrome</h2>
<p><tc><c>0x1403</c><m>Medium-</m><t>Hash</t><t>字符串</t><t>二分</t></tc></p>
<p>Manacher 模版，但是数据范围 \(10^6\)。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>一眼二分 + 正 / 反向哈希。</p>
<p>但这只是宏观描述，还是有比较多的细节。</p>
<ol>
<li>
<p>二分什么？从哪里开始二分？</p>
<p>应该对于每一个回文串可能的中点，在两边二分出最远的回文串的左右端点。注意，这个中点可能是夹在字符中间的。</p>
</li>
<li>
<p>二分的边界范围</p>
<p>应当为 \([0,\text{maxLength}]\)。注意一定要取 0，这样方便判断不存在回文串的情况。</p>
</li>
<li>
<p>反向哈希</p>
<p>若要求 \([l,r]\) 的反向哈希值，则答案为 \(b(l)-b(r+1)\cdot B^{r-l+1}\)，与正向的恰好相反。</p>
</li>
</ol>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>我在实现中用了 <code>std::string</code>，下次不要这样捏！尽量下标从 1 开始方便自己，否则在预处理哈希值的时候碰到数组越界很麻烦。</p>
<pre class="line-numbers"><code class="language-cpp">
std::string s;
unsigned long long f[1000003], b[1000003], p[1000003];

#define B 31

unsigned long long getFront(int l, int r) {
    if (l) return f[r] - f[l - 1] * p[r - l + 1];
    else return f[r];
}

unsigned long long getBack(int l, int r) {
    return b[l] - b[r + 1] * p[r - l + 1];
}

int main() {
    int t = 0;
    while (true) {
        std::cin &gt;&gt; s;
        if (s == &quot;END&quot;) break;
        ++t; std::cout &lt;&lt; &quot;Case &quot; &lt;&lt; t &lt;&lt; &quot;: &quot;;
        const int len = s.length();
        for (int i = 0; i &lt; len; i++)
            f[i] = (s[i] - 'a') + (i ? f[i - 1] * B : 0),
            b[len - i - 1] = (s[len - i - 1] - 'a') + b[len - i] * B,
            p[i] = i ? p[i - 1] * B : 1;
        int ans = 0;
        
        for (int i = 0; i &lt; len; ++i) {
            int l = 0, r = std::min(i, len - i - 1);
            while (l &lt; r) {
                const int mid = (l + r + 1) &gt;&gt; 1;
                if (getFront(i - mid, i) == getBack(i, i + mid))
                    l = mid;
                else
                    r = mid - 1;
            }
            ans = std::max(ans, (l &lt;&lt; 1) + 1);
        }
        for (int i = 1; i &lt; len; ++i) {
            int l = 0, r = std::min(i, len - i);
            while (l &lt; r) {
                const int mid = (l + r + 1) &gt;&gt; 1;
                if (getFront(i - mid, i - 1) == getBack(i, i + mid - 1))
                    l = mid;
                else
                    r = mid - 1;
            }
            ans = std::max(ans, l &lt;&lt; 1);
        }
        std::cout &lt;&lt; ans &lt;&lt; std::endl;
    }
}
</code></pre>
<hr />
<h2><a id="%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%EF%BC%88%E5%BC%B1%E5%8C%96%E7%89%88%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>后缀数组（弱化版）</h2>
<p><tc><c>0x1404</c><m>Medium-</m><t>Hash</t><t>字符串</t><t>二分</t></tc></p>
<p>后缀排序模版，但是 \(n \le 3\times10^5\)。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>其实是字符串 Hash 的综合。看看我们现有的知识对所求的两问分别有什么帮助。</p>
<ol>
<li>对于 Height 数组，似乎可以拿与上一题类似的二分来做，也比较好写。</li>
<li>对于 SA 的排序，无非就是用常规的 <code>std::sort</code> / 手写快排，归并排序，或者是用一些别的奇妙方法。当我们比较两个前缀的时候，常规做法应该是逐个字符比较；但已经可以实现 Height 了，要什么暴力！直接拿 Height 找出第一个不同的位置即可。把这些东西套在一个 <code>comp</code> 里，用 <code>std::sort</code>  排序。</li>
</ol>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>上面几题踩过坑，这次快很多。</p>
<pre class="line-numbers"><code class="language-cpp">char s[3000003];
int n;
unsigned long long x[3000003], p[3000003];

#define B 31

int getHash(int l, int r) {
    return x[r] - x[l - 1] * p[r - l + 1];
}

int height(int a, int b) {
    int l = 0, r = std::min(n - b + 1, n - a + 1);
    while (l &lt; r) {
        const int mid = (l + r + 1) &gt;&gt; 1;
        if (getHash(a, a + mid - 1) == getHash(b, b + mid - 1))
            l = mid;
        else
            r = mid - 1;
    }
    return l;
}

bool comp(int a, int b) {
    const int h = height(a, b);
    return s[a + h] &lt; s[b + h];
}

int sa[3000003];

int main() {
    scanf(&quot;%s&quot;, s + 1);
    n = strlen(s + 1);
    p[0] = 1;
    for (int i = 1; i &lt;= n; ++i) {
        x[i] = x[i - 1] * B + s[i] - 'a';
        p[i] = p[i - 1] * B;
        sa[i] = i;
    }
    std::sort(sa + 1, sa + n + 1, comp);
    for (int i = 1; i &lt;= n; ++i)
        printf(&quot;%d &quot;, sa[i] - 1);
    printf(&quot;\n0 &quot;);
    for (int i = 2; i &lt;= n; ++i)
        printf(&quot;%d &quot;, height(sa[i - 1], sa[i]));
    putchar('\n');
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ABC254]]></title>
    <link href="oi.afobject.ml/abc254.html"/>
    <updated>2022-06-04T23:26:05+08:00</updated>
    <id>oi.afobject.ml/abc254.html</id>
    <content type="html"><![CDATA[
<p>[6/8] VP</p>
<span id="more"></span><!-- more -->
<h2><a id="d-together-square" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>D Together Square</h2>
<p><tc><m>Medium *1191</m><t>数论</t><t>组合</t><t>筛法</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>两个数都是平方数的话其实是很简单的，但如果两个都不是平方数就有点难搞。一个非平方数所对应的可以让它们的积为完全平方数的另一个数是不唯一的，怎么快速找到它呢？</p>
<p>考虑将所有的数 \(i\) 都除去它们最大的完全平方数因数（\(p_i\)），然后剩下的部分（设为 \(f_i\)）相等的，原数拼在一起就可以得到一个完全平方数。下面考虑的是如何快速的得到 \(f_i\)。由于数据范围不大，可以直接枚举它的因数找到 \(p_i\)。枚举因数用类似埃筛的方法，时间复杂度反正不大。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">#define int long long

int n, sum[200001];
bool g[200001];
std::vector&lt;int&gt; v[200001];

signed main() {
    scanf(&quot;%lld&quot;, &amp;n);
    int ans = 0;
    for (int i = 1; i * i &lt;= n; ++i) g[i * i] = true;
    for (int i = 1; i &lt;= n; ++i)
        for (int j = i; j &lt;= n; j += i)
            v[j].push_back(i);
    for (int i = 1; i &lt;= n; ++i) {
        int f = 1;
        for (int p : v[i])
            if (i % p == 0 &amp;&amp; g[p]) f = std::max(f, p);
        sum[i / f]++;
    }
    for (int i = 1; i &lt;= n; ++i) ans += sum[i] * sum[i];
    printf(&quot;%lld\n&quot;, ans);
}
</code></pre>
<hr />
<h2><a id="e-small-d-and-k" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>E Small d and k</h2>
<p><tc><e>Easy+ *1202</e><t>搜索</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>答案是暴力。</p>
<p>这种最短路问题理应用 BFS 解决，但实际上 DFS 乱搞搞也可以过。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int x, k;
int dis[200001];
std::vector&lt;int&gt; nodes;
void dfs(int x, int t) {
    if (t &gt;= dis[x]) return;
    if (dis[x] &gt; k) nodes.push_back(x);
    dis[x] = t;
    if (t == k) return;
    for (int v : e[x])
        dfs(v, t + 1);
}

int main() {
    n = read(), m = read();
    for (int i = 1; i &lt;= n; ++i) dis[i] = 1e9;
    while (m--) {
        int u = read(), v = read();
        e[u].push_back(v);
        e[v].push_back(u);
    }
    q = read();
    while (q--) {
        x = read(), k = read();
        nodes = std::vector&lt;int&gt;();
        dfs(x, 0);
        long long ans = 0;
        for (int u : nodes) {
            dis[u] = 1e9;
            ans += u;
        }
        printf(&quot;%lld\n&quot;, ans);
    }
    return 0;
}
</code></pre>
<hr />
<h2><a id="f-rectangle-gcd" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>F Rectangle GCD</h2>
<p><tc><m>Medium *1764</m><t>数论</t><t>GCD</t><t>线段树</t><t>DS</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>极其显然地，答案是</p>
\[\gcd\{A_{h_1}+B_{w_1},\underset{i\in(h_1,h_2]}{\left|A_i-A_{i-1}\right|},\underset{i\in(w_1,w_2]}{\left|B_i-B_{i-1}\right|}\}
\]
<p>然后就是查询区间 \(\gcd\)，用线段树或者 ST 表。</p>
<p>为什么感觉 E &lt; F &lt; D……</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>不带修的线段树真好写。注意四倍空间！</p>
<pre class="line-numbers"><code class="language-cpp">#define lt(x) ((x) &lt;&lt; 1)
#define rt(x) (((x) &lt;&lt; 1) + 1)
#define abs(x) ((x) &gt; 0 ? (x) : -(x))

int n, q;
int a[200001], b[200001];
int ca[200001], cb[200001];

int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}

int segA[800001], segB[800001];
void build(int *s1, int *s2, int x, int l, int r) {
    if (l == r) {
        s1[x] = s2[l];
        return;
    }
    const int mid = (l + r) &gt;&gt; 1;
    build(s1, s2, lt(x), l, mid);
    build(s1, s2, rt(x), mid + 1, r);
    s1[x] = gcd(s1[lt(x)], s1[rt(x)]);
}

int query(int *s, int x, int l, int r, int ql, int qr) {
    if (l &gt; r) return 1;
    if (ql &lt;= l &amp;&amp; r &lt;= qr) return s[x];
    const int mid = (l + r) &gt;&gt; 1;
    int res = 0;
    if (ql &lt;= mid) res = gcd(res, query(s, lt(x), l, mid, ql, qr));
    if (qr &gt; mid) res = gcd(res, query(s, rt(x), mid + 1, r, ql, qr));
    return res;
}

int main() {
    n = read(), q = read();
    for (int i = 1; i &lt;= n; ++i) a[i] = read();
    for (int i = 1; i &lt;= n; ++i) b[i] = read();
    for (int i = 1; i &lt;= n; ++i)
        ca[i] = abs(a[i] - a[i - 1]), cb[i] = abs(b[i] - b[i - 1]);
    build(segA, ca, 1, 1, n);
    build(segB, cb, 1, 1, n);
    while (q--) {
        int h1 = read(), h2 = read(), w1 = read(), w2 = read();
        printf(&quot;%d\n&quot;, gcd( gcd(query(segA, 1, 1, n, h1 + 1, h2),
                                query(segB, 1, 1, n, w1 + 1, w2)),
                            a[h1] + b[w1]));
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x13 链表与邻接表]]></title>
    <link href="oi.afobject.ml/0x13-.html"/>
    <updated>2022-06-01T20:12:11+08:00</updated>
    <id>oi.afobject.ml/0x13-.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E5%B0%8F%E7%86%8A%E7%9A%84%E6%9E%9C%E7%AF%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>小熊的果篮</h2>
<p><tc><c>CSP-J 2021</c><e>Easy+</e><t>模拟</t><t>链表</t></tc></p>
<p>普及摆烂没 AK 的痛</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>将块作为链表的一个项目，每一轮进行合并，由于每个水果至多被删一次，所以时间复杂度就是 \(O(n)\) 的。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>有点难整。。。</p>
<p>首先明确一个块内的编号并不是连续的，所以除了维护块之间的顺序外还要再开一个双向链表来维护编号间的前后关系（但这个实现起来用数组即可，比较简单）。考场上写错就是因为这个点。</p>
<p>另外这里的写法中两边的 <code>head</code> 和 <code>tail</code> 是空的，要判一下。</p>
<pre class="line-numbers"><code class="language-cpp">namespace List {
    struct Node {
        int val, type, start;
        Node *prev, *next;
    } v[200001], *head, *tail;
    void init() {
        head = new Node();
        tail = new Node();
        head-&gt;next = tail;
        tail-&gt;prev = head;
    }
    void insert(int val, int type, int start, Node *p) {
        auto r = new Node();
        r-&gt;val = val; r-&gt;type = type; r-&gt;start = start;
        r-&gt;prev = p; r-&gt;next = p-&gt;next;
        p-&gt;next-&gt;prev = r; p-&gt;next = r;
    }
    void remove(Node *p) {
        p-&gt;prev-&gt;next = p-&gt;next;
        p-&gt;next-&gt;prev = p-&gt;prev;
        delete p;
    }
};

int prevN[200001], nextN[200001];

int n;

int main() {
    n = read();
    List::init();
    int prev = 0, count = 0;
    for (int i = 1; i &lt;= n; ++i) {
        if (i != n) nextN[i] = i + 1; prevN[i] = i - 1;
        int a = read();
        if (a != prev) {
            if (i != 1)
                List::insert(count, prev, i - count, List::tail-&gt;prev);
            prev = a;
            count = 0;
        }
        ++count;
    }
    List::insert(count, prev, n + 1 - count, List::tail-&gt;prev);
    while (List::head-&gt;next != List::tail) {
        for (auto x = List::head-&gt;next; x-&gt;next != NULL; x = x-&gt;next)
            printf(&quot;%d &quot;, x-&gt;start);
        putchar('\n');
        for (auto x = List::head-&gt;next; x-&gt;next != NULL; x = x-&gt;next) {
            x-&gt;val--;

            nextN[prevN[x-&gt;start]] = nextN[x-&gt;start];
            prevN[nextN[x-&gt;start]] = prevN[x-&gt;start];
            x-&gt;start = nextN[x-&gt;start];

            if (x-&gt;val == 0)
                List::remove(x);
            else if (x-&gt;prev-&gt;type == x-&gt;type &amp;&amp; x-&gt;prev != List::head)
                x-&gt;prev-&gt;val += x-&gt;val, List::remove(x);
        }
    }
    return 0;
}
</code></pre>
<hr />
<h2><a id="%E9%82%BB%E5%80%BC%E6%9F%A5%E6%89%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>邻值查找</h2>
<p><tc><c>0x1301</c><m>Medium-</m><t>模拟</t><t>链表</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>显然有一步是要从小到大排序并且找出某个数的前驱 / 后继。</p>
<p>一种方法是依次将数有序地插入一个 <code>std::set</code>，并输出这个数的前驱或后缀。</p>
<p>另一种方法则是<strong>倒序</strong>处理，用完一个删一个，用链表维护数据。</p>
<p>本节例题中「Running Median」（0x0503）也可以用这种倒序的思想处理数据（用完一个删一个）。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>还是注意判断队列首、尾预留的空项的问题，赋一个极大的初值即可。</p>
<pre class="line-numbers"><code class="language-cpp">namespace List {
    struct Node {
        std::pair&lt;int, int&gt; val;
        Node *prev, *next;
    } v[200001], *head, *tail;
    void init() {
        head = new Node();
        tail = new Node();
        head-&gt;val.first = -2e9;
        tail-&gt;val.first = 2e9;
        head-&gt;next = tail;
        tail-&gt;prev = head;
    }
    void insert(std::pair&lt;int, int&gt; val, Node *p) {
        auto r = new Node();
        r-&gt;val = val; r-&gt;prev = p; r-&gt;next = p-&gt;next;
        p-&gt;next-&gt;prev = r; p-&gt;next = r;
    }
    void remove(Node *p) {
        p-&gt;prev-&gt;next = p-&gt;next;
        p-&gt;next-&gt;prev = p-&gt;prev;
        delete p;
    }
};

std::pair&lt;int, int&gt; a[200001];
List::Node *b[200001];

int n;
int ansVal[200001], ansIdx[200001];

int main() {
    n = read();
    List::init();
    for (int i = 1; i &lt;= n; ++i) a[i] = {read(), i};
    std::sort(a + 1, a + n + 1);
    for (int i = 1; i &lt;= n; ++i) {
        List::insert(a[i], List::tail-&gt;prev);
        b[a[i].second] = List::tail-&gt;prev;
    }
    for (int i = n; i &gt; 1; --i) {
        int lhs = b[i]-&gt;val.first - b[i]-&gt;prev-&gt;val.first,
            rhs = b[i]-&gt;next-&gt;val.first - b[i]-&gt;val.first;
        ansVal[i] = std::min(lhs, rhs);
        if (lhs &lt;= rhs) ansIdx[i] = b[i]-&gt;prev-&gt;val.second;
        else ansIdx[i] = b[i]-&gt;next-&gt;val.second;
        List::remove(b[i]);
    }
    for (int i = 2; i &lt;= n; ++i)
        printf(&quot;%d %d\n&quot;, ansVal[i], ansIdx[i]);
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x12 队列]]></title>
    <link href="oi.afobject.ml/0x12-.html"/>
    <updated>2022-05-20T22:37:19+08:00</updated>
    <id>oi.afobject.ml/0x12-.html</id>
    <content type="html"><![CDATA[
<h2><a id="team-queue" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Team Queue</h2>
<p><tc><c>0x1201</c><e>Easy</e><t>模拟</t><t>队列</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>开个队列记录下队伍之间的顺序；再对于每个队伍开个队列记录下内部的顺序。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n;
std::map&lt;int, int&gt; m;
std::queue&lt;int&gt; d, q[1001];

int main() {
    int T = 0;
    while (std::cin &gt;&gt; n &amp;&amp; n) {
        ++T;
        std::cout &lt;&lt; &quot;Scenario #&quot; &lt;&lt; T &lt;&lt; '\n';

        m.clear(); d = std::queue&lt;int&gt;();
        for (int i = 1; i &lt;= n; ++i) {
            q[i] = std::queue&lt;int&gt;();
            int t; std::cin &gt;&gt; t;
            while (t--) {
                int g; std::cin &gt;&gt; g;
                m[g] = i;
            }
        }

        std::string s; int op;
        while (std::cin &gt;&gt; s &amp;&amp; s != &quot;STOP&quot;) {
            if (s == &quot;DEQUEUE&quot;) {
                std::cout &lt;&lt; q[d.front()].front() &lt;&lt; '\n';
                q[d.front()].pop();
                if (q[d.front()].empty()) d.pop();
            } else if (s == &quot;ENQUEUE&quot;) {
                std::cin &gt;&gt; op;
                if (q[m[op]].empty()) d.push(m[op]);
                q[m[op]].push(op);
            }
        }
        std::cout &lt;&lt; '\n';
    }
}
</code></pre>
<hr />
<h2><a id="%E8%9A%AF%E8%9A%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>蚯蚓</h2>
<p><tc><c>NOIP2016 D2T2</c><c>0x1202</c><m>Medium+</m><t>数学</t><t>队列</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>时间复杂度的瓶颈像是 \(O(m)\) 的，这也就是要求我们 \(O(1)\) 实现查询最大值、分裂、增长长度这三个操作。</p>
<p>最直接地，可以想到通过大根堆找出最大值，但是顺序不保证，而且太慢了，想要 \(O(1)\) 的话最好使序列有序。接下来就是试图找出单调性。</p>
<p>一次操作，等效于把一个数 \(x\) 分为 \(\lfloor px \rfloor - q\) 和 \(x - \lfloor px \rfloor - q\) 这两个数（实际值是全部数加上 \(\Delta=q\cdot T\)，\(T\) 为当前操作次数）。任何操作都只会让数列中的数变小，所以数列的最大值单调递减，被砍的数单调递减。</p>
<p>可不想让被砍出来的数再放回原队列破坏单调性，所以继续探究被砍出来的数是否存在单调性。注意我们集体减了 \(\Delta\)，计算的时候要还原 \(\Delta\)（\(\Delta\) 为本轮操作前的 \(\Delta\)）。一个数被分为了 \(x_1=\lfloor p(x+\Delta) \rfloor - q - \Delta\) 和 \(x_2=x - \lfloor p(x+\Delta) \rfloor - q\)。假设在这个数后面被分裂的那个数是 \(y\)（\(y \le x\)），那么分出来的就是 \(y_1=\lfloor p(y+\Delta+q) \rfloor - q - \Delta-q\) 和 \(y_2=y - \lfloor p(y+\Delta+q) \rfloor - q\)。</p>
<p>作差：</p>
\[\begin{aligned}
x_1-y_1
&amp;=\lfloor p(x+\Delta) \rfloor-\lfloor p(y+\Delta+q) \rfloor+q\\
&amp;=\lfloor p(x+xq) \rfloor-\lfloor p(y+q) \rfloor&gt;0\\

x_2-y_2
&amp;=x - \lfloor p(x+\Delta) \rfloor - y + \lfloor p(y+\Delta+q) \rfloor\\
&amp;=\lfloor x-p(x)\rfloor-\lfloor y-p(y+q) \rfloor&gt;0
\end{aligned}
\]
<p>也就是说，<strong>砍出来的那两截蚯蚓的长度也随着时间的推移而单调递减</strong>。在所有操作之前先把整个序列排序存进一个队列中，当进行分裂操作时，把大的取出来放进一个队列，把小的取出来放进另一个队列。可以保证这三个队列都是队首大，队尾小，这样就完成了 \(O(1)\) 地求最大值。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">#define int long long
#define top(x) ((x.empty()) ? -1e16 : x.front())

int n, m, q, u, v, t;
int d[100001];
std::queue&lt;int&gt; a, b, c;

signed main() {
    n = read(), m = read(), q = read(), u = read(), v = read(), t = read();
    for (int i = 1; i &lt;= n; ++i) d[i] = read();
    std::sort(d + 1, d + n + 1);
    for (int i = n; i; --i) a.push(d[i]);

    int delta = 0;
    for (int i = 1; i &lt;= m; ++i, delta += q) {
        int a0 = top(a), b0 = top(b), c0 = top(c), max = 0;
        if (a0 &gt;= b0 &amp;&amp; a0 &gt;= c0) max = a0, a.pop();
        else if (b0 &gt;= c0) max = b0, b.pop();
        else max = c0, c.pop();
        if (i % t == 0) printf(&quot;%lld &quot;, max + delta);
        b.push(floor((double)u / v * (max + delta)) - q - delta);
        c.push(max - floor((double)u / v * (max + delta)) - q);
    }
    putchar('\n');
    for (int i = 1; i &lt;= n + m; ++i) {
        int a0 = top(a), b0 = top(b), c0 = top(c), max = 0;
        if (a0 &gt;= b0 &amp;&amp; a0 &gt;= c0) max = a0, a.pop();
        else if (b0 &gt;= c0) max = b0, b.pop();
        else max = c0, c.pop();
        if (i % t == 0) printf(&quot;%lld &quot;, max + delta);
    }

    return 0;
}
</code></pre>
<hr />
<h2><a id="%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>双端队列</h2>
<p><tc><c>BJOI 2011</c><c>0x1203</c><m>Medium+</m><t>贪心</t><t>队列</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>以输入为出发点考虑问题：我不太行，因为他要求是整体有序，很难光通过原始的无序序列找到答案。</p>
<p><strong>以输出为出发点考虑问题</strong>：最终要求排好序，那我就排好序，把排好序的数组分割，每一段对应一个双端队列。每一段中要求数的下标具有<strong>单谷性质</strong>。注意判断重复的数。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>接下来是单谷怎么找的问题，一开始是下降的状态，降不动的时候只能升，升不动的时候就成了一个双端队列（同一个数的下标要么全升要么全降，否则复杂化了）。开两个变量，一个是上升下降的标志，一个是上升 / 下降期的最小 / 最大下标。</p>
<pre class="line-numbers"><code class="language-cpp">int n, a[200001];
std::pair&lt;int, int&gt; p[200001];
std::vector&lt;int&gt; v[200001];

int main() {
    n = read();
    for (int i = 1; i &lt;= n; ++i) {
        p[i].first = read();
        p[i].second = i;
    }
    std::sort(p + 1, p + n + 1);
    int t = 1;
    v[t].push_back(p[1].second);
    for (int i = 2; i &lt;= n; ++i) {
        if (p[i].first != p[i - 1].first)
            v[++t].push_back(p[i].second);
        else v[t].push_back(p[i].second);
    }
    int flag = 0, num = 0, ans = 0;
    for (int i = 1; i &lt;= t; ++i) {
        const int first = v[i][0], last = v[i][v[i].size() - 1];
        if (flag) {
            if (first &lt; num) { ++ans; flag = 0; num = first; }
            else num = last;
        } else {
            if (last &gt; num) { flag = 1; num = last; }
            else num = first;
        }
    }
    printf(&quot;%d\n&quot;, ans);
    return 0;
}
</code></pre>
<hr />
<h2><a id="%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>最大子序和</h2>
<p><tc><c>0x1204</c><e>Easy</e><t>前缀和</t><t>单调队列</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>考虑没有限制的做法：一个是递推一下，一个是前缀和一下。有限制的话感觉前缀和更靠谱，那就试一试。求出前缀和 \(p\) 后，问题转化为找出 \(\max\limits_{i-j &lt; m}\{p_i-p_j\}\)。</p>
<p>考虑用单调队列求解。用滑动窗口求出当前点之前的 \(m\) 个前缀和的最小值，用现在的前缀和去减，就做完了。</p>
<p>复习一下滑动窗口的做法：进队尾把大数顶掉，维持单调递增，把超过窗口范围的也推掉。最小值在每次的队头。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n, m, p[300001];
std::deque&lt;std::pair&lt;int, int&gt;&gt; q;

int main() {
    n = read(), m = read();
    for (int i = 1; i &lt;= n; ++i)
        p[i] = p[i - 1] + read();
    int ans = -2e8;
    q.push_back({0, 0});
    for (int i = 1; i &lt;= n; ++i) {
        while (q.size() &amp;&amp; q.back().second &gt; p[i]) q.pop_back();
        q.push_back({i, p[i]});
        if (i - q.front().first &gt; m) q.pop_front();
        ans = std::max(ans, p[i] - q.front().second);
    }
    printf(&quot;%d\n&quot;, ans);
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Educational Codeforces Round #128 (Div.2)]]></title>
    <link href="oi.afobject.ml/cf1680.html"/>
    <updated>2022-05-14T22:28:03+08:00</updated>
    <id>oi.afobject.ml/cf1680.html</id>
    <content type="html"><![CDATA[
<p>[5/6] Alt (Rated), 3/6, 1071 \(\to\) 1278</p>
<span id="more"></span><!-- more -->
<h2><a id="1680c-binary-string" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1680C Binary String</h2>
<p><tc><m>Medium- *1600</m><t>二分</t><t>前缀和</t></tc></p>
<p>场切了，想出二分没觉得特难，到时候看看 \(O(n)\) 做法是什么。</p>
<hr />
<h2><a id="1680d-dog-walking" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1680D Dog Walking</h2>
<p><tc><m>Medium+ *2400</m><t>数学</t><t>贪心</t><t>前缀和</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>题面太长不看。稍微简化一下题面：将数列中的 \(0\) 都替换成 \([-k,k]\) 中的一个数后，令前缀和数组为 \(s\)，最大化 \(\max\{s\}-\min\{s\}\) 且 \(s_n=0\)（很容易判断，当 \(\mid s_n\mid\) 大于 0 的个数乘以 \(k\) 的时候，必然无解）。</p>
<p>由这个式子不难想到最大子段和的前缀和解法，可以差不多地理解一下，这个 \(\max\{s\}-\min\{s\}\) 代表的是原数列中的<strong>一段区间和（的绝对值）</strong>。然后注意到 \(1 \le n \le 3000\) 的良心范围，考虑直接枚举这个区间的左、右端点。最优化的方案必然是要么 0 全替换为 \(k\)，要么全替换为 \(-k\)。</p>
<p>但要求 \(s_n=0\)，怎么处理这个条件也是难点之一。关键点在于看被选择的区间内、外的和能否达到平衡，即「归零」：</p>
<ul>
<li>当区间内的和为一个正数 \(p\)，区间外的和的最小值为 \(p'_{\min}\)，我们想要使 \(p+p'_{\min}=0\)，因此答案取 \(\min\{p, \mid p'_{\min} \mid\}\)；</li>
<li>同理，当区间内的和为一个负数 \(-p\)，区间外的和的最大值为 \(p'_{\max}\)，答案取 \(\min\{\mid p \mid, p'_{\max}\}\)。</li>
</ul>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n, k, a[3001];
int p[3001], d[3001];

signed main() {
    n = read(), k = read();
    for (int i = 1; i &lt;= n; i++) {
        a[i] = read();
        d[i] = d[i - 1] + (a[i] == 0);
        p[i] = p[i - 1] + a[i];
    }
    if (abs(p[n]) &gt; k * d[n]) return puts(&quot;-1&quot;), 0;
    int max = -1;
    for (int l = 1; l &lt;= n; l++) {
        for (int r = l; r &lt;= n; r++) {
            int sum = p[r] - p[l - 1], cnt = d[r] - d[l - 1];
            int lSum = p[n] - sum, lCnt = d[n] - cnt;
            max = std::max(max, std::min(abs(sum + cnt * k), abs(lSum - lCnt * k)));
            max = std::max(max, std::min(abs(sum - cnt * k), abs(lSum + lCnt * k)));
        }
    }
    printf(&quot;%lld\n&quot;, max + 1);
    return 0;
}
</code></pre>
<hr />
<h2><a id="1680e-moving-chips" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1680E Moving Chips</h2>
<p><tc><m>Medium+ *2000</m><t>DP</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>这题里吃的路径其实是可逆的，比如说 A 吃了 B，C 再吃了 B 和 A 吃了 B 然后继续吃了 C 是一样的。所以我们的目标是找出代价最少的一条吃人路径，并且可以钦定任意一个星号作为最终状态。假如设最后留下来的是最右边的某个星号，那就是「从左吃到右」的过程，可以尝试用 DP 来最优化方案。</p>
<p>设 \(f(i,0/1)\) 为把第 \(1\) 到第 \(i-1\) 列全部吃掉，且星号仅在 \((i,0/1)\) 时的最小步数。在对这一列进行 DP 的过程中，我们要考虑的问题是<strong>怎么把上一列的星号全部转移到这一列的目标位置中去</strong>。假如本列有两个星号，<strong>合并一定更优</strong>（否则同时移两个就是浪费），所以也要考虑合并。</p>
<ul>
<li>若全部转移到 \((i,0)\)：
<ul>
<li>从 \((i-1,0)\) 转移：代价为 \(1\)，但如果 \((i,1)\) 有星号，还需要再加一。</li>
<li>从 \((i-1,1)\) 转移：可以顺便吃了 \((i,1)\)，无论如何代价始终为 \(2\)。</li>
</ul>
</li>
<li>若全部转移到 \((i,1)\)：
<ul>
<li>从 \((i-1,1)\) 转移：代价为 \(1\)，但如果 \((i,0)\) 有星号，还需要再加一。</li>
<li>从 \((i-1,0)\) 转移：代价始终为 \(2\)。</li>
</ul>
</li>
</ul>
<p>可以轻松写出状态转移方程。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int T, n;
int g[200001][2], f[200001][2];

int main() {
    std::cin &gt;&gt; T;
    while (T--) {
        std::cin &gt;&gt; n;
        for (int i = 1; i &lt;= n; ++i)
            f[i][0] = f[i][1] = 0;
        for (int i = 0; i &lt; 2; ++i) {
            for (int j = 1; j &lt;= n; ++j) {
                char c; std::cin &gt;&gt; c;
                g[j][i] = (c == '*');
            }
        }
        int l = 1, r = n;
        while (!g[l][0] &amp;&amp; !g[l][1]) ++l;
        while (!g[r][0] &amp;&amp; !g[r][1]) --r;
        for (int i = l; i &lt;= r; ++i) {
            f[i][0] = std::min(f[i - 1][0] + g[i][1] + 1, f[i - 1][1] + 2);
            f[i][1] = std::min(f[i - 1][1] + g[i][0] + 1, f[i - 1][0] + 2);
        }
        std::cout &lt;&lt; std::min(f[r][0], f[r][1]) - 1 &lt;&lt; std::endl;
        // 之前没有特地算 f[l][0/1] 的初始值，循环直接从 l 开始，但是 l-1 -&gt; l 算了 1 步，所以这里减去一。
    }
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces Round #786 (Div.3)]]></title>
    <link href="oi.afobject.ml/cf1674.html"/>
    <updated>2022-05-03T23:02:19+08:00</updated>
    <id>oi.afobject.ml/cf1674.html</id>
    <content type="html"><![CDATA[
<p>[已通关] Rated, 4/7, 1364 \(\to\) 1438</p>
<span id="more"></span><!-- more -->
<p>E 大家都 fst 也就算了，F 就差造个极端数据拍一拍就过了 /fn</p>
<h2><a id="1674f-desktop-rearrangement" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1674F Desktop Rearrangement</h2>
<p><tc><e>Easy+ *1800</e><t>模拟</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>你 CF 为啥要出这种烂模拟。</p>
<p>问题相当于询问有几个图标需要移动。首先求出原图状态下有几个需要移的，接下来考虑变化。</p>
<ul>
<li>
<p>如果是从没有变成有的：</p>
<ul>
<li>在操作<strong>后</strong>的边界上的那个点（如果存在）不用移了，答案减一（如果操作的就是这个点，<strong>忽略</strong>这一条，对答案没有影响）。</li>
<li>另外如果改变的这个点超过了操作<strong>后</strong>的边界，那么就需要费力气移它，答案加一。</li>
</ul>
</li>
<li>
<p>如果是从有变成没有的：</p>
<ul>
<li>操作<strong>前</strong>的守门员（如果存在）被踢了，需要移的加一（如果操作的就是这个点，<strong>忽略</strong>这一条，对答案没有影响）。</li>
<li>如果本来就超出了操作<strong>前</strong>的范围，需要移的减一，否则不变。</li>
</ul>
</li>
</ul>
<p>由上分类讨论可见，<code>.</code> 变 <code>*</code> 和 <code>*</code> 变 <code>.</code> 对答案的影响是不同的，尤其体现在操作前边界或是操作后边界的区别。</p>
<p>更直接的做法是树状数组直接暴力维护范围内有几个（前缀和）。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>考虑将矩阵转为序列，在序列上操作方便得多。</p>
<pre class="line-numbers"><code class="language-cpp">#define trans(i, j) (((j) - 1) * n + (i))
int n, m, q;
char map[1000001];

int main() {
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
    int cnt = 0;
    for (int i = 1, k = 0; i &lt;= n; ++i) {
        for (int j = 1; j &lt;= m; ++j) {
            std::cin &gt;&gt; map[trans(i, j)];
            if (map[trans(i, j)] == '*') ++cnt;
        }
    }
    int ans = cnt;
    for (int i = 1; i &lt;= cnt; ++i)
        if (map[i] == '*')
            --ans;

    while (q--) {
        int x, y;
        std::cin &gt;&gt; x &gt;&gt; y;
        int idx = trans(x, y);
        if (map[idx] == '.') {
            ++cnt;
            if (map[cnt] == '*') --ans;
            if (idx &gt; cnt) ++ans;
            map[idx] = '*';
        } else {
            map[idx] = '.';
            if (idx &gt; cnt) --ans;
            if (map[cnt] == '*') ++ans;
            --cnt;
        }
        std::cout &lt;&lt; ans &lt;&lt; '\n';
    }
    return 0;
}
</code></pre>
<hr />
<h2><a id="1674e-breaking-the-wall" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1674E Breaking the Wall</h2>
<p><tc><m>Medium- *2000</m><t>数学</t><t>贪心</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>形象一点，我们的答案的来源只有可能是这几种情况：</p>
<ul>
<li>火力全开。即对数列中最小的两个每次杀掉 2。适用于数列中最小的两个数分隔较远的情况。</li>
<li>投机取巧。相隔一个数的两个奇数，先通过杀中间的那个数一次转为偶数，然后转为「火力全开」型。</li>
<li>互帮互助。杀掉相邻两个数，互相凑一凑，答案就是两个数和除以 3 向上取整。但当一个数 \(a\) 大于另一个数 \(b\) 的两倍时，此方法只能妥协，答案为 \(\lceil \dfrac a 2 \rceil\)。</li>
</ul>
<p>当被杀的两个数距离大于等于 2 的时候，可以做到各杀各的互不干涉，归于「火力全开」型。</p>
<p>当被杀的两个数距离等于 1 的时候，适用「火力全开」型或「投机取巧」型（总结起来就是两个数加起来除以二向上取整）。</p>
<p>当被杀的两个数相邻，那必然属于「互帮互助」型。</p>
<p>因此，以上三种得到答案的类型覆盖所有的情况，解法是正确的。</p>
<p>这个题叉麻了，300 多测试点，乐死了。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n, a[200001];

int upper(int a, int b) {
    if (a % b) return a / b + 1;
    else return a / b;
}

int main() {
    n = read();
    for (int i = 1; i &lt;= n; ++i) {
        a[i] = read();
    }

    int t3 = 1000000;
    for (int i = 1; i &lt;= n - 1; ++i) {
        int res = 0;
        if (a[i] &gt; a[i + 1] * 2) res = (a[i] + 1) / 2;
        else if (a[i + 1] &gt; a[i] * 2) res = (a[i + 1] + 1) / 2;
        else res = upper(a[i] + a[i + 1], 3);
        t3 = std::min(t3, res);
    }

    int t2 = 1000000;
    for (int i = 1; i &lt;= n - 2; ++i)
        if ((a[i] &amp; 1) &amp;&amp; (a[i + 2] &amp; 1))
            t2 = std::min(t2, 1 + a[i] / 2 + a[i + 2] / 2);

    std::sort(a + 1, a + n + 1);
    int t1 = (a[1] + 1) / 2 + (a[2] + 1) / 2;

    printf(&quot;%d\n&quot;, std::min({t1, t2, t3}));
    return 0;
}
</code></pre>
<hr />
<h2><a id="1674g-remove-directed-edges" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1674G Remove Directed Edges</h2>
<p><tc><m>Medium+ *2000</m><t>图论</t><t>拓扑</t><t>DP</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>首先回顾一下「Cute Set」的定义：</p>
<blockquote>
<p>一个顶点的集合 \(S\) 被称作可爱的当且仅当任意两个顶点 \(v\) 和 \(u\)（\(v \neq u,v \in S,u \in S\)），可以经过由未删除的边组成的路径由 \(u\) 达到 \(v\)，或是从 \(v\) 达到 \(u\)。</p>
</blockquote>
<p>由于原图是一个 DAG，集合中点和未删除的边构成的也是一个 DAG。由 DAG 联想到可以进行拓扑排序。拓扑序中，任何一对相邻的顶点 \((i, i+1)\)，都满足：由 \(i\) 可以通过一条路径到达 \(i+1\)，或是由 \(i+1\) 可以通过条路径到达 \(i\)。若是后者，则 \(i+1\) 在拓扑序中，必位于 \(i\) 之前，矛盾。因此拓扑序中，总可以由靠前的顶点经过一些边到达靠后的顶点。由此推出一个重要的结论：<strong>存在一条经过一个 Cute Set 中所有顶点的路径，一条路径经过的顶点的集合也是一个 Cute Set</strong>。</p>
<p>问题转化为：在 DAG 中找一条最长路，且经过的边均未删除。</p>
<p>转化为一个更简单直白问题后，再来看删边的条件。每个顶点要么没有入边，要么被删一条入边，出边同理。下面思考的问题是，在选择路径的时候，哪些顶点可以被加入集合中？路径对于一个顶点而言，就是一条入边和一条出边。在保留这条路径不能删的同时，它还要预留可以删除的入边、出边各一条，以满足题意。因此，第二个重要的结论是：除了路径的起点没有入度要求、路径的终点没有出度要求以外，对于路径上每一个点的要求是至少分别有两条入边和两条出边，即<strong>对于路径上的每一条边 \(u \to v\)，都要满足 \(out_u&gt;1\) 且 \(in_v&gt;1\)</strong>。</p>
<p>对于 DAG 上最长路问题，直接在拓扑序上 DP 即可，具体方法不再赘述。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n, m;
int ind[200001], oud[200001], del[200001];
std::vector&lt;int&gt; e[200001];
std::queue&lt;int&gt; q;
int f[200001];

int main() {
    n = read(), m = read();
    while (m--) {
        int u = read(), v = read();
        ++ind[v], ++del[v], ++oud[u];
        e[u].push_back(v);
    }
    for (int i = 1; i &lt;= n; ++i) {
        f[i] = 1;
        if (!del[i]) q.push(i);
    }
    int ans = 1;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        ans = std::max(ans, f[u]);
        for (int v : e[u]) {
            if (ind[v] &gt; 1 &amp;&amp; oud[u] &gt; 1)
                f[v] = std::max(f[v], f[u] + 1);
            if (!--del[v])
                q.push(v);
        }
    }
    printf(&quot;%d\n&quot;, ans);
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LGR108]]></title>
    <link href="oi.afobject.ml/LGR108.html"/>
    <updated>2022-05-01T23:13:15+08:00</updated>
    <id>oi.afobject.ml/LGR108.html</id>
    <content type="html"><![CDATA[
<h2><a id="c-sunset-p8320" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>C Sunset - P8320</h2>
<p><tc><e>Easy</e><t>交互</t><t>二分</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>观察 \(a\) 数列的变化趋势，那必然是先上升后不变，不变的那个点为当前数列的最大值。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int main() {
    cin &gt;&gt; T;
    while (T--) {
        cin &gt;&gt; n;
        for (int i = n; i; --i) {
            int last = query(n);
            int l = 1, r = n;
            while (l &lt; r) {
                const int mid = (l + r) / 2;
                if (query(mid) &lt; last) l = mid + 1;
                else r = mid;
            }
            ans[l] = i;
            cout &lt;&lt; &quot;? 2 &quot; &lt;&lt; l &lt;&lt; endl;
        }
        cout &lt;&lt; &quot;! &quot;;
        for (int i = 1; i &lt;= n; ++i)
            cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot;;
        cout &lt;&lt; endl;
    }
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces Round #785 (Div.2)]]></title>
    <link href="oi.afobject.ml/cf1673.html"/>
    <updated>2022-05-01T00:58:35+08:00</updated>
    <id>oi.afobject.ml/cf1673.html</id>
    <content type="html"><![CDATA[
<p>[3/6] Rated, 1/6, \(1448 \to 1364\)，我是天下第一🎤，哈哈哈哈！！！！！！！！！B 都不会！！！</p>
<span id="more"></span><!-- more -->
<h2><a id="1673b-a-perfectly-balanced-string" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1673B A Perfectly Balanced String?</h2>
<p><tc><m>Medium- *1100</m><t>结论</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>五花八门。</p>
<p>你找一个长度最短且首尾字符相同的，此时首尾字符出现的次数为 \(2\)，那么中间的次数只能是 \(1\) 咯，必须每个都轮一遍。轮不到的寄。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>这个 <code>last</code> 的用法还挺妙的。</p>
<pre class="line-numbers"><code class="language-cpp">int T;
char s[200003];
bool e[27];
int last[27];

int main() {
    scanf(&quot;%d&quot;, &amp;T);
    while (T--) {
        scanf(&quot;%s&quot;, s);
        const int len = strlen(s);
        for (int i = 0; i &lt; 27; i++)
            e[i] = false;
        for (int i = 0; i &lt; len; i++)
            e[s[i] - 'a'] = true;
        int kind = 0;
        for (int i = 0; i &lt; 26; i++)
            kind += e[i], last[i] = -1;
        for (int i = 0; i &lt; len; i++) {
            if (last[s[i] - 'a'] != -1) {
                if (i - last[s[i] - 'a'] != kind) {
                    puts(&quot;NO&quot;);
                    goto end;
                }
            }
            last[s[i] - 'a'] = i;
        }
        puts(&quot;YES&quot;);
        end: continue;
    }
    return 0;
}
</code></pre>
<hr />
<h2><a id="1673c-palindrome-basis" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1673C Palindrome Basis</h2>
<p><tc><m>Medium- *1500</m><t>背包</t><t>DP</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>考虑设 \(f(i,j)\) 为在前 \(i\) 个回文数中（第 \(i\) 个为 \(p_i\)），凑出来数 \(n\) 的方案数。则有：</p>
\[f(i,j)=f(i-1,j)+f(i,j-p_i)
\]
<p>考虑省去一维。</p>
\[f(j)\gets f(j)+f(j-p_i)
\]
<p>\(f(0)=1\)。</p>
<p>关于循环顺序：两维的时候你爱咋地咋地，但一维的时候省去了 \(i\) 这维，所以大前提就是在虚拟遍历 \(i\) 只不过没在转移方程里体现出来，\(i\) 必须放在外层，否则就会对 \(f(j)\) 的值产生影响。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">signed main() {
    T = read(); f[0] = 1;
    for (int k = 0; k &lt; P; ++k)
        for (int i = p[k]; i &lt;= 50000; ++i)
            f[i] = (f[i] + f[i - p[k]]) % MOD;
    while (T--)
        printf(&quot;%lld\n&quot;, f[read()]);
}
</code></pre>
<hr />
<h2><a id="1673d-lost-arithmetic-progression" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1673D Lost Arithmetic Progression</h2>
<p><tc><m>Medium+ *1900</m><t>数学</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>由题意直接得出：由公差为 \(d_0,d_1\) 的两个等差数列合成的新等差数列的公差必定为 \(d'=\operatorname{lcm}(d_0,d_1)\)，也就是说 \(d_0 \mid d'\)，\(d_1 \mid d'\)。设这三个等差数列的数的集合分别为 \(A,B,C\)，则 \(A \in C\)，\(B \in C\)。</p>
<p>无解的情况很方便判断，即 \(\exists x \in C\) 满足 \(x\notin B\)，即满足以下条件之一：</p>
<ul>
<li>\(d_B \not\mid d_C\)</li>
<li>\(C_1 \notin B\) 或 \(C_n \notin B\)</li>
</ul>
<p>接下来看有几个解。乍一看好像都是无数个解，但由于 \(A \cap B\) 中不能有 \(C\) 以外的元素，所以 \(A\) 只能在 \(C\) 限定的范围内蠕动，<strong>不得在 \(C\) 之外与 \(B\) 有交点</strong>。而 \(A\) 与 \(B\) 在 \(C\) 左侧第一个交点显然是 \(C_0\) 即 \(C_1-d_C\)（如果 \(B\) 的左端点大于这个那么 \(A\) 可以向左无限延长，无数个解），中间（从 \(C_0+1\) 到 \(C_1\)）放得下的 \(A\) 的个数显然是 \(\dfrac {d_C} {d_A}\)，\(C\) 右侧同理。因此，对于每一个 \(d_A\) 使得 \(\operatorname{lcm}(d_A,d_B)=d_C\)，答案为 \(\left(\dfrac {d_C} {d_A}\right)^2\)。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">#define int __int128
#define MOD 1000000007

int T;
struct AP {
    int s, d, n;
    int get(int i) { return (i - 1) * d + s; }
    int last() { return get(n); }
    bool in(int x) {
        if (s &lt;= x &amp;&amp; x &lt;= last() &amp;&amp; (x - s) % d == 0) return true;
        else return false;
    }
} b, c;

int gcd(int a, int b) {
    return a % b ? gcd(b, a % b) : b;
}
int lcm(int a, int b) {
    return a / gcd(a, b) * b;
}

signed main() {
    T = read();
    while (T--) {
        b.s = read(), b.d = read(), b.n = read();
        c.s = read(), c.d = read(), c.n = read();
        if (c.d % b.d || !b.in(c.s) || !b.in(c.last()))
            puts(&quot;0&quot;);
        else if (b.s &gt; c.get(0) || b.last() &lt; c.get(c.n + 1))
            puts(&quot;-1&quot;);
        else {
            int ans = 0;
            for (int x = 1; x * x &lt;= c.d; ++x) {
                if (lcm(x, b.d) == c.d)
                    ans = (ans + (c.d / x) * (c.d / x)) % MOD;
                if (x * x != c.d &amp;&amp; lcm(c.d / x, b.d) == c.d)
                    ans = (ans + x * x) % MOD;
            }
            printf(&quot;%lld\n&quot;, (long long)ans);
        }
    }
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x113 单调栈]]></title>
    <link href="oi.afobject.ml/0x113.html"/>
    <updated>2022-04-27T21:35:55+08:00</updated>
    <id>oi.afobject.ml/0x113.html</id>
    <content type="html"><![CDATA[
<h2><a id="largest-rectangle-in-a-histogram" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Largest Rectangle in a Histogram</h2>
<p><tc><c>0x1104</c><e>Easy+</e><t>单调栈</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>考虑对于每一个 \(x\) 坐标，都尝试找出以它为右边界的最大的矩形的面积。那么可能成为答案的矩形在左侧一定终止于在它左侧，且比它矮的一个位置。所以在它左侧，且比它高的东西没有用，直接用单调栈扔掉就行。</p>
<p>在原位置在 \(i\) 的一个数 \(k\) 在位置 \(j\) 时被推出栈的时候统计答案，答案为 \((j-i+d(k))\times k\)，其中 \(d(k)\) 代表这个数 \(k\) 顶掉的数的个数（即不在栈中，但可以算进矩形的宽的数，包括直接顶掉和间接顶掉）。在整个数列末尾追加一个 0，顶掉所有数。</p>
<p>按照书上做法，其实也可以把被顶掉的压一压高度，栈内宽度不变，这样就不用分「直接顶掉」和「间接顶掉」了，不过差不多。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n, a;
std::stack&lt;std::pair&lt;int, int&gt;&gt; s;
int d[1000001];

int main() {
    while (true) {
        n = read();
        if (!n) break;
        for (int i = 1; i &lt;= n; ++i) d[i] = 0;
        while (s.size()) s.pop();
        long long ans = 0;
        for (int i = 1; i &lt;= n + 1; i++) {
            a = (i &lt;= n) ? read() : 0;
            while (s.size() &amp;&amp; s.top().second &gt; a) {
                const int u = s.top().first, h = s.top().second;
                ans = std::max(ans, (long long)(i - u + d[u]) * h), d[i] += d[u] + 1;
                s.pop();
            }
            s.push({i, a});
        }
        printf(&quot;%lld\n&quot;, ans);
    }
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x112 表达式求值]]></title>
    <link href="oi.afobject.ml/0x112.html"/>
    <updated>2022-04-27T08:36:45+08:00</updated>
    <id>oi.afobject.ml/0x112.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E4%B8%BA%E5%90%8E%E7%BC%80%E6%B1%82%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>中缀表达式转为后缀求值</h2>
<p>首先举个例子：</p>
<p>中缀：<code>3 * (1 - 2)</code><br />
后缀：<code>3 1 2 - *</code></p>
<p>所有数的顺序肯定是一样的，然后就是运算符的问题（不管括号），同一优先级的情况下（如 <code>1 + 1 - 4</code> \(\to\) <code>1 1 4 - +</code>）就可以把运算符倒序输出，如果非同一优先级（如 <code>5 * 1 + 4</code> \(\to\) <code>5 1 * 4 +</code>），那就在一个运算符入栈的同时，看一下有没有比它优先级高的在栈里，如果有，顶掉输出。</p>
<p>现在考虑括号问题，括号内当一个子问题求解就行了（碰到一个右括号就把左括号及之后的所有内容输出，有点像递归的栈的写法）。</p>
<pre class="line-numbers"><code class="language-cpp">std::string s;
std::stack&lt;char&gt; st;
int priority[151];

int type[100001], n = 0;
double m[100001]; char o[100001];
std::stack&lt;double&gt; h;

int main() {
    std::cin &gt;&gt; s;
    s = '(' + s + ')';

    priority['*'] = priority['/'] = 2;
    priority['+'] = priority['-'] = 1;
    priority[')'] = 3; priority['('] = 0;

    double num = 0.0; bool flag = false;
    for (char x : s) {
        if (x &gt;= '0' &amp;&amp; x &lt;= '9') {
            flag = true;
            num *= 10, num += x - '0';
        } else {
            if (flag)
                type[++n] = 1, m[n] = num,
                num = 0, flag = false;
            if (x == ')')  {
                while (st.top() != '(')
                    type[++n] = 2, o[n] = st.top(), st.pop();
                st.pop();
                continue;
            } else if (x != '(') {
                while (st.size() &amp;&amp; priority[st.top()] &gt;= priority[x])
                    type[++n] = 2, o[n] = st.top(), st.pop();
            }
            st.push(x);
        }
    }

    for (int i = 1; i &lt;= n; ++i) {
        if (type[i] == 1) {
            h.push(m[i]);
        } else {
            double rhs = h.top(); h.pop();
            double lhs = h.top(); h.pop();
            if (o[i] == '+') h.push(lhs + rhs);
            if (o[i] == '-') h.push(lhs - rhs);
            if (o[i] == '*') h.push(lhs * rhs);
            if (o[i] == '/') h.push(lhs / rhs);
        }
    }

    std::cout &lt;&lt; h.top() &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<h2><a id="%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E9%80%92%E5%BD%92%E6%B3%95%E6%B1%82%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>中缀表达式的递归法求值</h2>
<p>这个比较简单好写，但时间复杂度是平方的。</p>
<pre class="line-numbers"><code class="language-cpp">std::string s;

double solve(int l, int r) {
    int add = -1, mul = -1, t = 0;
    for (int i = r; i &gt;= l; --i) {
        if (s[i] == ')') ++t;
        else if (s[i] == '(') --t;
        if (t == 0 &amp;&amp; add == -1 &amp;&amp; (s[i] == '+' || s[i] == '-'))
            add = i;
        if (t == 0 &amp;&amp; mul == -1 &amp;&amp; (s[i] == '*' || s[i] == '/'))
            mul = i;
    }
    if (add != -1) {
        if (s[add] == '+') return solve(l, add - 1) + solve(add + 1, r);
        else return solve(l, add - 1) - solve(add + 1, r);
    } else if (mul != -1) {
        if (s[mul] == '*') return solve(l, mul - 1) * solve(mul + 1, r);
        else return solve(l, mul - 1) / solve(mul + 1, r);
    } else if (s[l] == '(' &amp;&amp; s[r] == ')') {
        return solve(l + 1, r - 1);
    } else {
        double ans = 0;
        for (int i = l; i &lt;= r; i++) {
            ans *= 10;
            ans += s[i] - '0';
        }
        return ans;
    }
}

int main() {
    std::cin &gt;&gt; s;
    std::cout &lt;&lt; solve(0, s.size() - 1) &lt;&lt; std::endl;
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x111 栈基础]]></title>
    <link href="oi.afobject.ml/0x111.html"/>
    <updated>2022-04-25T08:20:03+08:00</updated>
    <id>oi.afobject.ml/0x111.html</id>
    <content type="html"><![CDATA[
<h2><a id="push-pop-getmin" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Push, Pop, GetMin</h2>
<p><tc><c>0x1101</c><e>Easy-</e><t>栈</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>维护两个栈，一个是题目中给出的栈，一个保存每个时刻最小值。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">class MinStack {
public:
    std::stack&lt;int&gt; o, m;
    MinStack() {}
    void push(int x) {
        o.push(x);
        if (m.size())
            m.push(std::min(m.top(), x));
        else
            m.push(x);
    }
    void pop() {
        o.pop();
        m.pop();
    }
    int top() {
        return o.top();
    }
    int getMin() {
        return m.top();
    }
};
</code></pre>
<hr />
<h2><a id="editor" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Editor</h2>
<p><tc><c>0x1102</c><e>Easy</e><t>栈</t><t>模拟</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>考虑建立对顶栈，这样前四种操作都可以实现。</p>
<p>对于第五种操作，可以再建立两个栈，一个保存所有时刻的前缀和，另一个用 0x1101 的方式维护最小值，只不过这里要用数组模拟栈（需要直接访问）。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>注意第一个数为负数时的处理。</p>
<pre class="line-numbers"><code class="language-cpp">int n;
std::stack&lt;int&gt; a, b;
int s[1000001], f[1000001], top;

void pushA(int t) {
    a.push(t);
    s[top + 1] = s[top] + t;
    if (top) f[top + 1] = std::max(f[top], s[top + 1]);
    else f[top + 1] = s[top + 1];
    ++top;
}

void popA() {
    a.pop();
    --top;
}

int main() {
    std::cin &gt;&gt; n;
    while (n--) {
        char c; int t;
        std::cin &gt;&gt; c;
        switch (c) {
            case 'I':
                std::cin &gt;&gt; t; pushA(t);
                break;
            case 'D':
                if (a.size()) popA();
                break;
            case 'L':
                if (a.size()) b.push(a.top()), popA();
                break;
            case 'R':
                if (b.size()) pushA(b.top()), b.pop();
                break;
            case 'Q':
                std::cin &gt;&gt; t;
                std::cout &lt;&lt; f[t] &lt;&lt; std::endl;
                break;
        }
    }
    return 0;
}
</code></pre>
<hr />
<h2><a id="%E8%BF%9B%E5%87%BA%E6%A0%88%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>进出栈序列问题</h2>
<p><tc><c>0x1103</c><m>Medium</m><t>栈</t><t>数学</t><t>DP</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%951" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法 1</h3>
<p>\(O(n^2)\)。</p>
<p>设 \(f(k)\) 为 \(n=k\) 时的答案。显然，\(f(0)=f(1)=1,f(2)=2\)。</p>
<p>假设最后一个出栈的选手是 \(k\)。一个数入栈时，栈里不可能有比它还大的数，如果想要压着 \(k\) 留到最后一个出栈，那必须把比它小的先踢掉，让它到栈底。因此在它之前入栈的共有 \(f(k-1)\) 种排列方式，跳过它，比它大的共有 \(f(n-k)\) 种方式。总方案数是</p>
\[\sum_{k=1}^nf(k-1) \cdot f(n-k)
\]
<p>这样的拆分是可行的。同样，也可以分析 \(1\) 来得到这个结论。</p>
<h3><a id="%E7%AE%97%E6%B3%952" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法 2</h3>
<p>\(O(n^2)\)。</p>
<p>设 \(f(i,j)\) 为其中出了 \(i\) 个，还有 \(j\) 个没出的方案数。目标状态为 \(f(n,0)\)。</p>
<p>每一步要么弹入一个，要么弹出栈顶。</p>
\[f(i,j)=f(i-1,j+1)+f(i,j-1)
\]
<h3><a id="%E7%AE%97%E6%B3%953" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法 3</h3>
<p>这玩意就是卡特兰数。</p>
\[Cat_n=\dfrac{2n \choose n}{n+1}
\]
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>贺就完了。</p>
<pre class="line-numbers"><code class="language-python">from math import factorial
n = int(input())
a = factorial(2 * n)
b = factorial(n)
print(a // b // b // (n + 1))
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ABC249]]></title>
    <link href="oi.afobject.ml/abc249.html"/>
    <updated>2022-04-23T20:54:17+08:00</updated>
    <id>oi.afobject.ml/abc249.html</id>
    <content type="html"><![CDATA[
<p>[6/8] 为什么每次打 ABC 都碰上蓝色的 E（恼）</p>
<p>Rated, 4/8, 977 \(\to\) 987</p>
<span id="more"></span><!-- more -->
<h2><a id="d-index-trio" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>D Index Trio</h2>
<p><tc><m>Medium- *983</m><t>数论</t><t>组合</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%951" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法 1</h3>
<p>从乘积出发。</p>
<p>考虑对于每一个数，根号复杂度分解质因数。如果分到的恰好都是数列里的数，则答案加上两边出现次数的乘积再乘以二。有一些小细节。</p>
<h3><a id="%E7%AE%97%E6%B3%952" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法 2</h3>
<p>从乘数出发。</p>
<p>在记录每个数的出现次数后，对于每对 \((i,j)\)，答案直接加上 \(c_i \cdot c_j \cdot c_{i \times j}\)。时间复杂度能过。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>（算法 1）</p>
<pre class="line-numbers"><code class="language-cpp">#define int long long

int n;
int b[1000001];

signed main() {
    n = read();
    for (int i = 1; i &lt;= n; i++)
        ++b[read()];
    int ans = 0;
    for (int i = 1; i &lt;= 200000; i++) {
        if (!b[i]) continue;
        for (int x = 1; x * x &lt;= i; ++x)
            if (i % x == 0)
                if (b[x] &amp;&amp; b[i / x]) {
                    if (x * x == i) ans += b[i] * b[x] * b[x];
                    else ans += b[i] * b[x] * b[i / x] * 2;
                }
    }
    printf(&quot;%lld\n&quot;, ans);
    return 0;
}
</code></pre>
<hr />
<h2><a id="f-ignore-operations" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>F Ignore Operations</h2>
<p><tc><m>Medium *1786</m><t>堆</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>考虑一下如果一定要删一个操作，那么肯定是看一下删哪个对最终的结果最好。如果该操作后面有替换操作，那么屁用没有；否则对最终答案的贡献就是进行到那一步和前一步操作后的结果差。</p>
<p>那如果一定要删两个呢？</p>
<p>在替换操作前面删屁用没有。所以要么在这之后选 \(y\) 最小的两个修改操作，要么就干脆直接把这个替换操作删了。所以有三种：</p>
<ul>
<li>在最后一个替换操作后面选两个 \(y\) 最小的删；</li>
<li>删了最后一个替换操作，然后在倒数第二个后面选一个最小的删；</li>
<li>直接删掉最后两个替换操作。</li>
</ul>
<p>扩展到选 \(k\) 个删，且没必要删完：</p>
<ul>
<li>在最后一个替换操作后面选至多 \(k\) 个 \(y\) 最小且为负的删；</li>
<li>删了最后一个替换操作，然后在倒数第二个后面选至多 \(k-1\) 个最小且为负的删；</li>
<li>……</li>
<li>把最后 \(k\) 个替换操作全删了（如果有）。</li>
</ul>
<p>在以上 \(k+1\) 种答案中选一个最小的即可。到这里时间复杂度为 \(O(n \log n + k^2)\)，不太行。</p>
<p>接下来考虑怎么更高效地维护信息。可以从后往前，动态维护所有修改操作 \(y\) 的前 \(k\) 小，并维护这个顺序，碰到一个替换操作的时候就可以计算出一种可能的答案了。</p>
<p>设两个相邻的替换操作在 \(i,j\) 这两个位置，并且我已经在 \((j,n]\) 范围内的修改操作中找到了删去最优的 \(k\) 个的和。我现在要找 \((i,n]\) 范围内最优 \(k-1\) 个的和。这个相对比较容易，首先先踢出去一个，然后优先队列（大根堆）维护就行了（同时另外维护一个总和），在 \((i,j)\) 的修改操作中碰到有比优先队列中相对最不优的那个更优的，把它顶掉就行了。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n, k;
std::stack&lt;int&gt; rep;
std::priority_queue&lt;long long&gt; q;
long long t[200005], y[200005];
long long suf[200005];

int main() {
    n = read(), k = read();
    rep.push(0);
    for (int i = 1; i &lt;= n; i++) {
        t[i] = read(), y[i] = read();
        if (t[i] == 1)
            rep.push(i);
    }

    for (int i = n; i; --i)
        if (t[i] == 2)
            suf[i] = suf[i + 1] + y[i];
        else
            suf[i] = suf[i + 1];

    int now, last = n;
    long long sum = 0, ans = -1e18;
    do {
        now = rep.top() + 1;
        rep.pop();
        for (int i = now; i &lt;= last; ++i)
            if (t[i] == 2 &amp;&amp; y[i] &lt; 0) {
                if (q.size() &lt; k) {
                    sum += y[i];
                    q.push(y[i]);
                } else if (k &amp;&amp; q.top() &gt; y[i]) {
                    sum += y[i] - q.top();
                    q.pop();
                    q.push(y[i]);
                }
            }
        ans = std::max(ans, y[now - 1] + suf[now] - sum);
        last = now - 2;
        if (k &amp;&amp; q.size() == k) sum -= q.top(), q.pop();
        --k;
    } while (k &gt;= 0 &amp;&amp; rep.size());

    printf(&quot;%lld\n&quot;, ans);
    return 0;
}
</code></pre>
<hr />
<h2><a id="e-rle" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>E RLE</h2>
<p><tc><m>Medium+ *1970</m><t>DP</t><t>前缀和</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>设 \(f(i,j)\) 为原长为 \(i\)，压缩后长为 \(j\) 的个数。</p>
<p>接下来考虑转移。首先假如连续段长度都只有个位数，则</p>
\[f(i,j)=\sum_{k=1}^9 f(i-k,j-2)
\]
<p>扩展：</p>
\[\begin{aligned}
f(i,j)&amp;=\sum_{k=1}^i f(i-k,j-\lfloor\log_{10}(k)\rfloor-1)
\end{aligned}
\]
<p>\(k\) 从 \(1\) 到 \(i\) 的遍历相当于逐个尝试这个字符串最后连续相同字符的个数。</p>
<p>但上面这个方程不完全对，还要考虑到每个字符都不一样，转移时都要乘上系数 \(25\)。</p>
<p>但是这样的效率还是不够高，我们考虑对于 \(f\) 的每一行进行一个前缀和，由于 \(i,j\) 显然最多只是四位数，状态转移方程变为：</p>
\[\begin{aligned}
f(i,j)&amp;=25 \cdot [ s(i-1,j-2)-s(i-10,j-2)\\
&amp;+s(i-10,j-3)-s(i-100,j-3)\\
&amp;+s(i-100,j-4)-s(i-1000,j-4)\\
&amp;+s(i-1000,j-5)-s(i-10000,j-5) ]
\end{aligned}
\]
<p>计数的时候从小到大对于每个 \(i\) 分别讨论，注意到当原长为 \(i\) 时，\(j\) 至少为 \(\lfloor \log_{10}(i)  \rfloor+1\)，因此初始值 \(f(i,\lfloor \log_{10}(i)\rfloor+1)=26\)，其余的直接 \(0\)，懒得考虑边界问题。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">long long n, p; // npk48
long long f[3005][3005], s[3005][3005];

int len(int x) {
    if (x &lt; 10) return 2;
    if (x &lt; 100) return 3;
    if (x &lt; 1000) return 4;
    return 5;
}

int main() {
    n = read(), p = read();
    for (int i = 1; i &lt;= n; ++i) {
        f[i][len(i)] = 26ll;
        for (int j = 1; j &lt; n; ++j) {
            f[i][j] = M(f[i][j] + 25ll * (s[T(i - 1)][T(j - 2)]     - s[T(i - 10)][T(j - 2)]));
            f[i][j] = M(f[i][j] + 25ll * (s[T(i - 10)][T(j - 3)]    - s[T(i - 100)][T(j - 3)]));
            f[i][j] = M(f[i][j] + 25ll * (s[T(i - 100)][T(j - 4)]   - s[T(i - 1000)][T(j - 4)]));
            f[i][j] = M(f[i][j] + 25ll * (s[T(i - 1000)][T(j - 5)]  - s[T(i - 3001)][T(j - 5)]));
            s[i][j] = M(s[i - 1][j] + f[i][j]);
        }
    }
    long long ans = 0;
    for (int i = 1; i &lt; n; ++i)
        ans = M(ans + f[n][i]);
    printf(&quot;%lld\n&quot;, ans);
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x00 索引]]></title>
    <link href="oi.afobject.ml/0x00-.html"/>
    <updated>2022-04-23T11:01:36+08:00</updated>
    <id>oi.afobject.ml/0x00-.html</id>
    <content type="html"><![CDATA[
<h2><a id="0x01" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>0x01</h2>
<table>
<thead>
<tr>
<th>题目</th>
<th>一句话题解</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x0101</td>
<td>快速幂板子，通过二进制拆分 \(b\) 证明结论。</td>
</tr>
<tr>
<td>0x0102</td>
<td>模拟。</td>
</tr>
<tr>
<td>0x0103</td>
<td>快速幂改快速乘。</td>
</tr>
<tr>
<td>0x0104</td>
<td>状压 DP 板子，设 \(f(i,u)\) 为经过的点集为 \(i\)，且当前点为 \(u\) 时的最短路长度，容易推出转移方程。</td>
</tr>
<tr>
<td>0x0105</td>
<td>从高到低对于每一位分别讨论，如果该位不确定，则在 \(m\) 的限制条件下尽量让它变成 1。</td>
</tr>
</tbody>
</table>
<h2><a id="0x02" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>0x02</h2>

]]></content>
  </entry>
  
</feed>
