<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[OI Blog]]></title>
  <link href="oi.afobject.ml/atom.xml" rel="self"/>
  <link href="oi.afobject.ml/"/>
  <updated>2022-03-20T00:02:49+08:00</updated>
  <id>oi.afobject.ml/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[0xff 算法竞赛进阶指南]]></title>
    <link href="oi.afobject.ml/overview.html"/>
    <updated>2022-01-07T23:06:53+08:00</updated>
    <id>oi.afobject.ml/overview.html</id>
    <content type="html"><![CDATA[
<hr />
<ul>
<li><c>0x0101</c> 表示题目编号。根据书后索引编号，如果有明确来源则会标注。</li>
<li><e>Easy</e> 我能很快做出来的题目。<br />
大约对应 *1500 以内，如 NOIP 2021 A。</li>
<li><m>Medium</m> 我需要充足的思考才能做出来或者能有个大概方向但细节卡住了的题目。<br />
大约对应 *2200 以内，如 CSP-S 2021 A。</li>
<li><h>Hard</h> 蚌。</li>
</ul>
<hr />
<ul>
<li>0x00 基本算法</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x01 位运算]]></title>
    <link href="oi.afobject.ml/0x01.html"/>
    <updated>2022-01-08T11:01:10+08:00</updated>
    <id>oi.afobject.ml/0x01.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E8%A1%A5%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>补码</h2>
<ul>
<li>对于 <code>unsigned int</code>：补码等于原码。</li>
<li>对于 <code>signed int</code>：正数部分补码等于原码，负数部分 \([-2^{31}, -1]\) 相当于 <code>unsigned int</code> \([2^{31}+1, 2^{32}]\)。即原来的<strong>负数的绝对值减去 1 后取反</strong>。<br />
\(-45 \to -(00101101)_2 \to \operatorname{rev}(00101101-1)_2 \to (11010011)_2\)。</li>
</ul>
<hr />
<h2><a id="%E6%88%90%E5%AF%B9%E5%8F%98%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>成对变换</h2>
<p>\((0,1), (2,3), (4,5)\) 这些二元组中的一个数可以通过 <code>xor</code> 运算得到另一个数。应用：双向边邻接表。</p>
<hr />
<h2><a id="lowbit%E8%BF%90%E7%AE%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>lowbit 运算</h2>
<p>lowbit 是<strong>二进制下最低位的 1 及其右边的所有 0 构成的数值</strong>。</p>
\[\operatorname{lowbit}(n)=n\ \&amp;\ (-n)
\]
<p>应用：哈希、树状数组等。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x011 位运算基础]]></title>
    <link href="oi.afobject.ml/0x011.html"/>
    <updated>2022-01-07T22:44:17+08:00</updated>
    <id>oi.afobject.ml/0x011.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E5%BF%AB%E9%80%9F%E5%B9%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>快速幂</h2>
<p><tc><c>0x0101</c><e>Easy-</e><t>快速幂</t></tc></p>
<p>求 \(a^b \bmod p\) 的值。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>\(b\) 可以拆分为这样的二进制：\(b=\sum\limits_{i=0}^{n-1} k_i \times 2^i\)（\(k_i \in \{0, 1\}\)）。</p>
<p>因此 \(a^b = \prod\limits_{i=0}^{n-1} a^{k_i \times 2^{i}}\)。</p>
<p>可以看成递推：\(p_i=a^{2^i}\)，则 \(a^b = \prod\limits_{i=0}^{n-1} p_{i}^{k_i}\)，其中 \(p_{i}= p_{i-1}^2\)。</p>
<p>做的时候直接把数组免了。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int pow(int a, int b, int p) {
	int ans = 1 % p;
	while (b) {
		if (b &amp; 1)
			ans = (ans * a) % p;
		a = (a * a) % p;
		b &gt;&gt;= 1;
	}
	return ans;
}
</code></pre>
<hr />
<h2><a id="raising-modulo-numbers" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Raising Modulo Numbers</h2>
<p><tc><c>0x0102</c><e>Easy-</e><t>快速幂</t></tc></p>
<p>给你 \(N\) 组数，让你求 \(\sum a_i^{b_i} \bmod M\)（\(N, M \le 4.5 \times 10^4\)）。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>暴力。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n, p, a, b, T;
signed main() {
	T = read();
	while (T--) {
		p = read(), n = read();
		int ans = 0;
		while (n--) {
			a = read(), b = read();
			ans = (ans + pow(a, b, p)) % p;
		}
		printf(&quot;%lld\n&quot;, ans);
	}
}
</code></pre>
<hr />
<h2><a id="64%E4%BD%8D%E6%95%B4%E6%95%B0%E4%B9%98%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>64 位整数乘法</h2>
<p><tc><c>0x0103</c><e>Easy-</e><t>快速幂</t></tc></p>
<p>求 \(a \times b \bmod p\) 的值。\(1 \le a,b,p \le 10^{18}\)。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>除非用 <code>__int128</code>，否则必须要将 \(a,b\) 拆分成更小的数再合并求积。这时就可以用到位运算了。</p>
<p>和快速幂几乎完全一样，改几个符号而已。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int mul(int a, int b, int p) {
	int ans = 0;
	while (b) {
		if (b &amp; 1)
			ans = (ans + a) % p;
		a = (a &lt;&lt; 1) % p;
		b &gt;&gt;= 1;
	}
	return ans;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x012 二进制状态压缩]]></title>
    <link href="oi.afobject.ml/0x012.html"/>
    <updated>2022-01-07T22:44:57+08:00</updated>
    <id>oi.afobject.ml/0x012.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E6%9C%80%E7%9F%ADhamilton%E8%B7%AF%E5%BE%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>最短 Hamilton 路径</h2>
<p><tc><c>0x0104</c><c>LG1171</c><m>Medium</m><t>状压</t><t>DP</t></tc></p>
<p>在一张点数小于等于 \(20\) 的带权无向图中找出一条从 \(0\) 到 \(n-1\) <strong>不重不漏地经过每一个点</strong>且<strong>边权和最短</strong>的路径。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>很容易想到用一个二进制数来表示已路过的点的状态（路径状态）。</p>
<p>令 \(f(s,i)\) 为路径状态为 \(s\)，当前点在 \(i\) 的最短路。然后转移即可。</p>
\[f(s,i) = \min_{s' \to s}\{f(s',k) + w(k,i)\}
\]
<p>注意细节：\(s'\) 能通向 \(s\) 需要满足 <strong>\(k\) 包含在 \(s'\) 中</strong>，即 \(k\) 包含在 \(s\) 中且 \(k \neq i\)。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n;
int w[21][21];
int dis[1 &lt;&lt; 21][21];

int main() {
    memset(dis, 0x3f, sizeof dis);
	dis[1][0] = 0;
	for (int s = 2; s &lt; (1 &lt;&lt; n); ++s) {
		for (int i = 0; i &lt; n; ++i) {
			if (!((s &gt;&gt; i) &amp; 1)) continue; // 要求 s 包含 i。
			for (int k = 0; k &lt; n; ++k) { // 选择上一个点。
				if ((s &gt;&gt; k) &amp; 1 &amp;&amp; k != i) // 要求 s 包含 k 且 k 不等于 i。
					dis[s][i] = std::min(dis[s][i], dis[s ^ (1 &lt;&lt; i)][k] + w[k][i]);
			}
		}
	}
	printf(&quot;%d\n&quot;, dis[(1 &lt;&lt; n) - 1][n - 1]);
	return 0;
}
</code></pre>
<hr />
<h2><a id="%E8%B5%B7%E5%BA%8A%E5%9B%B0%E9%9A%BE%E7%BB%BC%E5%90%88%E7%97%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>起床困难综合症</h2>
<p><tc><c>0x0105</c><c>NOI 2014</c><m>Medium</m><t>位运算</t><t>贪心</t></tc></p>
<p>\([0, m]\) 之间选择一个数，使得经过 \(n\) 次位运算后值最大，求最大值。\(m \le 10^9\)，\(n \le 10^5\)。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>很牛的一点：<strong>题目中这些操作在二进制中都不会产生进位。</strong></p>
<p>所以每一位分讨，结果能是 1 就是 1，原数能是 0 就是 0（因为要满足 \(\le m\) 的条件）。</p>
<p>即如果只有填 1 结果才能是 1，且当前还 \(\le m\) 的情况下，就填 1。否则一律填 0。</p>
<p>从高到低分位讨论。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n, m, arg[1000001];
std::string op[1000001];

bool calc(int k, bool val) {
	for (int i = 1; i &lt;= n; ++i) {
		if (op[i] == &quot;AND&quot;)
			val &amp;= (arg[i] &gt;&gt; k) &amp; 1;
		else if (op[i] == &quot;OR&quot;)
			val |= (arg[i] &gt;&gt; k) &amp; 1;
		else
			val ^= (arg[i] &gt;&gt; k) &amp; 1;
	}
	return val;
}

int main() {
	std::cin &gt;&gt; n &gt;&gt; m;
	for (int i = 1; i &lt;= n; ++i)
		std::cin &gt;&gt; op[i] &gt;&gt; arg[i];
		
	int sel = 0, ans = 0;
	for (int i = 30; i &gt;= 0; --i) {
		if (sel + (1 &lt;&lt; i) &lt;= m &amp;&amp;
			calc(i, 0) == 0 &amp;&amp; calc(i, 1) == 1)
			sel += (1 &lt;&lt; i), ans += (1 &lt;&lt; i);
		else if (calc(i, 0))
			ans += (1 &lt;&lt; i);
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x02 递推与递归]]></title>
    <link href="oi.afobject.ml/0x02.html"/>
    <updated>2022-01-15T10:33:03+08:00</updated>
    <id>oi.afobject.ml/0x02.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E5%AE%8F%E8%A7%82%E6%8F%8F%E8%BF%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>宏观描述</h2>
<h3><a id="%E9%80%92%E5%BD%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>递归</h3>
<p>从原大问题出发到小问题，然后将小问题推广到大问题。</p>
<p>缩小、求解、扩展。</p>
<p>Key Points：</p>
<ul>
<li>自身调用自身</li>
<li>回溯时还原现场。</li>
</ul>
<h3><a id="%E9%80%92%E6%8E%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>递推</h3>
<p>正向，由小问题直接推到大问题。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x021 递推与递归的简单应用]]></title>
    <link href="oi.afobject.ml/0x021.html"/>
    <updated>2022-01-15T10:36:36+08:00</updated>
    <id>oi.afobject.ml/0x021.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8C%87%E6%95%B0%E5%9E%8B%E6%9E%9A%E4%B8%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>递归实现指数型枚举</h2>
<p><tc><c>0x0201</c><e>Easy-</e><t>递归</t><t>搜索</t></tc></p>
<pre class="line-numbers"><code class="language-cpp">bool c[21];
void recursive(int t) {
	if (t == n + 1) {
		for (int i = 1; i &lt;= n; ++i)
			if (c[i])
				printf(&quot;%d &quot;, i);
		putchar('\n');
		return;
	}
	c[t] = true;
	recursive(t + 1);
	c[t] = false;
	recursive(t + 1);
}
</code></pre>
<h2><a id="%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E7%BB%84%E5%90%88%E5%9E%8B%E6%9E%9A%E4%B8%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>递归实现组合型枚举</h2>
<p><tc><c>0x0202</c><e>Easy-</e><t>递归</t><t>搜索</t></tc></p>
<pre class="line-numbers"><code class="language-cpp">bool c[21];
void recursive(int t, int sel) {
	if (sel &gt; m || sel + n - t + 1 &lt; m)
		return;
	if (t == n + 1) {
		for (int i = 1; i &lt;= n; ++i)
			if (c[i])
				printf(&quot;%d &quot;, i);
		putchar('\n');
		return;
	}
	c[t] = true;
	recursive(t + 1, sel + 1);
	c[t] = false;
	recursive(t + 1, sel);
}
</code></pre>
<h2><a id="%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%88%97%E5%9E%8B%E6%9E%9A%E4%B8%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>递归实现排列型枚举</h2>
<p><tc><c>0x0203</c><e>Easy-</e><t>递归</t><t>搜索</t></tc></p>
<pre class="line-numbers"><code class="language-cpp">bool c[21];
int sel[21];
void recursive(int t) {
	if (t == n + 1) {
		for (int i = 1; i &lt;= n; ++i)
			printf(&quot;%d &quot;, sel[i]);
		putchar('\n');
		return;
	}
	for (int i = 1; i &lt;= n; ++i) {
		if (!c[i]) {
			sel[t] = i;
			c[i] = true;
			recursive(t +  1);c[i] = false;
		}
	}
}
</code></pre>
<hr />
<h2><a id="%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>费解的开关</h2>
<p><tc><c>0x0204</c><m>Medium</m><t>结论</t><t>贪心</t></tc></p>
<p>\(5\times 5\) 的 01 矩阵中，点击一个位置，它及它上下左右格内的数都会变化，最少多少次点击变成全 0？</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p><strong>考虑特殊情况：</strong> 假如不能动第一行，则对于第一行的任意一个数，如果它是 1，那么只能点击它下面的那个格子。</p>
<p>又有：<strong>点击的顺序不影响最终的结果。</strong> 一个格子被翻转的次数等于它四周的格子被点按次数之和。所以可以以任意顺序考虑点击的位置。</p>
<p>因此只用枚举第一行的 \(2^5\) 种状态即可。后面的方案都是确定的。假如最后不都为 0 那么这种做法就是寄的，继续搜索求解。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>第一次在 OI 里写异常处理。</p>
<pre class="line-numbers"><code class="language-cpp">int T;
int m[7][7];
int t[7][7];

int cnt = 0;
void doOper(int x, int y) {
	t[x][y] ^= 1;
	t[x - 1][y] ^= 1;
	t[x + 1][y] ^= 1;
	t[x][y - 1] ^= 1;
	t[x][y + 1] ^= 1;
	++cnt;
	if (cnt &gt; 6)
		throw -1;
}

int main() {
	scanf(&quot;%d&quot;, &amp;T);
	while (T--) {
		for (int i = 1; i &lt;= 5; ++i)
			for (int j = 1; j &lt;= 5; ++j)
				scanf(&quot;%1d&quot;, &amp;m[i][j]);
		int ans = 0x3f3f3f3f;
		for (int s = 0; s &lt; 32; ++s) {
			cnt = 0;
			try {
				for (int i = 1; i &lt;= 5; ++i)
					for (int j = 1; j &lt;= 5; ++j)
						t[i][j] = m[i][j];
				for (int i = 1, s0 = s; s0; s0 &gt;&gt;= 1, ++i)
					if (s0 &amp; 1)
						doOper(1, i);
				for (int r = 2; r &lt;= 5; ++r) {
					for (int c = 1; c &lt;= 5; ++c)
						if (!t[r - 1][c])
							doOper(r, c);
				}
			} catch (int e) {
				continue;
			}
			int sum = 1;
			for (int i = 1; i &lt;= 5; ++i)
				sum &amp;= t[5][i];
			if (sum)
				ans = std::min(ans, cnt);
		}
		printf(&quot;%d\n&quot;, (ans == 0x3f3f3f3f) ? -1 : ans);
	}
	return 0;
}
</code></pre>
<hr />
<h2><a id="strange-towers-of-hanoi" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Strange Towers of Hanoi</h2>
<p><tc><c>0x0205</c><m>Medium</m><t>递推</t><t>DP</t></tc></p>
<p>求 \(n\) 盘 4 塔的汉诺塔步数。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>考虑 \(n\) 盘 3 塔：</p>
<ul>
<li>\(n-1\) 盘：A \(\to\) B</li>
<li>第 \(n\) 盘：A \(\to\) C</li>
<li>\(n-1\) 盘：B \(\to\) C</li>
</ul>
<p>因此 \(f_3(n)=2 \times f_3(n-1) + 1\)，其中 \(f_3(1)=1\)。可以知道 \(f_3(n)=2^n-1\)。</p>
<p>再考虑 \(n\) 盘 4 塔：</p>
\[f_4(n) \le \min_{1 \le i \lt n} \{2 \times f_4(i) + f_3(n-i)\}
\]
<p>注意此处使用小于等于号。</p>
<p>参照具体数学上证明等于的方法：</p>
<p>我们迟早都必须要移动最下面的那 \(n-i\) 个盘子移动到 D 柱，当我们这么做的时候，上面 \(i\) 个必须已经在某个柱子上。而把下面的这 \(n-i\) 个盘子摆好以后，又要用 \(f_4(i)\) 次移动将上面的盘子放置在它上方（胡言乱语 /tuu）。因此至少需要有 \(\min_{1 \le i \lt n} \{2 \times f_4(i) + f_3(n-i)\}\) 次移动。</p>
\[\therefore f_4(n) = \min_{1 \le i \lt n} \{2 \times f_4(i) + f_3(n-i)\}
\]
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">#define f3(x) ((1 &lt;&lt; (x)) - 1)

int f4[13];

int main() {
    f4[1] = 1;
    for (int x = 2; x &lt;= 12; ++x) {
    	f4[x] = 0x3f3f3f3f;
    	for (int i = 1; i &lt; x; ++i)
    		f4[x] = std::min(f4[x], 2 * f4[i] + f3(x - i));
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x022 分治]]></title>
    <link href="oi.afobject.ml/0x022.html"/>
    <updated>2022-01-15T22:34:54+08:00</updated>
    <id>oi.afobject.ml/0x022.html</id>
    <content type="html"><![CDATA[
<h2><a id="sumdiv" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sumdiv</h2>
<p><tc><c>0x0206</c><c>LG1593</c><m>Medium</m><t>数论</t><t>分治</t><t>快速幂</t></tc></p>
<p>求 \(a^b\) 的因子和 \(\bmod 9901\)。\(a, b \le 5 \times 10^7\)。</p>
<h2><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h2>
<p>假设 \(a = \prod p_i^{c_i}\)，则 \(a^b=\prod p_i^{c_i \times b}\) 因子和为</p>
\[\prod{\sum_{k=0}^{c_i \times b} {p_i}^k}
\]
<p>求个 \(p\) 是 \(\sqrt a\) 级别的，现在要快速求 \(\sum_{k=0}^{c_i \times b} {p_i}^k\)。</p>
<p>考虑使用等比数列求和公式：</p>
\[\begin{aligned}
S&amp;=1+p+p^2+p^3+\cdots+p^k\\
p\cdot S&amp;=p+p^2+p^3+\cdots+p^k+p^{k+1}\\
S&amp;=\frac{p^{k+1}-1}{p-1}
\end{aligned}
\]
<p>但要取模所以不能除啊……</p>
<p>于是，开始分治（\(k \in \mathbb N\)）！</p>
\[\begin{aligned}
\sum_{i=0}^{2k+1}p^i &amp;= \sum_{i=0}^k p^i+ p^{k+1} \cdot \sum_{i=0}^k p^i \\
&amp;=(1+p^{k+1}) \cdot\sum_{i=0}^k p^i\\

\sum_{i=0}^{2k}p^i &amp;= \sum_{i=0}^{k-1} p^i+ p^{k} \cdot \sum_{i=0}^{k-1} p^i+p^{2k} \\
&amp;=(1+p^k) \cdot\sum_{i=0}^{k-1} p^i+p^{2k}
\end{aligned}
\]
<p>拆完了！\(\log\) 时间内可以求到结果。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>随时取模；特判个 \(0\)。</p>
<pre class="line-numbers"><code class="language-cpp">#define MOD 9901

int a, b;
std::map&lt;int, int&gt; m;

int pow(int a, int b, int p = MOD) {
	int ans = 1 % MOD;
	while (b) {
		if (b &amp; 1)
			ans = (ans * a) % MOD;
		a = (a * a) % MOD;
		b &gt;&gt;= 1;
	}
	return ans;
}

int sum(int p, int c) {
	if (c == 0) return 1;
	if (c == 1) return p + 1;
	const int k = c / 2;
	if (c &amp; 1) {
		const int t = (1 + pow(p, k + 1)) % MOD;
		return (t * sum(p, k)) % MOD;
	} else {
		const int t = (1 + pow(p, k)) % MOD;
		return (t * sum(p, k - 1) + pow(p, 2 * k)) % MOD; 
	}
}

int main() {
	a = read(), b = read();
	for (int i = 2; i * i &lt;= a; ) {
		if (a % i == 0)
			++m[i], a /= i;
		else
			++i;
	}
	if (a != 1)
		++m[a];
    if (!a) return puts(&quot;0&quot;), 0;
	int ans = 1;
	for (auto [p, k] : m) {
		ans = (ans * sum(p % MOD, k * b)) % MOD;
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x023 分形]]></title>
    <link href="oi.afobject.ml/0x023.html"/>
    <updated>2022-01-18T08:06:55+08:00</updated>
    <id>oi.afobject.ml/0x023.html</id>
    <content type="html"><![CDATA[
<h2><a id="fractal-streets" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Fractal Streets</h2>
<p><tc><c>0x0207</c><e>Easy+</e><t>递归</t><t>模拟</t><t>数学</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>一个 \(N\) 级城市可以分为 4 个 \(N-1\) 级小城市。以此为依据进行递推。</p>
<p><strong>以城市的中心为原点，建立平面直角坐标系。</strong></p>
<p>首先我们令 \(k = \lfloor \frac {i-1} {4^{n-1}} \rfloor\)（实现的时候所有 \(i\) 自动减一）。\(k=0\) 在第二象限，\(k=1\) 在第一象限，\(k=2\) 在第四象限，\(k=3\) 在第三象限。</p>
<p>以第一、四象限的城市为标准图形。<strong>第二象限的是把标准图形沿 \(y\) 轴翻折然后逆时针旋转 \(90^{\circ}\)</strong>，就能把编号顺序和标准图形对应上，第三象限同理，是<strong>沿 \(y\) 轴翻折然后顺时针旋转 \(90^{\circ}\)</strong>。</p>
<p>设以标准图形求出来的是 \((x,y)\)，\(\Delta = 2^{N-2}\)。</p>
<table>
<thead>
<tr>
<th style="text-align: center">\(k\)</th>
<th style="text-align: center">坐标</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">\(\quad0\quad\)</td>
<td style="text-align: center">\((-y-\Delta,-x+\Delta)\)</td>
</tr>
<tr>
<td style="text-align: center">\(\quad1\quad\)</td>
<td style="text-align: center">\((x+\Delta,y+\Delta)\)</td>
</tr>
<tr>
<td style="text-align: center">\(\quad2\quad\)</td>
<td style="text-align: center">\((x+\Delta,y-\Delta)\)</td>
</tr>
<tr>
<td style="text-align: center">\(\quad3\quad\)</td>
<td style="text-align: center">\((y-\Delta,x-\Delta)\)</td>
</tr>
</tbody>
</table>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>退钱，精度问题卡了巨久，，，</p>
<p>「所有房屋在格子中间」这条有点烦，可以把每个格子长度设为 2，然后房屋在正中间。最后答案乘以 5。</p>
<p>虽然开了 <code>__int128</code> 以后大概不用这样。</p>
<pre class="line-numbers"><code class="language-cpp">#define sq(x) ((x) * (x))
#define int __int128
#define x first
#define y second

int T, n, s, d;

int read() {
    int ans = 0, neg = 1; char ch = getchar();
    while (ch &lt; '0' || ch &gt; '9') { if (ch == '-') neg = -1; ch = getchar(); }
    while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') { ans *= 10; ans += (ch - '0'); ch = getchar(); }
    return ans * neg;
}

std::pair&lt;int, int&gt; solve(int n, int i) {
	if (n == 0) return std::make_pair(0, 0);
	if (n == 1) {
		if (i == 0) return std::make_pair(-1, 1);
		if (i == 1) return std::make_pair(1, 1);
		if (i == 2) return std::make_pair(1, -1);
		if (i == 3) return std::make_pair(-1, -1);
	}
	const int k = i / (1ll &lt;&lt; (2 * n - 2)),
				 r = i % (1ll &lt;&lt; (2 * n - 2)),
				 d = (1ll &lt;&lt; (n - 2)) * 2ll;
	auto a = solve(n - 1, r);
	if (k == 0) return std::make_pair(-a.y - d, -a.x + d);
	if (k == 1) return std::make_pair(a.x + d, a.y + d);
	if (k == 2) return std::make_pair(a.x + d, a.y - d);
	if (k == 3) return std::make_pair(a.y - d, a.x - d);
	return std::make_pair(0, 0);
}

signed main() {
	T = read();
	while (T--) {
		n = read(), s = read(), d = read();
		auto l = solve(n, s - 1), r = solve(n, d - 1);
		printf(&quot;%.0lf\n&quot;, (double)sqrt(sq(r.x - l.x) + sq(r.y - l.y)) * 5);
	}
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x031 前缀和]]></title>
    <link href="oi.afobject.ml/0x031.html"/>
    <updated>2022-01-18T11:54:19+08:00</updated>
    <id>oi.afobject.ml/0x031.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E6%BF%80%E5%85%89%E7%82%B8%E5%BC%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>激光炸弹</h2>
<p><tc><c>0x0301</c><c>HNOI 2003</c><e>Easy</e><t>前缀和</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>使用二维前缀和。</p>
\[\begin{aligned}
&amp;\operatorname{sum}((x_1,y_1),(x_2,y_2)) \\
&amp; =
\operatorname{pre}(x_2,y_2) -
\operatorname{pre}(x_1-1,y_2) -\operatorname{pre}(x_2,y_1-1) +
\operatorname{pre}(x_1-1,y_1-1)
\end{aligned}
\]
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>思维没有任何难度，主要是实现上。题意不清楚，也没解释是什么坐标系。</p>
<ol>
<li>
<blockquote>
<p>若目标位于爆破正方形的边上，该目标不会被摧毁。</p>
</blockquote>
<p>显然对于 \(m\) 没有任何影响。因为目标在整点处，正方形相当于包围着它们的边，只不过加了 \(0.5\) 的 padding。</p>
</li>
<li>
<blockquote>
<p>\(0 \le x_i, y_i \le 5 \times 10^3\)。</p>
</blockquote>
<p>所以区域范围是 \((0,0)\) 到 \((5\times 10^3, 5 \times 10^3)\)。</p>
</li>
</ol>
<p>因此遍历正方形左上角的范围应该是 \((0,0)\) 到 \((5\times10^3-m+1,5\times10^3-m+1)\)。</p>
<p>细节挺多的，除了数组边界问题（其实全 +1 更方便但忘了懒得改了），还有尤其是关于 \(m\) 的那条一开始想对就对了，一开始想错很难发现。所以避免在脑子不清醒时做题！</p>
<pre class="line-numbers"><code class="language-cpp">int n, m;
int pre[5001][5001];

int sum(int x1, int y1, int x2, int y2) {
	return pre[x2][y2] - (x1 ? pre[x1 - 1][y2] : 0) - (y1 ? pre[x2][y1 - 1] : 0) + ((x1 &amp;&amp; y1) ? pre[x1 - 1][y1 - 1] : 0);
}

int main() {
	n = read(), m = read();
	int max = 0;
	while (n--) {
		int x = read(), y = read();
		pre[x][y] += read();
		max = std::max(max, pre[x][y]);
	}
	for (int r = 0; r &lt;= 5000; ++r)
		for (int c = 0; c &lt;= 5000; ++c) {
			if (!r &amp;&amp; !c) continue;
			else if (!r) pre[r][c] += pre[r][c - 1];
			else if (!c) pre[r][c] += pre[r - 1][c];
			else pre[r][c] += pre[r - 1][c] + pre[r][c - 1] - pre[r - 1][c - 1];
		}
	for (int x = 0; x + m - 1 &lt;= 5000; ++x)
		for (int y = 0; y + m - 1 &lt;= 5000; ++y)
			max = std::max(max, sum(x, y, x + m - 1, y + m - 1));
	printf(&quot;%d\n&quot;, max);
	return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x032 差分]]></title>
    <link href="oi.afobject.ml/0x032.html"/>
    <updated>2022-01-19T07:55:42+08:00</updated>
    <id>oi.afobject.ml/0x032.html</id>
    <content type="html"><![CDATA[
<h2><a id="incdec-sequence" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>IncDec Sequence</h2>
<p><tc><c>0x0302</c><e>Easy</e><t>差分</t></tc></p>
<p>给定个长度为 \(n\) 的数列，每次可以选择一个区间同加 \(1\) 或减 \(1\)，要求最终所有数一样，求最小操作次数和满足最小操作次数的方案数。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>比较显然的差分：每次操作是对差分数列 \(c\) 中任两个数一个加 \(1\)，一个减 \(1\)。最终要求差分数组的除第一项、末项均为 \(0\)。</p>
<p>分析一下样例：<code>1 1 2 2 (0)</code></p>
<p>差分数组为：<code>1 0 1 0 -2</code></p>
<p>两种方案为：</p>
<ul>
<li>\(c_1 \gets c_1+1\)，\(c_3 \gets c_3-1\)：<code>2 0 0 0 -2</code></li>
<li>\(c_3 \gets c_3-1,c_5 \gets c_5+1\)：<code>1  0 0 0 -1</code></li>
</ul>
<p>观察到：</p>
<ul>
<li><strong>差分数组的第一个数的种数就是最后数列的种数</strong>；</li>
<li>差分数组的和始终保持为 \(0\)。</li>
</ul>
<h4><a id="%E7%AC%AC%E4%B8%80%E5%B0%8F%E9%97%AE%EF%BC%9A%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第一小问：最小操作次数</h4>
<p>那就是<strong>尽量在 \([2,n]\) 中正、负配对</strong>，配对不过来再考虑用上首项和末项。</p>
<p>令 \(p = \sum_{c=2}^{n} \vert c_i \vert [c_i &lt; 0]\)，\(q = \sum_{c=2}^{n} c_i[c_i &gt;0]\)。</p>
<ol>
<li>能正负配对的对数应该是 \(\min\{p,q\}\)。还不够的，就要拿首、末来凑了。</li>
<li>所以还需要的操作次数是此时的 \(\sum_{c=2}^{n} \vert c_i \vert\)，即 \(\vert p-q \vert\)。</li>
</ol>
<h4><a id="%E7%AC%AC%E4%BA%8C%E5%B0%8F%E9%97%AE%EF%BC%9A%E6%95%B0%E5%88%97%E7%A7%8D%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第二小问：数列种数</h4>
<p>上述第 1 步不会对 \(c_1\) 产生影响，关键是第二步如何消灭中间的数。</p>
<p>其实很容易发现，最终 \(c_1\) 的值域范围是：</p>
<ul>
<li>如果 \([2,n]\) 留下的数全是正数
<ul>
<li>最小：\(c_1-\vert p-q \vert\)。全拿 \(c_1\) 来抵了。</li>
<li>最大：\(c_1\)。不会更多。</li>
</ul>
</li>
<li>如果 \([2,n]\) 留下的全是负数
<ul>
<li>最小：\(c_1\)。</li>
<li>最大：\(c_1+ \vert p-q \vert\)。</li>
</ul>
</li>
</ul>
<p>因此数列种数就是第一小问求得的 \(\vert p-q \vert +1\)。</p>
<p>这波啊，之前为了方便在差分数组末尾加的数也没必要了。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>时间 \(\Theta(n)\)，空间 \(\Theta(1)\)。</p>
<pre class="line-numbers"><code class="language-cpp">#define int long long

int n;
signed main() {
	n = read();
	int p = 0, q = 0, last = 0, c;
	for (int i = 1; i &lt;= n; ++i) {
		c = read() - last, last += c;
		if (i &gt; 1) {
			if (c &gt; 0) p += c;
			else q -= c;
		}
	}
	printf(&quot;%lld\n%lld\n&quot;, std::min(p, q) + abs(p - q), abs(p - q) + 1);
	return 0;
}
</code></pre>
<hr />
<h2><a id="tallest-cow" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Tallest Cow</h2>
<p><tc><c>0x0303</c><c>USACO</c><c>LG2879</c><e>Easy</e><t>差分</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>sb 诈骗题，假设所有牛都最高，然后把每个区间内的牛砍一刀就行了。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>判重。</p>
<pre class="line-numbers"><code class="language-cpp">#define MP std::make_pair

int n, h, r;
int c[100001];

std::set&lt;std::pair&lt;int, int&gt;&gt; s;

signed main() {
	n = read(), h = read(), h = read(), r = read();
	while (r--) {
		int x = read(), y = read();
		if (x &gt; y) std::swap(x, y);
		if (s.find(MP(x, y)) == s.end()) {
			--c[x + 1], ++c[y];
			s.insert(MP(x, y));
		}
	}
	int a = h;
	for (int i = 1; i &lt;= n; ++i) {
		a += c[i];
		printf(&quot;%d\n&quot;, a);
	}
	return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x04 二分]]></title>
    <link href="oi.afobject.ml/0x04-.html"/>
    <updated>2022-01-19T17:24:58+08:00</updated>
    <id>oi.afobject.ml/0x04-.html</id>
    <content type="html"><![CDATA[
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gymucbb50ej30wc0dkabf.jpg" alt="" /></p>
<h2><a id="%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E4%B8%8A%E7%9A%84%E4%BA%8C%E5%88%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>整数集合上的二分</h2>
<p>现在开始更换成主流二分写法：</p>
<pre class="line-numbers"><code class="language-cpp">int l, r;
while (l &lt; r) {
    int mid = (l + r) &gt;&gt; 1;
    if (check(mid)) r = mid;
    else l = mid + 1;
}

while (l &lt; r) {
    int mid = (l + r + 1) &gt;&gt; 1;
    if (check(mid)) l = mid;
    else r = mid - 1;
}
</code></pre>
<p>两种写法中 \(mid\) 部分不同。</p>
<p>我们一定要选取一个正确的 \(mid\) 值，使得<strong>二分过程中任何一组 \((l, r)\) 都不同</strong>。否则，就会陷入死循环。</p>
<p>例如，在 \([2, 3]\) 进行二分：</p>
<ul>
<li>如果我们把 \(mid\) 选在 \(2\)（<code>(2 + 3) &gt;&gt; 1</code>），并且转移是 \(l \gets mid\) 的话，就会陷入死循环；</li>
<li>如果选在 \(3\)（<code>(2 + 3 + 1) &gt;&gt; 1</code>），且转移是 \(r \gets mid\) 的话，也会陷入死循环。</li>
</ul>
<p>因此：</p>
<ul>
<li>但凡选择了 \(l \gets mid + 1\)，\(r \gets mid\)，就必须选择 <code>(l + r) &gt;&gt; 1</code>；</li>
<li>但凡选择了 \(l \gets mid\)，\(r \gets mid - 1\)，就必须选择 <code>(l + r + 1) &gt;&gt; 1</code>。</li>
</ul>
<p>至于转移方式的选择，就要看 \(mid\) 算在右半边还是算在左半边了。</p>
<hr />
<h2><a id="%E4%BA%8C%E5%88%86%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二分的默认值</h2>
<ul>
<li><code>(l + r) &gt;&gt; 1</code> 型二分不会搜到 \(r\)，可以把默认值放在 \(r\) 处。</li>
<li><code>(l + r + 1) &gt;&gt; 1</code> 型二分不会搜到 \(l\)，可以把默认值放在 \(l\) 处。</li>
</ul>
<hr />
<h2><a id="%E5%AE%9E%E6%95%B0%E5%9F%9F%E4%B8%8A%E7%9A%84%E4%BA%8C%E5%88%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实数域上的二分</h2>
<p>可以采取这种方便的写法：</p>
<pre class="line-numbers"><code class="language-cpp">for (int i = 0; i &lt; 100; ++i) {
    double mid = (l + r) / 2;
    if (check(mid)) r = mid;
    else l = mid;
}
</code></pre>
<hr />
<h2><a id="%E4%B8%89%E5%88%86%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三分法</h2>
<p><tc><c>LG3382</c></tc></p>
<p>在 \([l, r]\) 内任意取两个点 \(mid_l, mid_r\)。</p>
<ul>
<li>若前者小于后者，则要么最高点在它们中间，要么在它们右边。\(l \gets mid_l\)。</li>
<li>反之，则 \(r \gets mid_r\)。</li>
</ul>
<p>注意实现时的数据类型应为 <code>double</code>。</p>
<pre class="line-numbers"><code class="language-cpp">for (int i = 1; i &lt;= 1000000; ++i) {
	double lMid = (r - l) / 3 + l;
	double rMid = r - (r - l) / 3;
	if (f(lMid) &lt; f(rMid)) l = lMid;
	else r = rMid;
}
</code></pre>
<hr />
<h2><a id="best-cow-fences" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Best Cow Fences</h2>
<p><tc><c>0x0401</c><c>USACO</c><e>Easy</e><t>二分答案</t><t>前缀和</t></tc></p>
<p>给定正整数数列 \(A\)（\(N \le 10^5\)），求一个平均数最大的、长度不小于 \(L\) 的连续子段。</p>
<h2><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h2>
<p>平均数最大是 naive 套路了，每个数都减去平均数数列和就是 \(0\)。二分的过程中全部减去二分值 \(x\)，如果有区间和是 \(\ge 0\) 的，就说明存在平均数大于 \(\ge x\) 的区间。</p>
<p>然后来个最大子段和（前缀和求法，其中求 \(\max_{j=1}^{i}\operatorname{pre}(j)\) 改为 \(\max_{j=1}^{i-L}\operatorname{pre}(j)\)）操作操作就行了。</p>
<h2><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h2>
<p>卡精度屑题属实没什么意思 /qd</p>
<pre class="line-numbers"><code class="language-cpp">int n, len;
double a[100001], sum[100001];

bool check(double x) {
	double ans = -1e10, min = 1e10;
	for (int i = 1; i &lt;= n; ++i) {
		sum[i] = sum[i - 1] + a[i] - x;
		if (i &gt;= len)
			min = std::min(min, sum[i - len]),
			ans = std::max(ans, sum[i] - min);
	}
	return ans &gt;= 0;
}

signed main() {
	std::cin &gt;&gt; n &gt;&gt; len;
	for (int i = 1; i &lt;= n; ++i)
		std::cin &gt;&gt; a[i];
	double l = -20000001, r = 20000001;
	while (r - l &gt; 1e-5) {
		double mid = (l + r) / 2;
		if (check(mid)) l = mid;
		else r = mid;
	}
	std::cout &lt;&lt; int(r * 1000) &lt;&lt; std::endl;
	return 0;
}
</code></pre>
<hr />
<h2><a id="innovative-business" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Innovative Business</h2>
<p><tc><c>0x0402</c><e>Easy+</e><t>交互</t><t>二分</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>虽然原图不具有传递性但最后的结果具有传递性。所以可以进行二分。二分插入排序的方式。</p>
<p>诈骗题。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>二分没复习到位，调了巨久（悲</p>
<pre class="line-numbers"><code class="language-cpp">
class Solution {
public:
	std::vector&lt;int&gt; specialSort(int n) {
		std::vector&lt;int&gt; ans = {-1, 1}; // -1 占位符。
		for (int i = 2; i &lt;= n; ++i) {
			int l = 0, r = i - 1; // 搜到谁代表插在谁后面。(l + r + 1) &gt;&gt; 1 型二分不会搜到 l，所以用 l 当默认值。
			while (l &lt; r) {
				const int mid = (l + r + 1) &gt;&gt; 1;
				if (compare(i, ans[mid])) r = mid - 1; // i &lt; mid，i 不可能插在 mid 后面，mid 不可能是答案。
				else l = mid; // i &gt; mid，i 可能插在 mid 后面。
			}
			ans.insert(ans.begin() + l + 1, i);
		}
		ans.erase(ans.begin());
		return ans;
	}
} s;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x051 离散化]]></title>
    <link href="oi.afobject.ml/0x051.html"/>
    <updated>2022-01-23T10:52:57+08:00</updated>
    <id>oi.afobject.ml/0x051.html</id>
    <content type="html"><![CDATA[
<p>即把一堆值域巨大的数映射到更小的有限集合中。</p>
<p>一般有以下几个步骤：</p>
<ul>
<li>排序；</li>
<li>去重；</li>
<li>得到原数在去重数组中的排名（第几小）。</li>
</ul>
<pre class="line-numbers"><code class="language-cpp">for (int i = 1; i &lt;= n; ++i)
    b[i] = a[i];
std::sort(b + 1, b + n + 1);
const int c = std::unique(b + 1, b + n + 1) - b;
for (int i = 1; i &lt;= n; ++i)
    printf(&quot;%d &quot;, (int)(std::lower_bound(b + 1, b + c + 1, a[i]) - b));
</code></pre>
<hr />
<h2><a id="cinema" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Cinema</h2>
<p><tc><c>0x0501</c><c>CF670C</c><e>Easy-</e><t>排序</t><t>离散化</t></tc></p>
<p>有 \(n\) 个人和 \(m\) 场电影，一个人只会一种语言，一场电影会有原声语言和字幕语言。选择一场电影，在最大化能理解原声的人数的情况下最大化能理解字幕的人数。</p>
<p>其中语言用 \(1\) 到 \(10^9\) 的数来表示。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>首先离散化语言，并统计每种语言的人数。</p>
<p>把电影按照第一关键字（理解其原声的人数）和第二关键字（理解其字母的人数）排序。当然直接 \(O(n)\) 做也是可以的。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n, m;
std::vector&lt;int&gt; lang;
int a[200001];
int d0[200001], d1[200001], d2[200001];
int buc[600001];

bool comp(int lhs, int rhs) {
    if (buc[d1[lhs]] == buc[d1[rhs]])
        return buc[d2[lhs]] &gt; buc[d2[rhs]];
    return buc[d1[lhs]] &gt; buc[d1[rhs]];
}

int main() {
    n = read();
    for (int i = 1; i &lt;= n; ++i)
        a[i] = read(), lang.push_back(a[i]);
    m = read();
    for (int i = 1; i &lt;= m; ++i)
        d1[i] = read(), lang.push_back(d1[i]);
    for (int i = 1; i &lt;= m; ++i)    
        d2[i] = read(), lang.push_back(d2[i]);
    std::sort(lang.begin(), lang.end());
    auto p = std::unique(lang.begin(), lang.end());
    for (int i = 1; i &lt;= n; ++i)
        ++buc[std::lower_bound(lang.begin(), p, a[i]) - lang.begin()];
    for (int i = 1; i &lt;= m; ++i)
        d0[i] = i,
        d1[i] = std::lower_bound(lang.begin(), p, d1[i]) - lang.begin(),
        d2[i] = std::lower_bound(lang.begin(), p, d2[i]) - lang.begin();
    std::sort(d0 + 1, d0 + m + 1, comp);
    printf(&quot;%d\n&quot;, d0[1]);
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x052 中位数]]></title>
    <link href="oi.afobject.ml/0x052.html"/>
    <updated>2022-01-23T11:45:04+08:00</updated>
    <id>oi.afobject.ml/0x052.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>货仓选址</h2>
<p><tc><c>0x0502</c><e>Easy-</e><t>数学</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>先排序，然后开始「换根」。</p>
<p>假如从建在 \(i\) 处转移到建在 \(i + 1\) 处，则 \(i\) 左边的商店很倒霉，右边的商店获益。反之同理。</p>
<p>最好使得左右商店均衡。</p>
<p>因此如果是奇数就建在中位数处，否则哪怕左右移动 1 毫米就会有超过一半的商店开始叫了。</p>
<p>如果是偶数，同理，建在中间的两个商店的区间内就行了。</p>
<p>答案是排序后的</p>
\[\sum_{i=1}^n \lvert a_i-a_{\lceil \frac n 2 \rceil} \rvert
\]
<hr />
<h2><a id="%E4%B8%83%E5%A4%95%E7%A5%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>七夕祭</h2>
<p><tc><c>0x0503</c><m>Medium+</m><t>前缀和</t><t>数学</t></tc></p>
<p>\(n \times m\) 的方格中，有 \(t\) 个点为「目标点」。通过一定次数的<strong>相邻</strong>上下、左右格内的交换，使得<strong>每行、每列内的目标点数相同</strong>。但这里比较特殊，一行或一列可以看成一个<strong>环</strong>，首行和末行在同一列上的格子可以交换，首列和末列在同一行上的格子可以交换。</p>
<p>求最少的交换次数。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>拆分问题：</p>
<ul>
<li>通过最少次数的左右交换使每列目标点数相同。</li>
<li>通过最少次数的上下交换使每行目标点数相同。</li>
</ul>
<p>这两个互不干涉。</p>
<blockquote>
<h4><a id="%E7%AE%80%E5%8C%96%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>简化问题</h4>
<p>一条长度为 \(n\) 的数组 \(a\)，要求最终每个数都相等。一次操作可以将相邻两个数一个 \(+1\) 一个 \(-1\)，求最小的操作次数。</p>
<hr />
<ul>
<li>首先要求 \(n \mid \sum a_i\)，否则显然无解。</li>
<li>否则，从第一个数开始考虑：
<ul>
<li>如果多了，给 2；</li>
<li>少了，2 给。</li>
</ul>
</li>
<li>同理继续。如果出现负数也无所谓，反正操作顺序可以任意调换。</li>
</ul>
<p>计算答案：</p>
<ul>
<li>由第一个数发起的操作次数为 \(\lvert a_1 - d \rvert\)，其中 \(d = \dfrac{\sum a_i}{n}\)；</li>
<li>由第二个数发起的操作次数为 \(\lvert a_1 + a_2 - 2 \cdot d \rvert\)；</li>
</ul>
<p><strong>总操作次数为 \(\sum\limits_{i=1}^n \lvert \operatorname{pre_a}(i)-i \cdot d \rvert\)。</strong></p>
<p>如果一开始每个人就减去 \(d\)（设减去后的数组为 \(b\)），则<strong>总操作次数就是 \(\sum_\limits{i=1}^n\lvert \operatorname{pre_b}(i)_ \rvert\)。</strong></p>
</blockquote>
<p>与本题的任意一个子问题的区别就在于本题可以成环。很容易想到经典的破环成链，下面来验证正确性。</p>
<p>我们观察到在简化问题中，<strong>即使允许首项和末项之间的操作，也不会对最优结果产生任何影响</strong>。一个数比 \(d\) 多的部分就雷打不动要移走，移走的时候直接顺着 \(1,2,3, \ldots ,n\) 的顺序就行了，没必要非得直接跳到 \(n\)。所以<strong>破环成链</strong>是正确的。</p>
<p>当破环破在第 \(k\) 个数之后时，则长成这样：</p>
<table>
<thead>
<tr>
<th style="text-align: center">转化后的 \(b\) 数组</th>
<th>\(b_{k+1}\)</th>
<th>\(b_{k+2}\)</th>
<th style="text-align: left">\(b_n\)</th>
<th style="text-align: left">\(b_1\)</th>
<th style="text-align: left">\(b_k\)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">前缀和 \(p\) 数组</td>
<td>\(p_{k+1}-p_k\)</td>
<td>\(p_{k+2}-p_k\)</td>
<td style="text-align: left">\(p_n-p_k\)</td>
<td style="text-align: left">\(p_1+p_n-p_k\)</td>
<td style="text-align: left">\(p_n\)</td>
</tr>
</tbody>
</table>
<p>很容易发现，总操作次数是 \(\sum\limits_{i=1}^n \lvert p_i-p_k \rvert\)。</p>
<p>震惊，就是上一题的货仓选址！将 \(p\) 排序后，\(k\) 应取中位数。</p>
<p>神 仙 题！</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>大数据题都开 <code>long long</code>。</p>
<pre class="line-numbers"><code class="language-cpp">#define int long long

#define abs(x) ((x) &gt; 0 ? (x) : -(x))

int n, m, t;
int r[100001], c[100001];

int p[100001];
int solve(int n, int a[]) {
    int sum = 0;
    for (int i = 1; i &lt;= n; ++i)
        sum += a[i];
    if (sum % n)
        return -1;
    const int d = sum / n;
    for (int i = 1; i &lt;= n; ++i)
        p[i] = p[i - 1] + a[i] - d;
    std::sort(p + 1, p + n + 1);
    int ans = 0;
    for (int i = 1; i &lt;= n; ++i)
        ans += abs(p[i] - p[(n + 1) / 2]);
    return ans;
}

signed main() {
    n = read(), m = read(), t = read();
    while (t--)
        ++r[read()], ++c[read()];
    int x = solve(n, r), y = solve(m, c);
    if (x == -1 &amp;&amp; y == -1) puts(&quot;impossible&quot;);
    else if (x == -1) printf(&quot;column %lld\n&quot;, y);
    else if (y == -1) printf(&quot;row %lld\n&quot;, x);
    else printf(&quot;both %lld\n&quot;, x + y);
    return 0;
}
</code></pre>
<hr />
<h2><a id="running-median" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Running Median</h2>
<p><tc><c>0x0503</c><e>Easy</e><t>对顶堆</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>维护两个堆（<code>std::priority_queue</code>），第一个大根堆维护 \(1 \sim \lfloor \dfrac n 2 \rfloor\)，第二个小根堆维护  \(\lfloor \dfrac n 2 \rfloor + 1 \sim n\)。第二个堆的首项为中位数。</p>
<p>当任意一个堆的个数超了的时候，移到另外一个去。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">void solve() {
    std::priority_queue&lt;int, std::vector&lt;int&gt;, std::less&lt;int&gt;&gt; q1;
    std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt; q2;
    int x = read();
    q2.push(x), printf(&quot;%d &quot;, x);
    for (int i = 2; i &lt;= n; ++i) {
        int x = read();
        if (x &lt; q2.top()) q1.push(x);
        else q2.push(x);
        if (q1.size() &gt; (i &gt;&gt; 1))
            q2.push(q1.top()), q1.pop();
        if (q2.size() &gt; (i + 1) &gt;&gt; 1)
            q1.push(q2.top()), q2.pop();
        if (i &amp; 1)
            printf(&quot;%d &quot;, q2.top());
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x053 快速排序与 kth-element]]></title>
    <link href="oi.afobject.ml/0x053.html"/>
    <updated>2022-01-24T20:02:17+08:00</updated>
    <id>oi.afobject.ml/0x053.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>快速排序</h2>
<p><tc><c>LG1177</c></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>在区间内 rand 一个数，比它小的放左边，大的放右边。</p>
<p>可以使用三路快速排序的优化：分为 <strong>小于基准｜等于基准｜大于基准</strong> 三类。</p>
<h3><a id="%E4%B8%89%E8%B7%AF%E4%BC%98%E5%8C%96%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三路优化实现</h3>
<pre class="line-numbers"><code class="language-cpp">void qSort(int l, int r) {
    if (l &gt;= r) return;

    int s = a[(l + r) / 2];
    int x = l, y = l, z = r;
    // y：左侧指针  z：右侧指针
    // x：存数指针
    while (y &lt; z + 1) {
        if (a[y] &lt; s) std::swap(a[x++], a[y++]); // 左侧指针数合法，入库
        else if (a[y] &gt; s) std::swap(a[z--], a[y]); // 左侧指针数不合法，右边调一个过来，咕着下一轮循环再检查
        else ++y; // 左侧指针数卡线，放过
    }
    // 循环结束：
    // 所有小于 s 的数都被压在了 [l, x);
    // 所有大于 s 的数都被压在了 (z, r]。
    
    qSort(l, x - 1);
    qSort(z + 1, r);
}
</code></pre>
<hr />
<h2><a id="kth-element" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>kth-element</h2>
<p><tc><c>LG1923</c></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>快排排一半。</p>
<h3><a id="%E4%B8%89%E8%B7%AF%E4%BC%98%E5%8C%96%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三路优化实现</h3>
<p>注意一些细节。</p>
<pre class="line-numbers"><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

int n, k, a[5000001];

int read() {
    int ans = 0, neg = 1; char ch = getchar();
    while (ch &lt; '0' || ch &gt; '9') { if (ch == '-') neg = -1; ch = getchar(); }
    while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') { ans *= 10; ans += (ch - '0'); ch = getchar(); }
    return ans * neg;
}

int kthElement(int l, int r, int k) {
    if (l &gt;= r) return a[l];

    int s = a[(l + r) / 2];
    int x = l, y = l, z = r;

    while (y &lt; z + 1) {
        if (a[y] &lt; s) std::swap(a[x++], a[y++]);
        else if (a[y] &gt; s) std::swap(a[z--], a[y]);
        else ++y;
    }
    
    if (l + k - 1 &lt; x) return kthElement(l, x - 1, k);
    else if (l + k - 1 &gt; z) return kthElement(z + 1, r, l + k - 1 - z);
    else return s;
}

int main() {
    n = read(), k = read() + 1;
    for (int i = 1; i &lt;= n; ++i)
        a[i] = read();
    printf(&quot;%d\n&quot;, kthElement(1, n, k));
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x054 逆序对]]></title>
    <link href="oi.afobject.ml/0x054.html"/>
    <updated>2022-02-17T22:48:13+08:00</updated>
    <id>oi.afobject.ml/0x054.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>归并排序求逆序对</h2>
<p><tc><c>LG1908</c></tc></p>
<pre class="line-numbers"><code class="language-cpp">int ans = 0;
void mergeSort(int l, int r) {
    if (l &gt;= r) return;
    const int mid = (l + r) &gt;&gt; 1;
    mergeSort(l, mid);
    mergeSort(mid + 1, r);

    int p = l, pl = l, pr = mid + 1;
    while (pl &lt;= mid &amp;&amp; pr &lt;= r)
        if (a[pl] &lt;= a[pr]) t[p++] = a[pl++];
        else t[p++] = a[pr++], ans += mid - pl + 1;
    while (pl &lt;= mid) t[p++] = a[pl++];
    while (pr &lt;= r) t[p++] = a[pr++];
    for (int i = l; i &lt;= r; ++i) a[i] = t[i];
}
</code></pre>
<hr />
<h2><a id="ultra-quicksort" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Ultra-QuickSort</h2>
<p><tc><c>0x0505</c><e>Easy-</e><t>逆序对</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>大眼观察答案就是逆序对。</p>
<p>一次交换少一个逆序对，啊对对对，显然有构成逆序对的相邻的两个。</p>
<hr />
<h2><a id="%E5%A5%87%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>奇数码问题</h2>
<p><tc><c>0x0506</c><m>Medium</m><t>逆序对</t></tc></p>
<p>给两个 \(n \times n\) 的数字华容道，问一个能否变成另外一个。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>先忽略 0 把这俩写成一串数（8 个）；</p>
<ul>
<li>若左右移动 0 的位置，则这串数不变；</li>
<li>若上下移动 0 的位置，则相当于将一个数后移 \(n-1\) 个位置。</li>
</ul>
<p>上下移动的操作中逆序对的个数的奇偶性不会改变（这个数与 \(n-1\) 个数发生了相对位置改变，每处相对位置改变会增加或减少一个逆序对，而 \(n-1\) 是偶数）。</p>
<p>因此这两串数逆序对个数的奇偶性相同是<strong>必要</strong>的。充分性猜一下大概是可以找出一种移动 0 的方案的。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">signed main() {
    while (std::cin &gt;&gt; n) {
        for (int i = 1, j = 1; i &lt;= n * n; ++i) {
            std::cin &gt;&gt; a[j];
            if (a[j]) ++j;
        }
        int ans1 = mergeSort(1, n * n - 1);
        for (int i = 1, j = 1; i &lt;= n * n; ++i) {
            std::cin &gt;&gt; a[j];
            if (a[j]) ++j;
        }
        int ans2 = mergeSort(1, n * n - 1);
        puts(((ans1 - ans2) % 2) ? &quot;NIE&quot; : &quot;TAK&quot;);
    }
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x06 倍增]]></title>
    <link href="oi.afobject.ml/0x06-.html"/>
    <updated>2022-02-19T13:19:02+08:00</updated>
    <id>oi.afobject.ml/0x06-.html</id>
    <content type="html"><![CDATA[
<p>倍增：将状态空间划分成若干个 2 的次幂的大小。</p>
<h2><a id="%E9%93%BA%E5%9E%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>铺垫</h2>
<p>给定一个数列 \(A\) 和若干次询问，每次给出一个 \(T\)，求 \(k_{\max}\ s.t.\ \sum_{i=1}^k \le T\)。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<h4><a id="%E6%96%B9%E6%A1%881%EF%BC%9A%E5%9C%A8%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%AD-naive%E4%BA%8C%E5%88%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>方案 1：在前缀和中 naive 二分</h4>
<p>复杂度恒定是 <strong>\(\log n\)</strong> 把大概。</p>
<h4><a id="%E6%96%B9%E6%A1%882%EF%BC%9A%E5%80%8D%E5%A2%9E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>方案 2：倍增</h4>
<p>这个 \(k\) 是要找的这个前缀的长度，<strong>每次尝试往 \(k\) 里面加 \(2\) 的次幂（\(2^p\)）</strong> 就行了。如果加了以后符合要求那么 \(k \gets k + 2^p\)，\(p \gets p+1\)，否则不加且 \(p \gets p - 1\)。\(p &lt; 0\) 的时候结束。</p>
<p>区别就是复杂度是 <strong>\(\log \text{答案}\)</strong> 差不多。这玩意相对于 \(\log\) 感觉有一定常数（差不多 3）。我也不清楚为什么要这么做。就是这样。</p>
<p>感觉有一种平凡优化这里不写了。</p>
<hr />
<h2><a id="genius-acm" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Genius ACM</h2>
<p><tc><c>0x0601</c><h>Hard</h><t>数学</t><t>排序</t><t>倍增</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>首先 \(\sum\limits_{i=1}^{m}(a_i - b_i)^2 = \sum\limits_{i=1}^{m} a_i^2 + \sum\limits_{i=1}^{m} b_i^2 -\sum\limits_{i=1}^{m} a_i b_i\)，所以要使两两的乘积最小。</p>
<blockquote>
<h4><a id="%E6%8E%92%E5%BA%8F%E4%B8%8D%E7%AD%89%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>排序不等式</h4>
<ol>
<li>给定 \(a,b\) 两个数列，证明：当 \(a_i,b_i\) 均不降时，\(\sum a_ib_i\) 最大。</li>
</ol>
<p>简略证明：</p>
<ul>
<li>假设 \(x_1\le x_2,x_3 \le x_4\)，由于 \((x_1-x_2)(x_3-x_4) \ge 0\)，则 \(x_1x_4+x_2x_3 \ge x_1x_3+x_2x_4\)（1）。</li>
<li>假定 \(a\) 不降，且 \(b\) 乱序（非单调不降），设存在 \(b_i, b_j\) 乱序，且它们分别对应 \(a_i, a_j\)（\(b_i&gt;b_j\)，\(a_i &lt; a_j\)）由（1），\(b_i a_j + b_ja_i&gt;b_ia_i + b_ja_j\)，将 \(b_i, b_j\) 交换结果更优。不断交换直到 \(b\) 不降，结果最优。</li>
<li>假定 \(b\) 不降，且 \(a\) 乱序（非单调不降），同理。</li>
</ul>
<p>所以要求 \(a,b\) 均不降。</p>
<hr />
<ol start="2">
<li>在（1）的条件下，当 \(a,b\) 中的一个倒序时，证明：此时 \(\sum a_ib_i\) 最小。</li>
</ol>
<p>简略证明：</p>
<ul>
<li>假定 \(a\) 不降，且 \(b\) 乱序（非单调不升），设存在 \(b_i, b_j\) 非逆序，且它们分别对应 \(a_i, a_j\)（\(b_i&lt;b_j\)，\(a_i &lt; a_j\)）由（1），\(b_i a_j + b_ja_i &lt; b_ia_i + b_ja_j\)，将 \(b_i, b_j\) 交换结果更优。不断交换直到 \(b\) 不升，结果最优。</li>
<li>假定 \(b\) 不降，且 \(a\) 乱序（非单调不升），同理。</li>
<li>得证。</li>
</ul>
</blockquote>
<p>由<strong>排序不等式</strong>，知应当最大对最大，第二大对第二大……最小对最小，此时的 \(\sum (a_i-b_i)^2\) 就是「校验值」。</p>
<p>但这并不是重点。</p>
<p>问题转化为固定一个 \(L\)，求最小的 \(R &gt; L\) 使得 \(f([L, R]) \le T\)。要求「校验值」，必须排序，至少用时 \(O(n \log n)\)。然后 \(n \le 5 \times 10^5\)，好好好，如果每段都很少那么二分屁用没有（\(n\) 级别段，每一段找 \(R\) 二分 \(\log n\) 次总排序 \(n \log n\) 级，感觉得卡成 \(n^2 \log n\)，寄了）。</p>
<p>😅 倍增，固定一个左端点往右扩展，复杂度 \(\sum len \log len\)（块数次倍增，每次倍增对一段排序，排序的总时间 \(n \log n\)，归并以及计算「校验值」的总时间差不多 \(O(n)\) 带点常数）左右吧，总复杂度大约 \(n \log n\) 可以接受（吧），自带巨大常数但是时限 10s。</p>
<blockquote>
<p>776 告诉我 \(\sum len \log len \le n \log n\)。</p>
</blockquote>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<ol>
<li>固定一个 \(l\)</li>
<li>倍增求 \(r\)
<ol>
<li>对未排序的部分进行归并排序</li>
<li>求出「校验值」</li>
<li>根据「校验值」大小判断当前的 \(r\) 是否满足条件</li>
<li>回到 1，直到倍增结束（\(p=0\)）</li>
</ol>
</li>
<li>回到 1，直到得到结果（\(r=n\)）</li>
</ol>
<p>谢邀，人在太平间，写吐了</p>
<pre class="line-numbers"><code class="language-cpp">#define int long long

int T, n, m, k;
// a 原数组不动
// t 是排好序的
// q 是辅助
// copy 是缓存
int a[5000001], t[5000001], q[5000001], copy[5000001];

void mergeSort(int l0, int l, int r) {
    r = std::min(r, n);
    for (int i = l; i &lt;= r; ++i)
        t[i] = a[i];
    
    std::sort(t + l, t + r + 1);

    int lp = l0, tp = l0, rp = l;
    while (lp &lt; l &amp;&amp; rp &lt;= r)
        if (t[lp] &lt; t[rp]) q[tp++] = t[lp++];
        else q[tp++] = t[rp++];
    while (lp &lt; l) q[tp++] = t[lp++];
    while (rp &lt;= r) q[tp++] = t[rp++];

    for (int i = l0; i &lt;= r; ++i)
        t[i] = q[i];
}

int captcha(int l, int r) {
    r = std::min(r, n);
    int ans = 0;
    for (int i = 0; i &lt; m &amp;&amp; l &lt; r; ++i, --r, ++l)
        ans += (t[r] - t[l]) * (t[r] - t[l]);
    return ans;
}

signed main() {
    T = read();
    while (T--) {
        n = read(), m = read(), k = read();
        for (int i = 1; i &lt;= n; ++i)
            a[i] = read();
        int l0 = 1, ans = 0; // 1
        while (l0 &lt;= n) {
            int l = l0, p = 1; bool r = false;
            while (p) {
                for (int i = l0; i &lt; l + p; ++i)
                    copy[i] = t[i]; // 保存当前的快照，以在 c &gt; k 时得以返回上一状态
                mergeSort(l0, l, l + p - 1); // 2.1
                const int c = captcha(l0, l + p - 1); // 2.2
                if (c &lt;= k) { // 2.3
                    l += p;
                    if (l &gt; n) break; // 2.4
                    if (!r)
                        p &lt;&lt;= 1;
                } else {
                    p &gt;&gt;= 1;
                    r = true;
                    for (int i = l0; i &lt; l + p; ++i)
                        t[i] = copy[i];
                }
            }
            ++ans;
            l0 = l;
        }
        printf(&quot;%lld\n&quot;, ans); // 3
    }
}
</code></pre>
<hr />
<h2><a id="st%E8%A1%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ST 表</h2>
<p><tc><c>LG3865</c></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>\(f(l,k)\) 为 \([l, l + 2^k)\) 的 \(\max\)。</p>
<ul>
<li>\(\forall i, f(i,0) = a_i\)。</li>
<li>\(f(l,k) = \max\{f(l,k-1),f(l+2^{k-1},k-1)\}\)</li>
</ul>
<p>求和：令 \(k=\log_2(r-l+1)\)。</p>
<p>\(f(l,r) = \max\{f(l,k),f(r-2^k+1,k)\}\)（这两个区间能覆盖 \([l, r]\)）。</p>
<p>最小值同理。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现（最大值）</h3>
<pre class="line-numbers"><code class="language-cpp">int n, q;
int f[5000001][31];

int query(int l, int r) {
    const int k = log2(r - l + 1);
    return std::max(f[l][k], f[r - (1 &lt;&lt; k) + 1][k]);
}

void cal() {
    for (int i = 1; i &lt;= n; ++i)
        f[i][0] = read();
    for (int k = 1; k &lt;= 30; ++k)
        for (int i = 1; i + (1 &lt;&lt; (k - 1)) &lt;= n; ++i)
            f[i][k] = std::max(f[i][k - 1], f[i + (1 &lt;&lt; (k - 1))][k - 1]);
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x07 贪心]]></title>
    <link href="oi.afobject.ml/0x07-.html"/>
    <updated>2022-03-18T15:15:46+08:00</updated>
    <id>oi.afobject.ml/0x07-.html</id>
    <content type="html"><![CDATA[
<h2><a id="sunscreen" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sunscreen</h2>
<p><tc><c>0x0701</c><c>USACO</c><e>Easy+</e><t>贪心</t><t>排序</t></tc></p>
<p>有 \(n\) 头牛，每头牛能忍受一个区间范围的阳光，然后有 \(m\) 瓶防晒霜，每瓶防晒霜能让一头牛身上的阳光变成一个定值，现在最大化能忍受阳光的奶牛数。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>我们的贪心策略一定是对于每一头牛：</p>
<ul>
<li>尽量能匹配到它的防晒霜</li>
<li>在有多个匹配时选择最不影响其他牛的匹配</li>
<li>如果非得因为这头牛然后让其他牛寄，也没问题，因为每头牛的权值都是 1。</li>
</ul>
<p>对于第二条，考虑给高高在上的牛上牛就匹配值高的防晒霜，把值小的防晒霜留给下面的牛用（没被上面的牛用的一定能满足下面的牛的最小值，如果超过了它的最大值只能怪它自己，我已经把尽量小的留给你了）。</p>
<p>这种策略事正确的。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>将牛按区间起始值排序，防晒霜按值排序，均从大到小。每一头你从防晒霜中找第一个能被它用的，然后下一个。</p>
<pre class="line-numbers"><code class="language-cpp">int n, m;
std::pair&lt;int, int&gt; cow[100001], sun[100001];

int main() {
    n = read(), m = read();
    for (int i = 1; i &lt;= n; ++i)
        cow[i].first = read(), cow[i].second = read();
    for (int i = 1; i &lt;= m; ++i)
        sun[i].first = read(), sun[i].second = read();
    std::sort(cow + 1, cow + n + 1, std::greater&lt;std::pair&lt;int, int&gt;&gt;());
    std::sort(sun + 1, sun + m + 1, std::greater&lt;std::pair&lt;int, int&gt;&gt;());
    int ans = 0;
    for (int i = 1; i &lt;= n; ++i)
        for (int j = 1; j &lt;= m; ++j)
            if (sun[j].second &amp;&amp; cow[i].first &lt;= sun[j].first &amp;&amp; sun[j].first &lt;= cow[i].second) {
                ++ans;
                --sun[j].second;
                break;
            }
    printf(&quot;%d\n&quot;, ans);
    return 0;
}
</code></pre>
<hr />
<h2><a id="stall-reservations" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Stall Reservations</h2>
<p><tc><c>0x0702</c><c>USACO</c><e>Easy</e><t>贪心</t><t>排序</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>萌萌题黄够了吧，和 廊桥分配 一个套路。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>区间有重复用 <code>std::multiset</code>。</p>
<pre class="line-numbers"><code class="language-cpp">int n;
struct Cow {
    int id, start, end;
    bool operator &lt; (const Cow &amp;rhs) const {
        if (start == rhs.start) {
            if (end == rhs.end)
                return id &lt; rhs.id;
            return end &lt; rhs.end;
        }
        return start &lt; rhs.start;
    }
};
std::multiset&lt;Cow&gt; s;
int ans[500001];

int main() {
    n = read();
    for (int i = 1; i &lt;= n; ++i) {
        int a = read(), b = read();
        s.insert({i, a, b});
    }
    int idx = 0;
    while (s.size()) {
        auto f = *s.begin();
        s.erase(s.begin());
        ans[f.id] = ++idx;
        int end = f.end;
        auto it = s.lower_bound({0, end + 1, 0});
        while (it != s.end()) {
            ans[it-&gt;id] = idx;
            end = it-&gt;end;
            s.erase(it);
            it = s.lower_bound({0, end + 1, 0});
        }
    }
    printf(&quot;%d\n&quot;, idx);
    for (int i = 1; i &lt;= n; ++i)
        printf(&quot;%d\n&quot;, ans[i]);
    return 0;
}
</code></pre>
<hr />
<h2><a id="radar-installation" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Radar Installation</h2>
<p><tc><c>0x0703</c><m>Medium-</m><t>贪心</t><t>计算几何</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>从左到右考虑每一个点。对于每一个点，找到一个最右侧的能包含它圆。如果下一个点在先前所列的某个圆的范围内，包含进去。否则，/remake。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0fmiygnkxj218p0r5goc.jpg" alt="" /><br />
但这种方案还要再细化。如上图，「包含」关系时，就应该更新圆心往里缩一点，「继承」关系维持不变即可，「脱离」关系自然答案就应该加一。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">#define int long long
#define AVA 100000

int n, d;

struct Pos {
    int x, y, l, r;
    bool operator &lt; (const Pos &amp;rhs) const {
        if (l == rhs.l)
            return r &lt; rhs.r;
        return l &lt; rhs.l;
    }
} p[100001];

int dist(Pos a, Pos b) {
    return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);
}

signed main() {
    n = read(), d = read() * AVA;
    for (int i = 1; i &lt;= n; ++i) {
        p[i].x = read() * AVA, p[i].y = read() * AVA;
        const int k = (int)sqrt(d * d - p[i].y * p[i].y);
        p[i].l = p[i].x - k, p[i].r = p[i].x + k;
    }
    std::sort(p + 1, p + n + 1);
    int ans = 0, pos = -100000000000;
    for (int i = 1; i &lt;= n; ++i) {
        if (p[i].y &gt; d) {
            puts(&quot;-1&quot;);
            return 0;
        }
        if (p[i].l &gt; pos) ++ans, pos = p[i].r;
        else pos = std::min(pos, p[i].r);
    }
    printf(&quot;%lld\n&quot;, ans);
    return 0;
}
</code></pre>
<hr />
<h2><a id="%E5%9B%BD%E7%8E%8B%E6%B8%B8%E6%88%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>国王游戏</h2>
<p><tc><c>0x0704</c><c>NOIP 2012</c><m>Medium+</m><t>贪心</t><t>数学</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>考虑猜个结论，左右手两数乘积大的排后面。现在试图证明。</p>
<p>对于相邻的两个大臣，获得的奖励就是 \(c_1=\lfloor \dfrac{\prod_{i=0}^{x-1} a_i}{b_x} \rfloor\) 和 \(c_2=\lfloor \dfrac{\prod_{i=0}^{x} a_i}{b_{x+1}} \rfloor\)。</p>
<p>假如对于 \(x\) 与 \(x+1\) 位进行一个交换，获得的奖励就是 \(d_1=\lfloor \dfrac{(\prod_{i=0}^{x-1} a_i) \times a_{x+1}}{b_x} \rfloor\) 和 \(d_2=\lfloor \dfrac{\prod_{i=0}^{x-1} a_i}{b_{x+1}} \rfloor\)。</p>
<p>（先忽略向下取整）现在我们要比较 \(\max\{c_1, c_2\}\) 和 \(\max\{d_1, d_2\}\) 的大小关系。</p>
<p>提取公因式 \(\prod_{i=0}^{x-1}a_i\)，我们要比较的就是 \(\max\left\{\dfrac{1}{b_x}, \dfrac{a_x}{b_{x+1}}\right\}\) 和 \(\max\left\{\dfrac{a_{x+1}}{b_x}, \dfrac{1}{b_{x+1}}\right\}\) 的关系。</p>
<p>统乘以 \(b_x \cdot b_{x+1}\)，比较 \(\max\{b_{x+1}, a_x \cdot b_x\}\) 与 \(\max\{b_x, a_{x+1} \cdot b_{x+1}\}\) 的大小关系。</p>
<p>显然 \(a_x \cdot b_x  \ge b_x\)，\(a_{x+1} \cdot b_{x+1} \ge b_{x+1}\)，所以就是比较 \(a_x \cdot b_x\) 与 \(a_{x+1} \cdot b_{x+1}\)，\(a_x \cdot b_x\) 大则交换前大，反之交换后大。得证。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>贺题解。</p>
<pre class="line-numbers"><code class="language-py">n = int(input())
a, b = map(int, input().split())
w = []
for i in range(n):
    c, d = map(int, input().split())
    w.append([c, d])
w.sort(key=lambda x: (x[0] * x[1]))
ans = 0
for i in range(n):
    ans = max(ans, a // w[i][1])
    a *= w[i][0]
print(ans)
</code></pre>
<hr />
<h2><a id="color-a-tree" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Color a Tree</h2>
<p><tc><c>0x0703</c><m>Medium+</m><t>贪心</t><t>树</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>注意到对于树中权值最大的点，它一定是在它父亲被染色之后立即被染色的。于是就可以把它和它父亲连成一个点。</p>
<p>连了以后权值变为它们的平均数，非常神奇。</p>
<p>举例，三个点 \(x,y,z\)，其中 \(x,y\) 同时染色。</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>代价</th>
</tr>
</thead>
<tbody>
<tr>
<td>先 \(z\) 再 \(x,y\)</td>
<td>\(a=z+2x+3y\)</td>
</tr>
<tr>
<td>先 \(x,y\) 再 \(z\)</td>
<td>\(b=x+2y+3z\)</td>
</tr>
</tbody>
</table>
<p>我们的目的是比较 \(a,b\) 的大小。作差，得 \(x+y-2z\)。因此，当 \(z \le \dfrac{x+y}2\) 的时候，先染 \(z\) 更优。所以 \(x,y\) 两个点其实等价于它们的平均值。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ABC236]]></title>
    <link href="oi.afobject.ml/abc236.html"/>
    <updated>2022-01-23T20:24:58+08:00</updated>
    <id>oi.afobject.ml/abc236.html</id>
    <content type="html"><![CDATA[
<p>Rated, 4/8, 776 \(\to\) 977</p>
<h2><a id="e-average-and-median" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>E Average and Median</h2>
<p><tc><m>Medium *1893</m><t>DP</t><t>二分</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>显然二分。</p>
<p>判断是否存在平均数 \(k\)：每个数减去 \(k\)，判总和是否大于 0。</p>
<p>判断是否存在中位数 \(k\)：一个数如果 \(\ge k\) 则是 \(1\)，否则 \(-1\)，判总和大于 0。</p>
<p>由于有这个相邻二选一的该死限制所以只能进行 DP。</p>
<p>考虑设 \(f(i)\) 为前 \([1,i]\) 中选择 \(i\) 时的最大的和。</p>
\[\begin{aligned}
f(0)&amp;=0\\
f(i)&amp;=\max\{f(i-2), f(i-1)\} + a_i
\end{aligned}
\]
<p>时间复杂度 \(O(n \log n)\)。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>爆 ll 警告。</p>
<pre class="line-numbers"><code class="language-cpp">#define AVA 10000
#define int __int128

int n;
int a[100001], f[100001];

bool judgeMedian(int x) {
    f[1] = (a[1] &gt;= x) ? 1 : -1;
    for (int i = 2; i &lt;= n; ++i)
        f[i] = std::max(f[i - 2], f[i - 1]) + ((a[i] &gt;= x) ? 1 : -1);
    return std::max(f[n], f[n - 1]) &gt; 0;
}

bool judgeAverage(int x) {
    f[1] = a[1] - x;
    for (int i = 2; i &lt;= n; ++i)
        f[i] = std::max(f[i - 2], f[i - 1]) + a[i] - x;
    return std::max(f[n], f[n - 1]) &gt;= 0;
}

signed main() {
    n = read();
    for (int i = 1; i &lt;= n; ++i)
        a[i] = read() * AVA;
    int l = 1, r = 1e15;
    while (l &lt; r) {
        const int mid = (l + r + 1) &gt;&gt; 1;
        if (judgeAverage(mid)) l = mid;
        else r = mid - 1;
    }
    printf(&quot;%.4lf\n&quot;, (double)l / AVA);
    l = 1, r = 1e15;
    while (l &lt; r) {
        const int mid = (l + r + 1) &gt;&gt; 1;
        if (judgeMedian(mid)) l = mid;
        else r = mid - 1;
    }
    printf(&quot;%lld\n&quot;, (long long)(l / AVA));
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces Round #773 (Div.2)]]></title>
    <link href="oi.afobject.ml/cf1642.html"/>
    <updated>2022-02-28T22:52:43+08:00</updated>
    <id>oi.afobject.ml/cf1642.html</id>
    <content type="html"><![CDATA[
<p>Rated, 3/6, 1353 \(\to\) 1448</p>
<h2><a id="cf1641b-1642d-repetitions-decoding" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CF1641B (1642D) Repetitions Decoding</h2>
<p><tc><m>Medium *2000</m><t>构造</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>场上思路：找到第一个 \(i\) 使得 \(a_i=a_1\)（例如 <code>ABCDADBC</code>）。在 \(i\) 后面插入 <code>ABCDDCBA</code> 这种形式的一串（<code>ABCDABCDDCBDBC</code>），然后发现前面可以消，只剩 <code>DCBDBC</code>。这个序列相较于原序列长度少 \(2\)，完全可行，操作次数也肉眼可见地不会太多。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>随便开个 STL 模拟。</p>
<pre class="line-numbers"><code class="language-cpp">
#define MP std::make_pair

int T, n;
std::vector&lt;int&gt; a;
std::map&lt;int, int&gt; m;

std::vector&lt;std::pair&lt;int, int&gt;&gt; op;
std::vector&lt;int&gt; v;

void solve(int d) {
    if (a.size() &lt;= 1)
        return;

    int pos = 0, len = 0;
    for (int i = 2; i &lt; a.size(); ++i)
        if (a[i] == a[1]) {
            pos = i;
            len = pos - 1;
            break;
        }

    for (int i = pos; i &lt; pos + len - 1; ++i)
        op.push_back(MP(i + d, a[i - len + 1]));
    v.push_back(len &lt;&lt; 1);

    a.erase(a.begin() + pos);
    a.erase(a.begin() + 1);
    for (int i = 1, j = pos - 2; i &lt;= j; ++i, --j)
        std::swap(a[i], a[j]);

    solve(d + (len &lt;&lt; 1));
}

int main() {
    T = read();
    while (T--) {
        n = read();
        m = std::map&lt;int, int&gt;();
        a = std::vector&lt;int&gt;();
        op = std::vector&lt;std::pair&lt;int, int&gt;&gt;();
        v = std::vector&lt;int&gt;();
        a.resize(n + 1);

        for (int i = 1; i &lt;= n; ++i)
            a[i] = read(), ++m[a[i]];
        bool flag = true;
        for (auto [x, y] : m)
            if (y &amp; 1)
                flag = false;
        if (!flag) {
            puts(&quot;-1&quot;);
            continue;
        }
        solve(0);
        printf(&quot;%d\n&quot;, (int)op.size());
        for (auto [x, y] : op)
            printf(&quot;%d %d\n&quot;, x, y);
        printf(&quot;%d\n&quot;, (int)v.size());
        for (int len : v)
            printf(&quot;%d &quot;, len);
        putchar('\n');
    }
    return 0;
}
</code></pre>
<hr />
<h2><a id="cf1641c-1642e-anonymity-is-important" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CF1641C (1642E) Anonymity Is Important</h2>
<p><tc><m>Medium+ *2200</m><t>DS</t><t>线段树</t><t>STL</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>「1」型区间为至少包含一个病人的区间，「0」型区间为不包含病人的区间。</p>
<ul>
<li>回答 <code>NO</code>：\(x\) 号病人包含在任意一个「0」区间中。</li>
<li>回答 <code>YES</code>：\(x\) 号病人包含且仅包含在「1」区间中，且<strong>存在一个包含它的「1」区间，使得除了它以外的所有病人都在「0」区间</strong>。</li>
<li>回答 <code>N/A</code>：不属于以上两种情况。</li>
</ul>
<p>接下来我们用 C 表示确定不是病人，U 表示不确定是否是病人的人。</p>
<p>一开始的数列一定是 <code>UUUU...UUU</code>。当报告一个区间内没有病人时，数列会变成类似这样：<code>UUCC...CCUUUU</code>。</p>
<p>接下来考虑 <code>YES</code> 情况的维护。通俗一点来讲，显然当一个 U 周围也是 U 的时候，就很难确定它；当一个 U 左右都是 C 时，确定它是否是病人就更容易一些。进一步思考，可以发现：</p>
<pre class="line-numbers"><code class="language-plain_text">...UUUCCCCCCUCCCCCUUU....
      o     ^    o
</code></pre>
<p>假设被 <code>^</code> 标记的 U 是我们的研究对象。当且仅当在<strong>它以及它左右 C 的连续段（两个 <code>o</code> 标记中间）中</strong>，存在一个包含这个 U 的「1」区间，U 才可以被确定为病人。</p>
<p>如果将所有的 U 用 <code>std::set</code> 维护，那么这就很简单了，直接就找中间那个 U（设其下标为 \(x\)）的前驱后继（设它们的下标为 \(l,r\)）即可。接下来，需要判定上述的区间是否存在。可以发现区间的左端点一定是在 U 左边那个 C 的连续段，因此<strong>只要存在一个以 \((l,x]\) 为起点的「1」区间，其右端点在 \([x, r)\)，那么 \(x\) 就确定是病人</strong>。</p>
<p>这部分可以使用一个单点修改、区间查询最小值的线段树 \(t\) 来维护。当输入一个「1」区间时，将 \(t_l\) 单点赋值为 \(\min\{t_l, r\}\) 即可。查询时判断 \(\operatorname{query}(l+1,x)\) 与 \(r\) 的大小关系就行了。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;

#define lt(x) ((x) &lt;&lt; 1)
#define rt(x) (lt(x) + 1)

int n, m;

int read() {
    int ans = 0, neg = 1; char ch = getchar();
    while (ch &lt; '0' || ch &gt; '9') { if (ch == '-') neg = -1; ch = getchar(); }
    while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') { ans *= 10; ans += (ch - '0'); ch = getchar(); }
    return ans * neg;
}

namespace SegTree {
    int t[1000001];

    void build(int x = 1, int l = 1, int r = n) {
        t[x] = n + 1;
        if (l == r)
            return;
        const int mid = (l + r) &gt;&gt; 1;
        build(lt(x), l, mid);
        build(rt(x), mid + 1, r);
    }

    void modify(int p, int a, int x = 1, int _l = 1, int _r = n) {
        if (_l == _r) {
            t[x] = std::min(t[x], a);
            return;
        }
        const int mid = (_l + _r) &gt;&gt; 1;
        if (p &lt;= mid)
            modify(p, a, lt(x), _l, mid);
        else
            modify(p, a, rt(x), mid + 1, _r);
        t[x] = std::min(t[lt(x)], t[rt(x)]);
    }

    int query(int l, int r, int x = 1, int _l = 1, int _r = n) {
        if (l &lt;= _l &amp;&amp; _r &lt;= r)
            return t[x];
        const int mid = (_l + _r) &gt;&gt; 1;
        int ans = n + 1;
        if (l &lt;= mid)
            ans = std::min(ans, query(l, r, lt(x), _l, mid));
        if (r &gt; mid)
            ans = std::min(ans, query(l, r, rt(x), mid + 1, _r));
        return ans;
    }
};

std::set&lt;int&gt; s;

int main() {
    n = read(), m = read();
    SegTree::build();
    for (int i = 0; i &lt;= n + 1; ++i)
        s.insert(i);
    while (m--) {
        int t = read();
        if (!t) {
            int l = read(), r = read(), op = read();
            if (!op) {
                while (!s.empty()) {
                    int pos = *s.lower_bound(l);
                    if (pos &lt;= r)
                        s.erase(pos);
                    else
                        break;
                }
            } else {
                SegTree::modify(l, r);
            }
        } else {
            int x = read();
            if (!s.count(x))
                puts(&quot;NO&quot;);
            else {
                auto i = s.lower_bound(x), j = s.upper_bound(x);
                --i;
                if (SegTree::query((*i) + 1, x) &lt; *j)
                    puts(&quot;YES&quot;);
                else
                    puts(&quot;N/A&quot;);
            }
        }
    }
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ABC242]]></title>
    <link href="oi.afobject.ml/abc242.html"/>
    <updated>2022-03-08T22:51:04+08:00</updated>
    <id>oi.afobject.ml/abc242.html</id>
    <content type="html"><![CDATA[
<p>VP</p>
<h2><a id="d-abc-transform" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>D ABC Transform</h2>
<p><tc><m>Medium *1286</m><t>递归</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h02vhvw87kj20vl0u0q4f.jpg" alt="" /></p>
<p>可以发现原树由 \(n\) 棵完全二叉树组成，然后发现可以暴力。具体地：</p>
<ul>
<li>对于节点 \((t,k)\)（第 \(t\) 层第 \(k\) 个） 它父亲一定是 \((t-1,\lfloor \dfrac k 2 \rfloor)\)，继续递归。回溯的时候，若 \(k \equiv 1 \pmod 2\)，则是左子节点，返回相应字母（原字母进一）；反之返回右子节点的字母（原字母进二 / 退一）。</li>
<li>对于节点 \((0,k)\)，返回第 \(k\) 个源字母。</li>
</ul>
<p>然后发现暴力似乎太慢，但又发现 \(k \le 10^{18}\) 这样一个怪异的条件。假如能做到 \(\log k\) 也是能过的。</p>
<p>考虑对于 \(k\) 已除到 \(0\) 的情况，即返回某一指定层的第一个字母。很容易发现第一个字母是循环的如 <code>ABCABC......</code> 所以结束了。复杂度 \(O(Q \log k)\)。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>注意负数取模仍是负数。</p>
<pre class="line-numbers"><code class="language-cpp">#define int long long

char a[1000001];
int q, t, k;

char solve(int t, int k) {
	if (t == 0)
		return a[k];
    if (k == 1)
        return (a[1] - 'A' + t) % 3 + 'A';

    char c = solve(t - 1, (k + 1) &gt;&gt; 1);
    return (c - 'A' - (k &amp; 1) + 2) % 3 + 'A';
}

signed main() {
	scanf(&quot;%s&quot;, a + 1);
	q = read();
	while (q--) {
		t = read(), k = read();
		printf(&quot;%c\n&quot;, solve(t, k));
	}
}
</code></pre>
<hr />
<h2><a id="e%E2%88%80-x%E2%88%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>E (∀x∀)</h2>
<p><tc><m>Medium- *1365</m><t>递归</t></tc></p>
<h3><a id="%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>分析</h3>
<p>毛估估是 \(\le\) 取一半构成的那个回文串的回文串的个数，如果取一半构成的那个回文串不符合那么答案就减一。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">#define int long long
#define MOD 998244353
#define m(x) (((x) + MOD) % MOD)

int T, n;
int pow26[2500001];
char s[2500001];

signed main() {
    pow26[0] = 1;
    for (int i = 1; i &lt;= 2500000; ++i)
        pow26[i] = m(26 * pow26[i - 1]);
    scanf(&quot;%lld&quot;, &amp;T);
    while (T--) {
        scanf(&quot;%lld%s&quot;, &amp;n, s);
        int ans = 1;
        const int q = (n - 1) &gt;&gt; 1;
        for (int i = q; i &gt;= 0; --i) 
            ans = m(ans + m((s[i] - 'A') * pow26[q - i]));
        bool valid = true;
        for (int i = q; i &gt;= 0; --i)
            if (s[n - i - 1] != s[i]) {
                valid = s[n - i - 1] &gt; s[i];
                break;
            }
        printf(&quot;%lld\n&quot;, m(ans - !valid));
    }
}
</code></pre>

]]></content>
  </entry>
  
</feed>
