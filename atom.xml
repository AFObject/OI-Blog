<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[OI Blog]]></title>
  <link href="oi.afobject.ml/atom.xml" rel="self"/>
  <link href="oi.afobject.ml/"/>
  <updated>2022-06-10T23:29:20+08:00</updated>
  <id>oi.afobject.ml/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[0x14 Hash]]></title>
    <link href="oi.afobject.ml/0x14-.html"/>
    <updated>2022-06-10T22:13:57+08:00</updated>
    <id>oi.afobject.ml/0x14-.html</id>
    <content type="html"><![CDATA[
<h2><a id="snowflake-snow-snowflakes" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Snowflake Snow Snowflakes</h2>
<p><tc><c>0x1401</c><e>Easy+</e><t>Hash</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>我们目标的 Hash 函数要满足：</p>
<ul>
<li>对于每个数是平等的；</li>
<li>能尽量区分出不同的雪花。</li>
</ul>
<p>因此可以构造出 Hash 函数 \(H(a_{i,1},a_{i,2},\ldots,a_{i,6})=(\sum_{j=1}^6a_{i,j}+\prod_{j=1}^6a_{i,j}) \bmod P\)。</p>
<p>对于每一个 Hash 值，期望的项目数是 \(\dfrac N P\)。每个块内比一比，最终的时间复杂度是 \(P \cdot \left(\dfrac N P\right)^2= \dfrac{N^2}P\)）。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>Hash 的实现注意：</p>
<ul>
<li>当 Hash 值计算过程中可能超过 <code>int</code> 范围（如乘积等）时，先转一下 <code>long long</code>；</li>
<li>能不开新空间就不开新空间，少用指针（适用所有题目）。</li>
</ul>
<pre class="line-numbers"><code class="language-cpp">#define P 99991

int n;

struct Snowflake {
    int a[6];
    int hashValue() {
        int sum = 0, prod = 1;
        for (int i = 0; i &lt; 6; ++i) 
            sum = (sum + a[i]) % P, prod = ((long long)prod * a[i]) % P;
        return (sum + prod) % P;
    }
    bool operator == (const Snowflake&amp; other) const {
        for (int s = 0; s &lt; 6; ++s) {
            bool flag = true;
            for (int i = 0; i &lt; 6; ++i)
                if (a[(s + i) % 6] != other.a[i])
                    flag = false;
            if (flag) return true;
            flag = true;
            for (int i = 0; i &lt; 6; ++i)
                if (a[(s + i) % 6] != other.a[5 - i])
                    flag = false;
            if (flag) return true;
        }
        return false;
    }
};

std::vector&lt;Snowflake&gt; v[100001];

int main() {
    n = read();
    while (n--) {
        Snowflake t;
        for (int i = 0; i &lt; 6; ++i)
            t.a[i] = read() % P;
        const int val = t.hashValue();
        for (auto x : v[val])
            if (x == t)
                return puts(&quot;Twin snowflakes found.&quot;), 0;
        v[val].push_back(t);
    }
    return puts(&quot;No two snowflakes are alike.&quot;), 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ABC254]]></title>
    <link href="oi.afobject.ml/abc254.html"/>
    <updated>2022-06-04T23:26:05+08:00</updated>
    <id>oi.afobject.ml/abc254.html</id>
    <content type="html"><![CDATA[
<p>VP</p>
<span id="more"></span><!-- more -->
<h2><a id="d-together-square" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>D Together Square</h2>
<p><tc><m>Medium *1191</m><t>数论</t><t>组合</t><t>筛法</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>两个数都是平方数的话其实是很简单的，但如果两个都不是平方数就有点难搞。一个非平方数所对应的可以让它们的积为完全平方数的另一个数是不唯一的，怎么快速找到它呢？</p>
<p>考虑将所有的数 \(i\) 都除去它们最大的完全平方数因数（\(p_i\)），然后剩下的部分（设为 \(f_i\)）相等的，原数拼在一起就可以得到一个完全平方数。下面考虑的是如何快速的得到 \(f_i\)。由于数据范围不大，可以直接枚举它的因数找到 \(p_i\)。枚举因数用类似埃筛的方法，时间复杂度反正不大。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">#define int long long

int n, sum[200001];
bool g[200001];
std::vector&lt;int&gt; v[200001];

signed main() {
    scanf(&quot;%lld&quot;, &amp;n);
    int ans = 0;
    for (int i = 1; i * i &lt;= n; ++i) g[i * i] = true;
    for (int i = 1; i &lt;= n; ++i)
        for (int j = i; j &lt;= n; j += i)
            v[j].push_back(i);
    for (int i = 1; i &lt;= n; ++i) {
        int f = 1;
        for (int p : v[i])
            if (i % p == 0 &amp;&amp; g[p]) f = std::max(f, p);
        sum[i / f]++;
    }
    for (int i = 1; i &lt;= n; ++i) ans += sum[i] * sum[i];
    printf(&quot;%lld\n&quot;, ans);
}
</code></pre>
<hr />
<h2><a id="e-small-d-and-k" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>E Small d and k</h2>
<p><tc><e>Easy+ *1202</e><t>搜索</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>答案是暴力。</p>
<p>这种最短路问题理应用 BFS 解决，但实际上 DFS 乱搞搞也可以过。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int x, k;
int dis[200001];
std::vector&lt;int&gt; nodes;
void dfs(int x, int t) {
    if (t &gt;= dis[x]) return;
    if (dis[x] &gt; k) nodes.push_back(x);
    dis[x] = t;
    if (t == k) return;
    for (int v : e[x])
        dfs(v, t + 1);
}

int main() {
    n = read(), m = read();
    for (int i = 1; i &lt;= n; ++i) dis[i] = 1e9;
    while (m--) {
        int u = read(), v = read();
        e[u].push_back(v);
        e[v].push_back(u);
    }
    q = read();
    while (q--) {
        x = read(), k = read();
        nodes = std::vector&lt;int&gt;();
        dfs(x, 0);
        long long ans = 0;
        for (int u : nodes) {
            dis[u] = 1e9;
            ans += u;
        }
        printf(&quot;%lld\n&quot;, ans);
    }
    return 0;
}
</code></pre>
<hr />
<h2><a id="f-rectangle-gcd" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>F Rectangle GCD</h2>
<p><tc><m>Medium- *1764</m><t>数论</t><t>GCD</t><t>线段树</t><t>DS</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>极其显然地，答案是</p>
\[\gcd\{A_{h_1}+B_{w_1},\underset{i\in(h_1,h_2]}{\left|A_i-A_{i-1}\right|},\underset{i\in(w_1,w_2]}{\left|B_i-B_{i-1}\right|}\}
\]
<p>然后就是查询区间 \(\gcd\)，用线段树或者 ST 表。</p>
<p>为什么感觉 E &lt; F &lt; D……</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>不带修的线段树真好写。注意四倍空间！</p>
<pre class="line-numbers"><code class="language-cpp">#define lt(x) ((x) &lt;&lt; 1)
#define rt(x) (((x) &lt;&lt; 1) + 1)
#define abs(x) ((x) &gt; 0 ? (x) : -(x))

int n, q;
int a[200001], b[200001];
int ca[200001], cb[200001];

int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}

int segA[800001], segB[800001];
void build(int *s1, int *s2, int x, int l, int r) {
    if (l == r) {
        s1[x] = s2[l];
        return;
    }
    const int mid = (l + r) &gt;&gt; 1;
    build(s1, s2, lt(x), l, mid);
    build(s1, s2, rt(x), mid + 1, r);
    s1[x] = gcd(s1[lt(x)], s1[rt(x)]);
}

int query(int *s, int x, int l, int r, int ql, int qr) {
    if (l &gt; r) return 1;
    if (ql &lt;= l &amp;&amp; r &lt;= qr) return s[x];
    const int mid = (l + r) &gt;&gt; 1;
    int res = 0;
    if (ql &lt;= mid) res = gcd(res, query(s, lt(x), l, mid, ql, qr));
    if (qr &gt; mid) res = gcd(res, query(s, rt(x), mid + 1, r, ql, qr));
    return res;
}

int main() {
    n = read(), q = read();
    for (int i = 1; i &lt;= n; ++i) a[i] = read();
    for (int i = 1; i &lt;= n; ++i) b[i] = read();
    for (int i = 1; i &lt;= n; ++i)
        ca[i] = abs(a[i] - a[i - 1]), cb[i] = abs(b[i] - b[i - 1]);
    build(segA, ca, 1, 1, n);
    build(segB, cb, 1, 1, n);
    while (q--) {
        int h1 = read(), h2 = read(), w1 = read(), w2 = read();
        printf(&quot;%d\n&quot;, gcd( gcd(query(segA, 1, 1, n, h1 + 1, h2),
                                query(segB, 1, 1, n, w1 + 1, w2)),
                            a[h1] + b[w1]));
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x13 链表与邻接表]]></title>
    <link href="oi.afobject.ml/0x13-.html"/>
    <updated>2022-06-01T20:12:11+08:00</updated>
    <id>oi.afobject.ml/0x13-.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E5%B0%8F%E7%86%8A%E7%9A%84%E6%9E%9C%E7%AF%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>小熊的果篮</h2>
<p><tc><c>CSP-J 2021</c><e>Easy+</e><t>模拟</t><t>链表</t></tc></p>
<p>普及摆烂没 AK 的痛</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>将块作为链表的一个项目，每一轮进行合并，由于每个水果至多被删一次，所以时间复杂度就是 \(O(n)\) 的。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>有点难整。。。</p>
<p>首先明确一个块内的编号并不是连续的，所以除了维护块之间的顺序外还要再开一个双向链表来维护编号间的前后关系（但这个实现起来用数组即可，比较简单）。考场上写错就是因为这个点。</p>
<p>另外这里的写法中两边的 <code>head</code> 和 <code>tail</code> 是空的，要判一下。</p>
<pre class="line-numbers"><code class="language-cpp">namespace List {
    struct Node {
        int val, type, start;
        Node *prev, *next;
    } v[200001], *head, *tail;
    void init() {
        head = new Node();
        tail = new Node();
        head-&gt;next = tail;
        tail-&gt;prev = head;
    }
    void insert(int val, int type, int start, Node *p) {
        auto r = new Node();
        r-&gt;val = val; r-&gt;type = type; r-&gt;start = start;
        r-&gt;prev = p; r-&gt;next = p-&gt;next;
        p-&gt;next-&gt;prev = r; p-&gt;next = r;
    }
    void remove(Node *p) {
        p-&gt;prev-&gt;next = p-&gt;next;
        p-&gt;next-&gt;prev = p-&gt;prev;
        delete p;
    }
};

int prevN[200001], nextN[200001];

int n;

int main() {
    n = read();
    List::init();
    int prev = 0, count = 0;
    for (int i = 1; i &lt;= n; ++i) {
        if (i != n) nextN[i] = i + 1; prevN[i] = i - 1;
        int a = read();
        if (a != prev) {
            if (i != 1)
                List::insert(count, prev, i - count, List::tail-&gt;prev);
            prev = a;
            count = 0;
        }
        ++count;
    }
    List::insert(count, prev, n + 1 - count, List::tail-&gt;prev);
    while (List::head-&gt;next != List::tail) {
        for (auto x = List::head-&gt;next; x-&gt;next != NULL; x = x-&gt;next)
            printf(&quot;%d &quot;, x-&gt;start);
        putchar('\n');
        for (auto x = List::head-&gt;next; x-&gt;next != NULL; x = x-&gt;next) {
            x-&gt;val--;

            nextN[prevN[x-&gt;start]] = nextN[x-&gt;start];
            prevN[nextN[x-&gt;start]] = prevN[x-&gt;start];
            x-&gt;start = nextN[x-&gt;start];

            if (x-&gt;val == 0)
                List::remove(x);
            else if (x-&gt;prev-&gt;type == x-&gt;type &amp;&amp; x-&gt;prev != List::head)
                x-&gt;prev-&gt;val += x-&gt;val, List::remove(x);
        }
    }
    return 0;
}
</code></pre>
<hr />
<h2><a id="%E9%82%BB%E5%80%BC%E6%9F%A5%E6%89%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>邻值查找</h2>
<p><tc><c>0x1301</c><m>Medium-</m><t>模拟</t><t>链表</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>显然有一步是要从小到大排序并且找出某个数的前驱 / 后继。</p>
<p>一种方法是依次将数有序地插入一个 <code>std::set</code>，并输出这个数的前驱或后缀。</p>
<p>另一种方法则是<strong>倒序</strong>处理，用完一个删一个，用链表维护数据。</p>
<p>本节例题中「Running Median」（0x0503）也可以用这种倒序的思想处理数据（用完一个删一个）。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>还是注意判断队列首、尾预留的空项的问题，赋一个极大的初值即可。</p>
<pre class="line-numbers"><code class="language-cpp">namespace List {
    struct Node {
        std::pair&lt;int, int&gt; val;
        Node *prev, *next;
    } v[200001], *head, *tail;
    void init() {
        head = new Node();
        tail = new Node();
        head-&gt;val.first = -2e9;
        tail-&gt;val.first = 2e9;
        head-&gt;next = tail;
        tail-&gt;prev = head;
    }
    void insert(std::pair&lt;int, int&gt; val, Node *p) {
        auto r = new Node();
        r-&gt;val = val; r-&gt;prev = p; r-&gt;next = p-&gt;next;
        p-&gt;next-&gt;prev = r; p-&gt;next = r;
    }
    void remove(Node *p) {
        p-&gt;prev-&gt;next = p-&gt;next;
        p-&gt;next-&gt;prev = p-&gt;prev;
        delete p;
    }
};

std::pair&lt;int, int&gt; a[200001];
List::Node *b[200001];

int n;
int ansVal[200001], ansIdx[200001];

int main() {
    n = read();
    List::init();
    for (int i = 1; i &lt;= n; ++i) a[i] = {read(), i};
    std::sort(a + 1, a + n + 1);
    for (int i = 1; i &lt;= n; ++i) {
        List::insert(a[i], List::tail-&gt;prev);
        b[a[i].second] = List::tail-&gt;prev;
    }
    for (int i = n; i &gt; 1; --i) {
        int lhs = b[i]-&gt;val.first - b[i]-&gt;prev-&gt;val.first,
            rhs = b[i]-&gt;next-&gt;val.first - b[i]-&gt;val.first;
        ansVal[i] = std::min(lhs, rhs);
        if (lhs &lt;= rhs) ansIdx[i] = b[i]-&gt;prev-&gt;val.second;
        else ansIdx[i] = b[i]-&gt;next-&gt;val.second;
        List::remove(b[i]);
    }
    for (int i = 2; i &lt;= n; ++i)
        printf(&quot;%d %d\n&quot;, ansVal[i], ansIdx[i]);
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x12 队列]]></title>
    <link href="oi.afobject.ml/0x12-.html"/>
    <updated>2022-05-20T22:37:19+08:00</updated>
    <id>oi.afobject.ml/0x12-.html</id>
    <content type="html"><![CDATA[
<h2><a id="team-queue" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Team Queue</h2>
<p><tc><c>0x1201</c><e>Easy</e><t>模拟</t><t>队列</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>开个队列记录下队伍之间的顺序；再对于每个队伍开个队列记录下内部的顺序。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n;
std::map&lt;int, int&gt; m;
std::queue&lt;int&gt; d, q[1001];

int main() {
    int T = 0;
    while (std::cin &gt;&gt; n &amp;&amp; n) {
        ++T;
        std::cout &lt;&lt; &quot;Scenario #&quot; &lt;&lt; T &lt;&lt; '\n';

        m.clear(); d = std::queue&lt;int&gt;();
        for (int i = 1; i &lt;= n; ++i) {
            q[i] = std::queue&lt;int&gt;();
            int t; std::cin &gt;&gt; t;
            while (t--) {
                int g; std::cin &gt;&gt; g;
                m[g] = i;
            }
        }

        std::string s; int op;
        while (std::cin &gt;&gt; s &amp;&amp; s != &quot;STOP&quot;) {
            if (s == &quot;DEQUEUE&quot;) {
                std::cout &lt;&lt; q[d.front()].front() &lt;&lt; '\n';
                q[d.front()].pop();
                if (q[d.front()].empty()) d.pop();
            } else if (s == &quot;ENQUEUE&quot;) {
                std::cin &gt;&gt; op;
                if (q[m[op]].empty()) d.push(m[op]);
                q[m[op]].push(op);
            }
        }
        std::cout &lt;&lt; '\n';
    }
}
</code></pre>
<hr />
<h2><a id="%E8%9A%AF%E8%9A%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>蚯蚓</h2>
<p><tc><c>NOIP2016 D2T2</c><c>0x1202</c><m>Medium+</m><t>数学</t><t>队列</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>时间复杂度的瓶颈像是 \(O(m)\) 的，这也就是要求我们 \(O(1)\) 实现查询最大值、分裂、增长长度这三个操作。</p>
<p>最直接地，可以想到通过大根堆找出最大值，但是顺序不保证，而且太慢了，想要 \(O(1)\) 的话最好使序列有序。接下来就是试图找出单调性。</p>
<p>一次操作，等效于把一个数 \(x\) 分为 \(\lfloor px \rfloor - q\) 和 \(x - \lfloor px \rfloor - q\) 这两个数（实际值是全部数加上 \(\Delta=q\cdot T\)，\(T\) 为当前操作次数）。任何操作都只会让数列中的数变小，所以数列的最大值单调递减，被砍的数单调递减。</p>
<p>可不想让被砍出来的数再放回原队列破坏单调性，所以继续探究被砍出来的数是否存在单调性。注意我们集体减了 \(\Delta\)，计算的时候要还原 \(\Delta\)（\(\Delta\) 为本轮操作前的 \(\Delta\)）。一个数被分为了 \(x_1=\lfloor p(x+\Delta) \rfloor - q - \Delta\) 和 \(x_2=x - \lfloor p(x+\Delta) \rfloor - q\)。假设在这个数后面被分裂的那个数是 \(y\)（\(y \le x\)），那么分出来的就是 \(y_1=\lfloor p(y+\Delta+q) \rfloor - q - \Delta-q\) 和 \(y_2=y - \lfloor p(y+\Delta+q) \rfloor - q\)。</p>
<p>作差：</p>
\[\begin{aligned}
x_1-y_1
&amp;=\lfloor p(x+\Delta) \rfloor-\lfloor p(y+\Delta+q) \rfloor+q\\
&amp;=\lfloor p(x+xq) \rfloor-\lfloor p(y+q) \rfloor&gt;0\\

x_2-y_2
&amp;=x - \lfloor p(x+\Delta) \rfloor - y + \lfloor p(y+\Delta+q) \rfloor\\
&amp;=\lfloor x-p(x)\rfloor-\lfloor y-p(y+q) \rfloor&gt;0
\end{aligned}
\]
<p>也就是说，<strong>砍出来的那两截蚯蚓的长度也随着时间的推移而单调递减</strong>。在所有操作之前先把整个序列排序存进一个队列中，当进行分裂操作时，把大的取出来放进一个队列，把小的取出来放进另一个队列。可以保证这三个队列都是队首大，队尾小，这样就完成了 \(O(1)\) 地求最大值。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">#define int long long
#define top(x) ((x.empty()) ? -1e16 : x.front())

int n, m, q, u, v, t;
int d[100001];
std::queue&lt;int&gt; a, b, c;

signed main() {
    n = read(), m = read(), q = read(), u = read(), v = read(), t = read();
    for (int i = 1; i &lt;= n; ++i) d[i] = read();
    std::sort(d + 1, d + n + 1);
    for (int i = n; i; --i) a.push(d[i]);

    int delta = 0;
    for (int i = 1; i &lt;= m; ++i, delta += q) {
        int a0 = top(a), b0 = top(b), c0 = top(c), max = 0;
        if (a0 &gt;= b0 &amp;&amp; a0 &gt;= c0) max = a0, a.pop();
        else if (b0 &gt;= c0) max = b0, b.pop();
        else max = c0, c.pop();
        if (i % t == 0) printf(&quot;%lld &quot;, max + delta);
        b.push(floor((double)u / v * (max + delta)) - q - delta);
        c.push(max - floor((double)u / v * (max + delta)) - q);
    }
    putchar('\n');
    for (int i = 1; i &lt;= n + m; ++i) {
        int a0 = top(a), b0 = top(b), c0 = top(c), max = 0;
        if (a0 &gt;= b0 &amp;&amp; a0 &gt;= c0) max = a0, a.pop();
        else if (b0 &gt;= c0) max = b0, b.pop();
        else max = c0, c.pop();
        if (i % t == 0) printf(&quot;%lld &quot;, max + delta);
    }

    return 0;
}
</code></pre>
<hr />
<h2><a id="%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>双端队列</h2>
<p><tc><c>BJOI 2011</c><c>0x1203</c><m>Medium+</m><t>贪心</t><t>队列</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>以输入为出发点考虑问题：我不太行，因为他要求是整体有序，很难光通过原始的无序序列找到答案。</p>
<p><strong>以输出为出发点考虑问题</strong>：最终要求排好序，那我就排好序，把排好序的数组分割，每一段对应一个双端队列。每一段中要求数的下标具有<strong>单谷性质</strong>。注意判断重复的数。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>接下来是单谷怎么找的问题，一开始是下降的状态，降不动的时候只能升，升不动的时候就成了一个双端队列（同一个数的下标要么全升要么全降，否则复杂化了）。开两个变量，一个是上升下降的标志，一个是上升 / 下降期的最小 / 最大下标。</p>
<pre class="line-numbers"><code class="language-cpp">int n, a[200001];
std::pair&lt;int, int&gt; p[200001];
std::vector&lt;int&gt; v[200001];

int main() {
    n = read();
    for (int i = 1; i &lt;= n; ++i) {
        p[i].first = read();
        p[i].second = i;
    }
    std::sort(p + 1, p + n + 1);
    int t = 1;
    v[t].push_back(p[1].second);
    for (int i = 2; i &lt;= n; ++i) {
        if (p[i].first != p[i - 1].first)
            v[++t].push_back(p[i].second);
        else v[t].push_back(p[i].second);
    }
    int flag = 0, num = 0, ans = 0;
    for (int i = 1; i &lt;= t; ++i) {
        const int first = v[i][0], last = v[i][v[i].size() - 1];
        if (flag) {
            if (first &lt; num) { ++ans; flag = 0; num = first; }
            else num = last;
        } else {
            if (last &gt; num) { flag = 1; num = last; }
            else num = first;
        }
    }
    printf(&quot;%d\n&quot;, ans);
    return 0;
}
</code></pre>
<hr />
<h2><a id="%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>最大子序和</h2>
<p><tc><c>0x1204</c><e>Easy</e><t>前缀和</t><t>单调队列</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>考虑没有限制的做法：一个是递推一下，一个是前缀和一下。有限制的话感觉前缀和更靠谱，那就试一试。求出前缀和 \(p\) 后，问题转化为找出 \(\max\limits_{i-j &lt; m}\{p_i-p_j\}\)。</p>
<p>考虑用单调队列求解。用滑动窗口求出当前点之前的 \(m\) 个前缀和的最小值，用现在的前缀和去减，就做完了。</p>
<p>复习一下滑动窗口的做法：进队尾把大数顶掉，维持单调递增，把超过窗口范围的也推掉。最小值在每次的队头。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n, m, p[300001];
std::deque&lt;std::pair&lt;int, int&gt;&gt; q;

int main() {
    n = read(), m = read();
    for (int i = 1; i &lt;= n; ++i)
        p[i] = p[i - 1] + read();
    int ans = -2e8;
    q.push_back({0, 0});
    for (int i = 1; i &lt;= n; ++i) {
        while (q.size() &amp;&amp; q.back().second &gt; p[i]) q.pop_back();
        q.push_back({i, p[i]});
        if (i - q.front().first &gt; m) q.pop_front();
        ans = std::max(ans, p[i] - q.front().second);
    }
    printf(&quot;%d\n&quot;, ans);
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Educational Codeforces Round #128 (Div.2)]]></title>
    <link href="oi.afobject.ml/cf1680.html"/>
    <updated>2022-05-14T22:28:03+08:00</updated>
    <id>oi.afobject.ml/cf1680.html</id>
    <content type="html"><![CDATA[
<p>[5/6] Alt (Rated), 3/6, 1071 \(\to\) 1278</p>
<span id="more"></span><!-- more -->
<h2><a id="1680c-binary-string" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1680C Binary String</h2>
<p><tc><m>Medium- *1600</m><t>二分</t><t>前缀和</t></tc></p>
<p>场切了，想出二分没觉得特难，到时候看看 \(O(n)\) 做法是什么。</p>
<hr />
<h2><a id="1680d-dog-walking" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1680D Dog Walking</h2>
<p><tc><m>Medium+ *2400</m><t>数学</t><t>贪心</t><t>前缀和</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>题面太长不看。稍微简化一下题面：将数列中的 \(0\) 都替换成 \([-k,k]\) 中的一个数后，令前缀和数组为 \(s\)，最大化 \(\max\{s\}-\min\{s\}\) 且 \(s_n=0\)（很容易判断，当 \(\mid s_n\mid\) 大于 0 的个数乘以 \(k\) 的时候，必然无解）。</p>
<p>由这个式子不难想到最大子段和的前缀和解法，可以差不多地理解一下，这个 \(\max\{s\}-\min\{s\}\) 代表的是原数列中的<strong>一段区间和（的绝对值）</strong>。然后注意到 \(1 \le n \le 3000\) 的良心范围，考虑直接枚举这个区间的左、右端点。最优化的方案必然是要么 0 全替换为 \(k\)，要么全替换为 \(-k\)。</p>
<p>但要求 \(s_n=0\)，怎么处理这个条件也是难点之一。关键点在于看被选择的区间内、外的和能否达到平衡，即「归零」：</p>
<ul>
<li>当区间内的和为一个正数 \(p\)，区间外的和的最小值为 \(p'_{\min}\)，我们想要使 \(p+p'_{\min}=0\)，因此答案取 \(\min\{p, \mid p'_{\min} \mid\}\)；</li>
<li>同理，当区间内的和为一个负数 \(-p\)，区间外的和的最大值为 \(p'_{\max}\)，答案取 \(\min\{\mid p \mid, p'_{\max}\}\)。</li>
</ul>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n, k, a[3001];
int p[3001], d[3001];

signed main() {
    n = read(), k = read();
    for (int i = 1; i &lt;= n; i++) {
        a[i] = read();
        d[i] = d[i - 1] + (a[i] == 0);
        p[i] = p[i - 1] + a[i];
    }
    if (abs(p[n]) &gt; k * d[n]) return puts(&quot;-1&quot;), 0;
    int max = -1;
    for (int l = 1; l &lt;= n; l++) {
        for (int r = l; r &lt;= n; r++) {
            int sum = p[r] - p[l - 1], cnt = d[r] - d[l - 1];
            int lSum = p[n] - sum, lCnt = d[n] - cnt;
            max = std::max(max, std::min(abs(sum + cnt * k), abs(lSum - lCnt * k)));
            max = std::max(max, std::min(abs(sum - cnt * k), abs(lSum + lCnt * k)));
        }
    }
    printf(&quot;%lld\n&quot;, max + 1);
    return 0;
}
</code></pre>
<hr />
<h2><a id="1680e-moving-chips" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1680E Moving Chips</h2>
<p><tc><m>Medium+ *2000</m><t>DP</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>这题里吃的路径其实是可逆的，比如说 A 吃了 B，C 再吃了 B 和 A 吃了 B 然后继续吃了 C 是一样的。所以我们的目标是找出代价最少的一条吃人路径，并且可以钦定任意一个星号作为最终状态。假如设最后留下来的是最右边的某个星号，那就是「从左吃到右」的过程，可以尝试用 DP 来最优化方案。</p>
<p>设 \(f(i,0/1)\) 为把第 \(1\) 到第 \(i-1\) 列全部吃掉，且星号仅在 \((i,0/1)\) 时的最小步数。在对这一列进行 DP 的过程中，我们要考虑的问题是<strong>怎么把上一列的星号全部转移到这一列的目标位置中去</strong>。假如本列有两个星号，<strong>合并一定更优</strong>（否则同时移两个就是浪费），所以也要考虑合并。</p>
<ul>
<li>若全部转移到 \((i,0)\)：
<ul>
<li>从 \((i-1,0)\) 转移：代价为 \(1\)，但如果 \((i,1)\) 有星号，还需要再加一。</li>
<li>从 \((i-1,1)\) 转移：可以顺便吃了 \((i,1)\)，无论如何代价始终为 \(2\)。</li>
</ul>
</li>
<li>若全部转移到 \((i,1)\)：
<ul>
<li>从 \((i-1,1)\) 转移：代价为 \(1\)，但如果 \((i,0)\) 有星号，还需要再加一。</li>
<li>从 \((i-1,0)\) 转移：代价始终为 \(2\)。</li>
</ul>
</li>
</ul>
<p>可以轻松写出状态转移方程。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int T, n;
int g[200001][2], f[200001][2];

int main() {
    std::cin &gt;&gt; T;
    while (T--) {
        std::cin &gt;&gt; n;
        for (int i = 1; i &lt;= n; ++i)
            f[i][0] = f[i][1] = 0;
        for (int i = 0; i &lt; 2; ++i) {
            for (int j = 1; j &lt;= n; ++j) {
                char c; std::cin &gt;&gt; c;
                g[j][i] = (c == '*');
            }
        }
        int l = 1, r = n;
        while (!g[l][0] &amp;&amp; !g[l][1]) ++l;
        while (!g[r][0] &amp;&amp; !g[r][1]) --r;
        for (int i = l; i &lt;= r; ++i) {
            f[i][0] = std::min(f[i - 1][0] + g[i][1] + 1, f[i - 1][1] + 2);
            f[i][1] = std::min(f[i - 1][1] + g[i][0] + 1, f[i - 1][0] + 2);
        }
        std::cout &lt;&lt; std::min(f[r][0], f[r][1]) - 1 &lt;&lt; std::endl;
        // 之前没有特地算 f[l][0/1] 的初始值，循环直接从 l 开始，但是 l-1 -&gt; l 算了 1 步，所以这里减去一。
    }
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces Round #786 (Div.3)]]></title>
    <link href="oi.afobject.ml/cf1674.html"/>
    <updated>2022-05-03T23:02:19+08:00</updated>
    <id>oi.afobject.ml/cf1674.html</id>
    <content type="html"><![CDATA[
<p>[已通关] Rated, 4/7, 1364 \(\to\) 1438</p>
<span id="more"></span><!-- more -->
<p>E 大家都 fst 也就算了，F 就差造个极端数据拍一拍就过了 /fn</p>
<h2><a id="1674f-desktop-rearrangement" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1674F Desktop Rearrangement</h2>
<p><tc><e>Easy+ *1800</e><t>模拟</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>你 CF 为啥要出这种烂模拟。</p>
<p>问题相当于询问有几个图标需要移动。首先求出原图状态下有几个需要移的，接下来考虑变化。</p>
<ul>
<li>
<p>如果是从没有变成有的：</p>
<ul>
<li>在操作<strong>后</strong>的边界上的那个点（如果存在）不用移了，答案减一（如果操作的就是这个点，<strong>忽略</strong>这一条，对答案没有影响）。</li>
<li>另外如果改变的这个点超过了操作<strong>后</strong>的边界，那么就需要费力气移它，答案加一。</li>
</ul>
</li>
<li>
<p>如果是从有变成没有的：</p>
<ul>
<li>操作<strong>前</strong>的守门员（如果存在）被踢了，需要移的加一（如果操作的就是这个点，<strong>忽略</strong>这一条，对答案没有影响）。</li>
<li>如果本来就超出了操作<strong>前</strong>的范围，需要移的减一，否则不变。</li>
</ul>
</li>
</ul>
<p>由上分类讨论可见，<code>.</code> 变 <code>*</code> 和 <code>*</code> 变 <code>.</code> 对答案的影响是不同的，尤其体现在操作前边界或是操作后边界的区别。</p>
<p>更直接的做法是树状数组直接暴力维护范围内有几个（前缀和）。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>考虑将矩阵转为序列，在序列上操作方便得多。</p>
<pre class="line-numbers"><code class="language-cpp">#define trans(i, j) (((j) - 1) * n + (i))
int n, m, q;
char map[1000001];

int main() {
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
    int cnt = 0;
    for (int i = 1, k = 0; i &lt;= n; ++i) {
        for (int j = 1; j &lt;= m; ++j) {
            std::cin &gt;&gt; map[trans(i, j)];
            if (map[trans(i, j)] == '*') ++cnt;
        }
    }
    int ans = cnt;
    for (int i = 1; i &lt;= cnt; ++i)
        if (map[i] == '*')
            --ans;

    while (q--) {
        int x, y;
        std::cin &gt;&gt; x &gt;&gt; y;
        int idx = trans(x, y);
        if (map[idx] == '.') {
            ++cnt;
            if (map[cnt] == '*') --ans;
            if (idx &gt; cnt) ++ans;
            map[idx] = '*';
        } else {
            map[idx] = '.';
            if (idx &gt; cnt) --ans;
            if (map[cnt] == '*') ++ans;
            --cnt;
        }
        std::cout &lt;&lt; ans &lt;&lt; '\n';
    }
    return 0;
}
</code></pre>
<hr />
<h2><a id="1674e-breaking-the-wall" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1674E Breaking the Wall</h2>
<p><tc><m>Medium- *2000</m><t>数学</t><t>贪心</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>形象一点，我们的答案的来源只有可能是这几种情况：</p>
<ul>
<li>火力全开。即对数列中最小的两个每次杀掉 2。适用于数列中最小的两个数分隔较远的情况。</li>
<li>投机取巧。相隔一个数的两个奇数，先通过杀中间的那个数一次转为偶数，然后转为「火力全开」型。</li>
<li>互帮互助。杀掉相邻两个数，互相凑一凑，答案就是两个数和除以 3 向上取整。但当一个数 \(a\) 大于另一个数 \(b\) 的两倍时，此方法只能妥协，答案为 \(\lceil \dfrac a 2 \rceil\)。</li>
</ul>
<p>当被杀的两个数距离大于等于 2 的时候，可以做到各杀各的互不干涉，归于「火力全开」型。</p>
<p>当被杀的两个数距离等于 1 的时候，适用「火力全开」型或「投机取巧」型（总结起来就是两个数加起来除以二向上取整）。</p>
<p>当被杀的两个数相邻，那必然属于「互帮互助」型。</p>
<p>因此，以上三种得到答案的类型覆盖所有的情况，解法是正确的。</p>
<p>这个题叉麻了，300 多测试点，乐死了。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n, a[200001];

int upper(int a, int b) {
    if (a % b) return a / b + 1;
    else return a / b;
}

int main() {
    n = read();
    for (int i = 1; i &lt;= n; ++i) {
        a[i] = read();
    }

    int t3 = 1000000;
    for (int i = 1; i &lt;= n - 1; ++i) {
        int res = 0;
        if (a[i] &gt; a[i + 1] * 2) res = (a[i] + 1) / 2;
        else if (a[i + 1] &gt; a[i] * 2) res = (a[i + 1] + 1) / 2;
        else res = upper(a[i] + a[i + 1], 3);
        t3 = std::min(t3, res);
    }

    int t2 = 1000000;
    for (int i = 1; i &lt;= n - 2; ++i)
        if ((a[i] &amp; 1) &amp;&amp; (a[i + 2] &amp; 1))
            t2 = std::min(t2, 1 + a[i] / 2 + a[i + 2] / 2);

    std::sort(a + 1, a + n + 1);
    int t1 = (a[1] + 1) / 2 + (a[2] + 1) / 2;

    printf(&quot;%d\n&quot;, std::min({t1, t2, t3}));
    return 0;
}
</code></pre>
<hr />
<h2><a id="1674g-remove-directed-edges" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1674G Remove Directed Edges</h2>
<p><tc><m>Medium+ *2000</m><t>图论</t><t>拓扑</t><t>DP</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>首先回顾一下「Cute Set」的定义：</p>
<blockquote>
<p>一个顶点的集合 \(S\) 被称作可爱的当且仅当任意两个顶点 \(v\) 和 \(u\)（\(v \neq u,v \in S,u \in S\)），可以经过由未删除的边组成的路径由 \(u\) 达到 \(v\)，或是从 \(v\) 达到 \(u\)。</p>
</blockquote>
<p>由于原图是一个 DAG，集合中点和未删除的边构成的也是一个 DAG。由 DAG 联想到可以进行拓扑排序。拓扑序中，任何一对相邻的顶点 \((i, i+1)\)，都满足：由 \(i\) 可以通过一条路径到达 \(i+1\)，或是由 \(i+1\) 可以通过条路径到达 \(i\)。若是后者，则 \(i+1\) 在拓扑序中，必位于 \(i\) 之前，矛盾。因此拓扑序中，总可以由靠前的顶点经过一些边到达靠后的顶点。由此推出一个重要的结论：<strong>存在一条经过一个 Cute Set 中所有顶点的路径，一条路径经过的顶点的集合也是一个 Cute Set</strong>。</p>
<p>问题转化为：在 DAG 中找一条最长路，且经过的边均未删除。</p>
<p>转化为一个更简单直白问题后，再来看删边的条件。每个顶点要么没有入边，要么被删一条入边，出边同理。下面思考的问题是，在选择路径的时候，哪些顶点可以被加入集合中？路径对于一个顶点而言，就是一条入边和一条出边。在保留这条路径不能删的同时，它还要预留可以删除的入边、出边各一条，以满足题意。因此，第二个重要的结论是：除了路径的起点没有入度要求、路径的终点没有出度要求以外，对于路径上每一个点的要求是至少分别有两条入边和两条出边，即<strong>对于路径上的每一条边 \(u \to v\)，都要满足 \(out_u&gt;1\) 且 \(in_v&gt;1\)</strong>。</p>
<p>对于 DAG 上最长路问题，直接在拓扑序上 DP 即可，具体方法不再赘述。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n, m;
int ind[200001], oud[200001], del[200001];
std::vector&lt;int&gt; e[200001];
std::queue&lt;int&gt; q;
int f[200001];

int main() {
    n = read(), m = read();
    while (m--) {
        int u = read(), v = read();
        ++ind[v], ++del[v], ++oud[u];
        e[u].push_back(v);
    }
    for (int i = 1; i &lt;= n; ++i) {
        f[i] = 1;
        if (!del[i]) q.push(i);
    }
    int ans = 1;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        ans = std::max(ans, f[u]);
        for (int v : e[u]) {
            if (ind[v] &gt; 1 &amp;&amp; oud[u] &gt; 1)
                f[v] = std::max(f[v], f[u] + 1);
            if (!--del[v])
                q.push(v);
        }
    }
    printf(&quot;%d\n&quot;, ans);
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LGR108]]></title>
    <link href="oi.afobject.ml/LGR108.html"/>
    <updated>2022-05-01T23:13:15+08:00</updated>
    <id>oi.afobject.ml/LGR108.html</id>
    <content type="html"><![CDATA[
<h2><a id="c-sunset-p8320" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>C Sunset - P8320</h2>
<p><tc><e>Easy</e><t>交互</t><t>二分</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>观察 \(a\) 数列的变化趋势，那必然是先上升后不变，不变的那个点为当前数列的最大值。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int main() {
    cin &gt;&gt; T;
    while (T--) {
        cin &gt;&gt; n;
        for (int i = n; i; --i) {
            int last = query(n);
            int l = 1, r = n;
            while (l &lt; r) {
                const int mid = (l + r) / 2;
                if (query(mid) &lt; last) l = mid + 1;
                else r = mid;
            }
            ans[l] = i;
            cout &lt;&lt; &quot;? 2 &quot; &lt;&lt; l &lt;&lt; endl;
        }
        cout &lt;&lt; &quot;! &quot;;
        for (int i = 1; i &lt;= n; ++i)
            cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot;;
        cout &lt;&lt; endl;
    }
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces Round #785 (Div.2)]]></title>
    <link href="oi.afobject.ml/cf1673.html"/>
    <updated>2022-05-01T00:58:35+08:00</updated>
    <id>oi.afobject.ml/cf1673.html</id>
    <content type="html"><![CDATA[
<p>[3/6] Rated, 1/6, \(1448 \to 1364\)，我是天下第一🎤，哈哈哈哈！！！！！！！！！B 都不会！！！</p>
<span id="more"></span><!-- more -->
<h2><a id="1673b-a-perfectly-balanced-string" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1673B A Perfectly Balanced String?</h2>
<p><tc><m>Medium- *1100</m><t>结论</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>五花八门。</p>
<p>你找一个长度最短且首尾字符相同的，此时首尾字符出现的次数为 \(2\)，那么中间的次数只能是 \(1\) 咯，必须每个都轮一遍。轮不到的寄。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>这个 <code>last</code> 的用法还挺妙的。</p>
<pre class="line-numbers"><code class="language-cpp">int T;
char s[200003];
bool e[27];
int last[27];

int main() {
    scanf(&quot;%d&quot;, &amp;T);
    while (T--) {
        scanf(&quot;%s&quot;, s);
        const int len = strlen(s);
        for (int i = 0; i &lt; 27; i++)
            e[i] = false;
        for (int i = 0; i &lt; len; i++)
            e[s[i] - 'a'] = true;
        int kind = 0;
        for (int i = 0; i &lt; 26; i++)
            kind += e[i], last[i] = -1;
        for (int i = 0; i &lt; len; i++) {
            if (last[s[i] - 'a'] != -1) {
                if (i - last[s[i] - 'a'] != kind) {
                    puts(&quot;NO&quot;);
                    goto end;
                }
            }
            last[s[i] - 'a'] = i;
        }
        puts(&quot;YES&quot;);
        end: continue;
    }
    return 0;
}
</code></pre>
<hr />
<h2><a id="1673c-palindrome-basis" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1673C Palindrome Basis</h2>
<p><tc><m>Medium- *1500</m><t>背包</t><t>DP</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>考虑设 \(f(i,j)\) 为在前 \(i\) 个回文数中（第 \(i\) 个为 \(p_i\)），凑出来数 \(n\) 的方案数。则有：</p>
\[f(i,j)=f(i-1,j)+f(i,j-p_i)
\]
<p>考虑省去一维。</p>
\[f(j)\gets f(j)+f(j-p_i)
\]
<p>\(f(0)=1\)。</p>
<p>关于循环顺序：两维的时候你爱咋地咋地，但一维的时候省去了 \(i\) 这维，所以大前提就是在虚拟遍历 \(i\) 只不过没在转移方程里体现出来，\(i\) 必须放在外层，否则就会对 \(f(j)\) 的值产生影响。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">signed main() {
    T = read(); f[0] = 1;
    for (int k = 0; k &lt; P; ++k)
        for (int i = p[k]; i &lt;= 50000; ++i)
            f[i] = (f[i] + f[i - p[k]]) % MOD;
    while (T--)
        printf(&quot;%lld\n&quot;, f[read()]);
}
</code></pre>
<hr />
<h2><a id="1673d-lost-arithmetic-progression" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1673D Lost Arithmetic Progression</h2>
<p><tc><m>Medium+ *1900</m><t>数学</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>由题意直接得出：由公差为 \(d_0,d_1\) 的两个等差数列合成的新等差数列的公差必定为 \(d'=\operatorname{lcm}(d_0,d_1)\)，也就是说 \(d_0 \mid d'\)，\(d_1 \mid d'\)。设这三个等差数列的数的集合分别为 \(A,B,C\)，则 \(A \in C\)，\(B \in C\)。</p>
<p>无解的情况很方便判断，即 \(\exists x \in C\) 满足 \(x\notin B\)，即满足以下条件之一：</p>
<ul>
<li>\(d_B \not\mid d_C\)</li>
<li>\(C_1 \notin B\) 或 \(C_n \notin B\)</li>
</ul>
<p>接下来看有几个解。乍一看好像都是无数个解，但由于 \(A \cap B\) 中不能有 \(C\) 以外的元素，所以 \(A\) 只能在 \(C\) 限定的范围内蠕动，<strong>不得在 \(C\) 之外与 \(B\) 有交点</strong>。而 \(A\) 与 \(B\) 在 \(C\) 左侧第一个交点显然是 \(C_0\) 即 \(C_1-d_C\)（如果 \(B\) 的左端点大于这个那么 \(A\) 可以向左无限延长，无数个解），中间（从 \(C_0+1\) 到 \(C_1\)）放得下的 \(A\) 的个数显然是 \(\dfrac {d_C} {d_A}\)，\(C\) 右侧同理。因此，对于每一个 \(d_A\) 使得 \(\operatorname{lcm}(d_A,d_B)=d_C\)，答案为 \(\left(\dfrac {d_C} {d_A}\right)^2\)。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">#define int __int128
#define MOD 1000000007

int T;
struct AP {
    int s, d, n;
    int get(int i) { return (i - 1) * d + s; }
    int last() { return get(n); }
    bool in(int x) {
        if (s &lt;= x &amp;&amp; x &lt;= last() &amp;&amp; (x - s) % d == 0) return true;
        else return false;
    }
} b, c;

int gcd(int a, int b) {
    return a % b ? gcd(b, a % b) : b;
}
int lcm(int a, int b) {
    return a / gcd(a, b) * b;
}

signed main() {
    T = read();
    while (T--) {
        b.s = read(), b.d = read(), b.n = read();
        c.s = read(), c.d = read(), c.n = read();
        if (c.d % b.d || !b.in(c.s) || !b.in(c.last()))
            puts(&quot;0&quot;);
        else if (b.s &gt; c.get(0) || b.last() &lt; c.get(c.n + 1))
            puts(&quot;-1&quot;);
        else {
            int ans = 0;
            for (int x = 1; x * x &lt;= c.d; ++x) {
                if (lcm(x, b.d) == c.d)
                    ans = (ans + (c.d / x) * (c.d / x)) % MOD;
                if (x * x != c.d &amp;&amp; lcm(c.d / x, b.d) == c.d)
                    ans = (ans + x * x) % MOD;
            }
            printf(&quot;%lld\n&quot;, (long long)ans);
        }
    }
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x113 单调栈]]></title>
    <link href="oi.afobject.ml/0x113.html"/>
    <updated>2022-04-27T21:35:55+08:00</updated>
    <id>oi.afobject.ml/0x113.html</id>
    <content type="html"><![CDATA[
<h2><a id="largest-rectangle-in-a-histogram" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Largest Rectangle in a Histogram</h2>
<p><tc><c>0x1104</c><e>Easy+</e><t>单调栈</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>考虑对于每一个 \(x\) 坐标，都尝试找出以它为右边界的最大的矩形的面积。那么可能成为答案的矩形在左侧一定终止于在它左侧，且比它矮的一个位置。所以在它左侧，且比它高的东西没有用，直接用单调栈扔掉就行。</p>
<p>在原位置在 \(i\) 的一个数 \(k\) 在位置 \(j\) 时被推出栈的时候统计答案，答案为 \((j-i+d(k))\times k\)，其中 \(d(k)\) 代表这个数 \(k\) 顶掉的数的个数（即不在栈中，但可以算进矩形的宽的数，包括直接顶掉和间接顶掉）。在整个数列末尾追加一个 0，顶掉所有数。</p>
<p>按照书上做法，其实也可以把被顶掉的压一压高度，栈内宽度不变，这样就不用分「直接顶掉」和「间接顶掉」了，不过差不多。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n, a;
std::stack&lt;std::pair&lt;int, int&gt;&gt; s;
int d[1000001];

int main() {
    while (true) {
        n = read();
        if (!n) break;
        for (int i = 1; i &lt;= n; ++i) d[i] = 0;
        while (s.size()) s.pop();
        long long ans = 0;
        for (int i = 1; i &lt;= n + 1; i++) {
            a = (i &lt;= n) ? read() : 0;
            while (s.size() &amp;&amp; s.top().second &gt; a) {
                const int u = s.top().first, h = s.top().second;
                ans = std::max(ans, (long long)(i - u + d[u]) * h), d[i] += d[u] + 1;
                s.pop();
            }
            s.push({i, a});
        }
        printf(&quot;%lld\n&quot;, ans);
    }
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x112 表达式求值]]></title>
    <link href="oi.afobject.ml/0x112.html"/>
    <updated>2022-04-27T08:36:45+08:00</updated>
    <id>oi.afobject.ml/0x112.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E4%B8%BA%E5%90%8E%E7%BC%80%E6%B1%82%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>中缀表达式转为后缀求值</h2>
<p>首先举个例子：</p>
<p>中缀：<code>3 * (1 - 2)</code><br />
后缀：<code>3 1 2 - *</code></p>
<p>所有数的顺序肯定是一样的，然后就是运算符的问题（不管括号），同一优先级的情况下（如 <code>1 + 1 - 4</code> \(\to\) <code>1 1 4 - +</code>）就可以把运算符倒序输出，如果非同一优先级（如 <code>5 * 1 + 4</code> \(\to\) <code>5 1 * 4 +</code>），那就在一个运算符入栈的同时，看一下有没有比它优先级高的在栈里，如果有，顶掉输出。</p>
<p>现在考虑括号问题，括号内当一个子问题求解就行了（碰到一个右括号就把左括号及之后的所有内容输出，有点像递归的栈的写法）。</p>
<pre class="line-numbers"><code class="language-cpp">std::string s;
std::stack&lt;char&gt; st;
int priority[151];

int type[100001], n = 0;
double m[100001]; char o[100001];
std::stack&lt;double&gt; h;

int main() {
    std::cin &gt;&gt; s;
    s = '(' + s + ')';

    priority['*'] = priority['/'] = 2;
    priority['+'] = priority['-'] = 1;
    priority[')'] = 3; priority['('] = 0;

    double num = 0.0; bool flag = false;
    for (char x : s) {
        if (x &gt;= '0' &amp;&amp; x &lt;= '9') {
            flag = true;
            num *= 10, num += x - '0';
        } else {
            if (flag)
                type[++n] = 1, m[n] = num,
                num = 0, flag = false;
            if (x == ')')  {
                while (st.top() != '(')
                    type[++n] = 2, o[n] = st.top(), st.pop();
                st.pop();
                continue;
            } else if (x != '(') {
                while (st.size() &amp;&amp; priority[st.top()] &gt;= priority[x])
                    type[++n] = 2, o[n] = st.top(), st.pop();
            }
            st.push(x);
        }
    }

    for (int i = 1; i &lt;= n; ++i) {
        if (type[i] == 1) {
            h.push(m[i]);
        } else {
            double rhs = h.top(); h.pop();
            double lhs = h.top(); h.pop();
            if (o[i] == '+') h.push(lhs + rhs);
            if (o[i] == '-') h.push(lhs - rhs);
            if (o[i] == '*') h.push(lhs * rhs);
            if (o[i] == '/') h.push(lhs / rhs);
        }
    }

    std::cout &lt;&lt; h.top() &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<h2><a id="%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E9%80%92%E5%BD%92%E6%B3%95%E6%B1%82%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>中缀表达式的递归法求值</h2>
<p>这个比较简单好写，但时间复杂度是平方的。</p>
<pre class="line-numbers"><code class="language-cpp">std::string s;

double solve(int l, int r) {
    int add = -1, mul = -1, t = 0;
    for (int i = r; i &gt;= l; --i) {
        if (s[i] == ')') ++t;
        else if (s[i] == '(') --t;
        if (t == 0 &amp;&amp; add == -1 &amp;&amp; (s[i] == '+' || s[i] == '-'))
            add = i;
        if (t == 0 &amp;&amp; mul == -1 &amp;&amp; (s[i] == '*' || s[i] == '/'))
            mul = i;
    }
    if (add != -1) {
        if (s[add] == '+') return solve(l, add - 1) + solve(add + 1, r);
        else return solve(l, add - 1) - solve(add + 1, r);
    } else if (mul != -1) {
        if (s[mul] == '*') return solve(l, mul - 1) * solve(mul + 1, r);
        else return solve(l, mul - 1) / solve(mul + 1, r);
    } else if (s[l] == '(' &amp;&amp; s[r] == ')') {
        return solve(l + 1, r - 1);
    } else {
        double ans = 0;
        for (int i = l; i &lt;= r; i++) {
            ans *= 10;
            ans += s[i] - '0';
        }
        return ans;
    }
}

int main() {
    std::cin &gt;&gt; s;
    std::cout &lt;&lt; solve(0, s.size() - 1) &lt;&lt; std::endl;
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x111 栈基础]]></title>
    <link href="oi.afobject.ml/0x111.html"/>
    <updated>2022-04-25T08:20:03+08:00</updated>
    <id>oi.afobject.ml/0x111.html</id>
    <content type="html"><![CDATA[
<h2><a id="push-pop-getmin" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Push, Pop, GetMin</h2>
<p><tc><c>0x1101</c><e>Easy-</e><t>栈</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>维护两个栈，一个是题目中给出的栈，一个保存每个时刻最小值。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">class MinStack {
public:
    std::stack&lt;int&gt; o, m;
    MinStack() {}
    void push(int x) {
        o.push(x);
        if (m.size())
            m.push(std::min(m.top(), x));
        else
            m.push(x);
    }
    void pop() {
        o.pop();
        m.pop();
    }
    int top() {
        return o.top();
    }
    int getMin() {
        return m.top();
    }
};
</code></pre>
<hr />
<h2><a id="editor" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Editor</h2>
<p><tc><c>0x1102</c><e>Easy</e><t>栈</t><t>模拟</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>考虑建立对顶栈，这样前四种操作都可以实现。</p>
<p>对于第五种操作，可以再建立两个栈，一个保存所有时刻的前缀和，另一个用 0x1101 的方式维护最小值，只不过这里要用数组模拟栈（需要直接访问）。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>注意第一个数为负数时的处理。</p>
<pre class="line-numbers"><code class="language-cpp">int n;
std::stack&lt;int&gt; a, b;
int s[1000001], f[1000001], top;

void pushA(int t) {
    a.push(t);
    s[top + 1] = s[top] + t;
    if (top) f[top + 1] = std::max(f[top], s[top + 1]);
    else f[top + 1] = s[top + 1];
    ++top;
}

void popA() {
    a.pop();
    --top;
}

int main() {
    std::cin &gt;&gt; n;
    while (n--) {
        char c; int t;
        std::cin &gt;&gt; c;
        switch (c) {
            case 'I':
                std::cin &gt;&gt; t; pushA(t);
                break;
            case 'D':
                if (a.size()) popA();
                break;
            case 'L':
                if (a.size()) b.push(a.top()), popA();
                break;
            case 'R':
                if (b.size()) pushA(b.top()), b.pop();
                break;
            case 'Q':
                std::cin &gt;&gt; t;
                std::cout &lt;&lt; f[t] &lt;&lt; std::endl;
                break;
        }
    }
    return 0;
}
</code></pre>
<hr />
<h2><a id="%E8%BF%9B%E5%87%BA%E6%A0%88%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>进出栈序列问题</h2>
<p><tc><c>0x1103</c><m>Medium</m><t>栈</t><t>数学</t><t>DP</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%951" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法 1</h3>
<p>\(O(n^2)\)。</p>
<p>设 \(f(k)\) 为 \(n=k\) 时的答案。显然，\(f(0)=f(1)=1,f(2)=2\)。</p>
<p>假设最后一个出栈的选手是 \(k\)。一个数入栈时，栈里不可能有比它还大的数，如果想要压着 \(k\) 留到最后一个出栈，那必须把比它小的先踢掉，让它到栈底。因此在它之前入栈的共有 \(f(k-1)\) 种排列方式，跳过它，比它大的共有 \(f(n-k)\) 种方式。总方案数是</p>
\[\sum_{k=1}^nf(k-1) \cdot f(n-k)
\]
<p>这样的拆分是可行的。同样，也可以分析 \(1\) 来得到这个结论。</p>
<h3><a id="%E7%AE%97%E6%B3%952" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法 2</h3>
<p>\(O(n^2)\)。</p>
<p>设 \(f(i,j)\) 为其中出了 \(i\) 个，还有 \(j\) 个没出的方案数。目标状态为 \(f(n,0)\)。</p>
<p>每一步要么弹入一个，要么弹出栈顶。</p>
\[f(i,j)=f(i-1,j+1)+f(i,j-1)
\]
<h3><a id="%E7%AE%97%E6%B3%953" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法 3</h3>
<p>这玩意就是卡特兰数。</p>
\[Cat_n=\dfrac{2n \choose n}{n+1}
\]
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>贺就完了。</p>
<pre class="line-numbers"><code class="language-python">from math import factorial
n = int(input())
a = factorial(2 * n)
b = factorial(n)
print(a // b // b // (n + 1))
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ABC249]]></title>
    <link href="oi.afobject.ml/abc249.html"/>
    <updated>2022-04-23T20:54:17+08:00</updated>
    <id>oi.afobject.ml/abc249.html</id>
    <content type="html"><![CDATA[
<p>为什么每次打 ABC 都碰上蓝色的 E（恼）</p>
<p>Rated, 4/8, 977 \(\to\) 987</p>
<span id="more"></span><!-- more -->
<h2><a id="d-index-trio" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>D Index Trio</h2>
<p><tc><m>Medium- *983</m><t>数论</t><t>组合</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%951" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法 1</h3>
<p>从乘积出发。</p>
<p>考虑对于每一个数，根号复杂度分解质因数。如果分到的恰好都是数列里的数，则答案加上两边出现次数的乘积再乘以二。有一些小细节。</p>
<h3><a id="%E7%AE%97%E6%B3%952" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法 2</h3>
<p>从乘数出发。</p>
<p>在记录每个数的出现次数后，对于每对 \((i,j)\)，答案直接加上 \(c_i \cdot c_j \cdot c_{i \times j}\)。时间复杂度能过。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>（算法 1）</p>
<pre class="line-numbers"><code class="language-cpp">#define int long long

int n;
int b[1000001];

signed main() {
    n = read();
    for (int i = 1; i &lt;= n; i++)
        ++b[read()];
    int ans = 0;
    for (int i = 1; i &lt;= 200000; i++) {
        if (!b[i]) continue;
        for (int x = 1; x * x &lt;= i; ++x)
            if (i % x == 0)
                if (b[x] &amp;&amp; b[i / x]) {
                    if (x * x == i) ans += b[i] * b[x] * b[x];
                    else ans += b[i] * b[x] * b[i / x] * 2;
                }
    }
    printf(&quot;%lld\n&quot;, ans);
    return 0;
}
</code></pre>
<hr />
<h2><a id="f-ignore-operations" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>F Ignore Operations</h2>
<p><tc><m>Medium *1786</m><t>堆</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>考虑一下如果一定要删一个操作，那么肯定是看一下删哪个对最终的结果最好。如果该操作后面有替换操作，那么屁用没有；否则对最终答案的贡献就是进行到那一步和前一步操作后的结果差。</p>
<p>那如果一定要删两个呢？</p>
<p>在替换操作前面删屁用没有。所以要么在这之后选 \(y\) 最小的两个修改操作，要么就干脆直接把这个替换操作删了。所以有三种：</p>
<ul>
<li>在最后一个替换操作后面选两个 \(y\) 最小的删；</li>
<li>删了最后一个替换操作，然后在倒数第二个后面选一个最小的删；</li>
<li>直接删掉最后两个替换操作。</li>
</ul>
<p>扩展到选 \(k\) 个删，且没必要删完：</p>
<ul>
<li>在最后一个替换操作后面选至多 \(k\) 个 \(y\) 最小且为负的删；</li>
<li>删了最后一个替换操作，然后在倒数第二个后面选至多 \(k-1\) 个最小且为负的删；</li>
<li>……</li>
<li>把最后 \(k\) 个替换操作全删了（如果有）。</li>
</ul>
<p>在以上 \(k+1\) 种答案中选一个最小的即可。到这里时间复杂度为 \(O(n \log n + k^2)\)，不太行。</p>
<p>接下来考虑怎么更高效地维护信息。可以从后往前，动态维护所有修改操作 \(y\) 的前 \(k\) 小，并维护这个顺序，碰到一个替换操作的时候就可以计算出一种可能的答案了。</p>
<p>设两个相邻的替换操作在 \(i,j\) 这两个位置，并且我已经在 \((j,n]\) 范围内的修改操作中找到了删去最优的 \(k\) 个的和。我现在要找 \((i,n]\) 范围内最优 \(k-1\) 个的和。这个相对比较容易，首先先踢出去一个，然后优先队列（大根堆）维护就行了（同时另外维护一个总和），在 \((i,j)\) 的修改操作中碰到有比优先队列中相对最不优的那个更优的，把它顶掉就行了。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n, k;
std::stack&lt;int&gt; rep;
std::priority_queue&lt;long long&gt; q;
long long t[200005], y[200005];
long long suf[200005];

int main() {
    n = read(), k = read();
    rep.push(0);
    for (int i = 1; i &lt;= n; i++) {
        t[i] = read(), y[i] = read();
        if (t[i] == 1)
            rep.push(i);
    }

    for (int i = n; i; --i)
        if (t[i] == 2)
            suf[i] = suf[i + 1] + y[i];
        else
            suf[i] = suf[i + 1];

    int now, last = n;
    long long sum = 0, ans = -1e18;
    do {
        now = rep.top() + 1;
        rep.pop();
        for (int i = now; i &lt;= last; ++i)
            if (t[i] == 2 &amp;&amp; y[i] &lt; 0) {
                if (q.size() &lt; k) {
                    sum += y[i];
                    q.push(y[i]);
                } else if (k &amp;&amp; q.top() &gt; y[i]) {
                    sum += y[i] - q.top();
                    q.pop();
                    q.push(y[i]);
                }
            }
        ans = std::max(ans, y[now - 1] + suf[now] - sum);
        last = now - 2;
        if (k &amp;&amp; q.size() == k) sum -= q.top(), q.pop();
        --k;
    } while (k &gt;= 0 &amp;&amp; rep.size());

    printf(&quot;%lld\n&quot;, ans);
    return 0;
}
</code></pre>
<hr />
<h2><a id="e-rle" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>E RLE</h2>
<p><tc><m>Medium+ *1970</m><t>DP</t><t>前缀和</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>设 \(f(i,j)\) 为原长为 \(i\)，压缩后长为 \(j\) 的个数。</p>
<p>接下来考虑转移。首先假如连续段长度都只有个位数，则</p>
\[f(i,j)=\sum_{k=1}^9 f(i-k,j-2)
\]
<p>扩展：</p>
\[\begin{aligned}
f(i,j)&amp;=\sum_{k=1}^i f(i-k,j-\lfloor\log_{10}(k)\rfloor-1)
\end{aligned}
\]
<p>\(k\) 从 \(1\) 到 \(i\) 的遍历相当于逐个尝试这个字符串最后连续相同字符的个数。</p>
<p>但上面这个方程不完全对，还要考虑到每个字符都不一样，转移时都要乘上系数 \(25\)。</p>
<p>但是这样的效率还是不够高，我们考虑对于 \(f\) 的每一行进行一个前缀和，由于 \(i,j\) 显然最多只是四位数，状态转移方程变为：</p>
\[\begin{aligned}
f(i,j)&amp;=25 \cdot [ s(i-1,j-2)-s(i-10,j-2)\\
&amp;+s(i-10,j-3)-s(i-100,j-3)\\
&amp;+s(i-100,j-4)-s(i-1000,j-4)\\
&amp;+s(i-1000,j-5)-s(i-10000,j-5) ]
\end{aligned}
\]
<p>计数的时候从小到大对于每个 \(i\) 分别讨论，注意到当原长为 \(i\) 时，\(j\) 至少为 \(\lfloor \log_{10}(i)  \rfloor+1\)，因此初始值 \(f(i,\lfloor \log_{10}(i)\rfloor+1)=26\)，其余的直接 \(0\)，懒得考虑边界问题。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">long long n, p; // npk48
long long f[3005][3005], s[3005][3005];

int len(int x) {
    if (x &lt; 10) return 2;
    if (x &lt; 100) return 3;
    if (x &lt; 1000) return 4;
    return 5;
}

int main() {
    n = read(), p = read();
    for (int i = 1; i &lt;= n; ++i) {
        f[i][len(i)] = 26ll;
        for (int j = 1; j &lt; n; ++j) {
            f[i][j] = M(f[i][j] + 25ll * (s[T(i - 1)][T(j - 2)]     - s[T(i - 10)][T(j - 2)]));
            f[i][j] = M(f[i][j] + 25ll * (s[T(i - 10)][T(j - 3)]    - s[T(i - 100)][T(j - 3)]));
            f[i][j] = M(f[i][j] + 25ll * (s[T(i - 100)][T(j - 4)]   - s[T(i - 1000)][T(j - 4)]));
            f[i][j] = M(f[i][j] + 25ll * (s[T(i - 1000)][T(j - 5)]  - s[T(i - 3001)][T(j - 5)]));
            s[i][j] = M(s[i - 1][j] + f[i][j]);
        }
    }
    long long ans = 0;
    for (int i = 1; i &lt; n; ++i)
        ans = M(ans + f[n][i]);
    printf(&quot;%lld\n&quot;, ans);
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x00 索引]]></title>
    <link href="oi.afobject.ml/0x00-.html"/>
    <updated>2022-04-23T11:01:36+08:00</updated>
    <id>oi.afobject.ml/0x00-.html</id>
    <content type="html"><![CDATA[
<h2><a id="0x01" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>0x01</h2>
<table>
<thead>
<tr>
<th>题目</th>
<th>一句话题解</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x0101</td>
<td>快速幂板子，通过二进制拆分 \(b\) 证明结论。</td>
</tr>
<tr>
<td>0x0102</td>
<td>模拟。</td>
</tr>
<tr>
<td>0x0103</td>
<td>快速幂改快速乘。</td>
</tr>
<tr>
<td>0x0104</td>
<td>状压 DP 板子，设 \(f(i,u)\) 为经过的点集为 \(i\)，且当前点为 \(u\) 时的最短路长度，容易推出转移方程。</td>
</tr>
<tr>
<td>0x0105</td>
<td>从高到低对于每一位分别讨论，如果该位不确定，则在 \(m\) 的限制条件下尽量让它变成 1。</td>
</tr>
</tbody>
</table>
<h2><a id="0x02" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>0x02</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ABC248]]></title>
    <link href="oi.afobject.ml/abc248.html"/>
    <updated>2022-04-16T23:32:16+08:00</updated>
    <id>oi.afobject.ml/abc248.html</id>
    <content type="html"><![CDATA[
<p>VP</p>
<span id="more"></span><!-- more -->
<h2><a id="e-k-colinear-line" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>E K-colinear Line</h2>
<p><tc><m>Medium- *1292</m><t>计算几何</t><t>STL</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>主要问题在于如何精确、省力地表示一条直线。</p>
<p>对于过点 \((x_1,y_1),(x_2,y_2)\) 的直线，设其为 \(y=kx+b\)，则有 \(k=\dfrac{y_2-y_1}{x_2-x_1}\)，\(b=\dfrac{y_1x_2-y_2x_1}{x_2-x_1}\)。下面那个分母实在是太烦了，消掉，于是就变成了 \((x_2-x_1)y=(y_2-y_1)x+y_1x_2-y_2x_1\)。</p>
<p>于是可以用 \(x_2-x_1\)，\(y_2-y_1\)，\(y_1x_2-y_2x_1\) 这三个东西（全部除去 \(\gcd\)，且使 \(x_2-x_1\) 非负）来鉴定一条直线。可以使用 <code>std::tuple</code>。</p>
<p>这也正好解决了平行于 \(x\) 轴的直线的问题。</p>
<p>可以使用 <code>std::multiset</code> 维护信息。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">#define int long long

int n, k;
int x[301], y[301];

std::multiset&lt;std::tuple&lt;int, int, int&gt;&gt; m;
int t[90001];

auto line(int i, int j) {
    int a = x[i] - x[j];
    int b = y[i] - y[j];
    int c = x[j] * y[i] - x[i] * y[j];
    if (a &lt; 0) a = -a, b = -b, c = -c;
    const int g = gcd(a, gcd(b, c));
    a /= g, b /= g, c /= g;
    return std::make_tuple(a, b, c);
}

signed main() {
    n = read(), k = read();
    if (k == 1) return puts(&quot;Infinity&quot;), 0;
    for (int i = 1; i &lt;= n; ++i)
        x[i] = read(), y[i] = read();
    for (int i = 1; i &lt; n; ++i)
        for (int j = i + 1; j &lt;= n; ++j)
            m.insert(line(i, j));
    for (int i = 1; i &lt;= n; ++i)
        t[i * (i - 1) / 2] = i;
    int ans = 0;
    for (auto i = m.begin(); i != m.end(); i = m.upper_bound(*i))
        ans += (t[m.count(*i)] &gt;= k);
    printf(&quot;%lld\n&quot;, (int)ans);
    return 0;
}
</code></pre>
<hr />
<h2><a id="f-keep-connect" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>F Keep Connect</h2>
<p><tc><m>Medium+ *1828</m><t>DP</t><t>图论</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p><strong>考虑一个子图 \(G_k\)</strong>，它包含点 \((1,1),(1,2)\) 至 \((k,1),(k,2)\)。在 DP 进行过程中，它的 \((k-1,1) \to (k,1)\)，\((k,1) \to (k,2)\) 和 \((k-1,2) \to (k,2)\) 这三条边（分别叫做 \(a,b,c\) 边）未确定是否存在。</p>
<p><strong>考虑它在什么情况下才能让最终的图连通。</strong> 第一种是它本身连通；第二种是它有两个连通块，分别包含 \((k,1)\) 和 \((k,2)\)（注意一个点也算一个连通块！）。</p>
<p>接下来设计状态。\(f(k,j,s)\) 为 DP 进行到 \(G_k\) 时，已删了 \(j\) 条边，且连通状态为 \(s\)（\(s \in \{1,2\}\)）时的答案。</p>
<p>接下来考虑转移：</p>
<ol>
<li>从 1 转移到 1。这个时候可能的状态有：\((a,b),(b,c),(a,c),(a,b,c)\)，共 4 种。</li>
<li>从 2 转移到 2。可选择的只有 \((a,c)\)。</li>
<li>从 1 转移到 2。可以选择 \(a,c\)，2 种。</li>
<li>从 2 转移到 1。只能选择 \((a,b,c)\)。</li>
</ol>
<p>因此有：</p>
\[\begin{aligned}
f(k,j,1) &amp;= 3 \cdot f(k-1,j-1,1)+f(k-1,j,1)+f(k-1,j,2) \\
f(k,j,2) &amp;= f(k-1,j-1,2)+2 \cdot f(k-1,j-2,1)
\end{aligned}
\]
<p>最后考虑初始值。\(f(1,0,1)=f(1,1,2)=1\)。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">#define int long long

int n, p;
int f[3001][3001][3];

void add(int &amp;x, int d) {
    x = (x + d) % p;
}

signed main() {
    n = read(), p = read();
    f[1][0][1] = f[1][1][2] = 1;
    for (int i = 2; i &lt;= n; ++i) {
        for (int j = 0; j &lt; n; ++j) {
            if (j &gt;= 1) add(f[i][j][1], 3 * f[i - 1][j - 1][1]);
            add(f[i][j][1], f[i - 1][j][1] + f[i - 1][j][2]);
            if (j &gt;= 1) add(f[i][j][2], f[i - 1][j - 1][2]);
            if (j &gt;= 2) add(f[i][j][2], 2 * f[i - 1][j - 2][1]);
        }
    }
    for (int i = 1; i &lt; n; ++i)
        printf(&quot;%lld &quot;, f[n][i][1]);
    putchar('\n');
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2022 联合省选]]></title>
    <link href="oi.afobject.ml/shoi-2022.html"/>
    <updated>2022-04-10T20:58:03+08:00</updated>
    <id>oi.afobject.ml/shoi-2022.html</id>
    <content type="html"><![CDATA[
<p>我为什么敢来做省选？</p>
<span id="more"></span><!-- more -->
<h2><a id="d1t1-preprocessor" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>D1T1 Preprocessor</h2>
<p><tc><e>Easy+</e><t>模拟</t></tc></p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>纯纯的模拟，每一行分别处理。</p>
<p>处理「递归」是标准的 dfs。</p>
<pre class="line-numbers"><code class="language-cpp">#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

#define isId(x) (x &gt;= '0' &amp;&amp; x &lt;= '9' || x &gt;= 'a' &amp;&amp; x &lt;= 'z' || x &gt;= 'A' &amp;&amp; x &lt;= 'Z' || x == '_')

int n;
std::map&lt;std::string, std::string&gt; dict;
std::map&lt;std::string, bool&gt; state;

void tryReplace(std::string s);
void processText(std::string s) {
    std::string current;
    for (char x : s)
        if (isId(x))
            current += x;
        else {
            tryReplace(current);
            std::cout &lt;&lt; x;
            current = &quot;&quot;;
        }
    if (current.size())
        tryReplace(current);
}

void processPreprocessor(std::string s) {
    int pos1 = s.find(&quot; &quot;);
    auto command = s.substr(1, pos1 - 1);
    if (command == &quot;define&quot;) {
        int pos2 = s.find(&quot; &quot;, pos1 + 1);
        auto id = s.substr(pos1 + 1, pos2 - pos1 - 1),
             replacement = s.substr(pos2 + 1);
        dict[id] = replacement;
    } else {
        auto id = s.substr(pos1 + 1);
        dict.erase(dict.find(id));
    }
} 

int main() {
    std::cin &gt;&gt; n;
    std::string t;
    getline(std::cin, t);
    while (n--) {
        std::string line;
        getline(std::cin, line);
        if (line[0] == '#')
            processPreprocessor(line);
        else
            processText(line);
        std::cout &lt;&lt; std::endl;
    }
    return 0;
}

void tryReplace(std::string s) {
    if (dict.find(s) != dict.end()) {
        if (!state[s])
            state[s] = true, processText(dict[s]);
        else
            std::cout &lt;&lt; s;
        state[s] = false;
    } else
        std::cout &lt;&lt; s;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x0809 ~ 0x080C]]></title>
    <link href="oi.afobject.ml/0x08-3.html"/>
    <updated>2022-04-06T07:39:26+08:00</updated>
    <id>oi.afobject.ml/0x08-3.html</id>
    <content type="html"><![CDATA[
<h2><a id="number-base-conversion" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Number Base Conversion</h2>
<p><tc><c>0x0809</c><e>Easy+</e><t>高精</t><t>模拟</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>什么模拟题乱入，，，</p>
<p>考虑随便找个数模拟一下，\(964\) 转化 7 进制：</p>
\[\begin{aligned}
964 \div 7 &amp;= 137 &amp;\ldots 5 \\
137 \div 7 &amp;= 19 &amp;\ldots 4 \\
19 \div 7 &amp;= 2 &amp;\ldots 5 \\
2 \div 7 &amp;= 2 &amp;\ldots2 \\
(964)_{10}&amp;=(2545)_7
\end{aligned}
\]
<p>其实就是高精除低精，高精取模低精。</p>
<p>后面那个很容易，再看一下前者是怎么做的。</p>
\[\begin{aligned}
\underline 9 \div 7 &amp;= 1 &amp;\ldots 2 \\
\underline{26} \div 7 &amp;= 3 &amp;\ldots5 \\
\underline{54} \div 7&amp;=7 &amp;\ldots5
\end{aligned}
\]
<p>可以发现过程中有一个很重要的中间变量 \(k\)，也就是下划线的部分。它是计算过程中原数前若干位的十进制表示形式，只不过都及时按位模了 \(7\)。</p>
<p>……还说啥呢，可以开始写了。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int T, a, b;
char s[1000001], ans[1000001];

int to10(char x) {
    if (x &gt;= '0' &amp;&amp; x &lt;= '9') return x - '0';
    if (x &gt;= 'A' &amp;&amp; x &lt;= 'Z') return x - 'A' + 10;
    return x - 'a' + 36;
}
char from10(int x) {
    if (x &lt;= 9) return x + '0';
    if (x &lt;= 35) return x - 10 + 'A';
    return x - 36 + 'a';
}

int main() {
    scanf(&quot;%d&quot;, &amp;T);
    while (T--) {
        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
        scanf(&quot;%s&quot;, s);
        printf(&quot;%d %s\n%d &quot;, a, s, b);
        int len = strlen(s), t = 0, ansSize = 0;
        while (t &lt; len) {
            int k = 0;
            for (int i = t; i &lt; len; ++i) {
                k = k * a + to10(s[i]);
                s[i] = from10(k / b);
                k %= b;
            }
            ans[++ansSize] = from10(k);
            while (t &lt; len &amp;&amp; s[t] == '0') ++t;
        }
        for (int i = ansSize; i; --i)
            printf(&quot;%c&quot;, ans[i]);
        printf(&quot;\n\n&quot;);
    }
    return 0;
}
</code></pre>
<hr />
<h2><a id="cow-acrobats" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Cow Acrobats</h2>
<p><tc><c>0x080A</c><m>Medium-</m><t>贪心</t><t>数学</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>0x0704 改编版。</p>
<p>第 \(x\) 头奶牛的风险值为 \(a=\sum\limits_{i=1}^{x-1} w_i - s_x\)。第 \(x+1\) 头牛风险值为 \(b=\sum\limits_{i=1}^{x} w_i - s_{x+1}\)。</p>
<p>最后奶牛一定是按照某个顺序排列的，一旦打破这个顺序（交换），答案一定会增加。假设第 \(x\) 头牛与第 \(x+1\) 头牛交换。</p>
<p>此时，第 \(x\) 头牛的风险值为 \(c=\sum\limits_{i=1}^{x-1} w_i+w_{x+1}-s_x\)，第 \(x+1\) 头牛的风险值为 \(d=\sum\limits_{i=1}^{x-1} w_i-s_{x+1}\)。</p>
\[\begin{aligned}
\Delta=&amp;\max\{c,d\}-\max\{a,b\}\\
=&amp;\max\{w_{x+1}-s_x, -s_{x+1}\}-\max\{-s_x, w_x - s_{x+1}\}\text{   (统加 }\sum_{i=1}^{x-1}w_i\text{ )}\\
=&amp;\max\{w_{x+1}+s_{x+1}, s_x\}-\max\{s_{x+1}, w_x + s_x\}\text{   (统加 }s_x+s_{x+1}\text{ )}
\end{aligned}
\]
<p>好好好，当 \(w_x+s_x&gt;w_{x+1}+s_{x+1}\) 时，左边 \(s_x\) 再大也铁定大不了 \(w_x+s_x\)，\(\Delta&lt;0\)，交换更优。</p>
<p>当 \(w_x+s_x &lt; w_{x+1}+s_{x+1}\) 时，同理，\(\Delta&gt;0\)，不交换更优。</p>
<p>因此，按 \(w_i+s_i\) 从小到大排序最优。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n;
struct Cow {
    int w, s;
    bool operator &lt; (const Cow &amp;rhs) const {
        return w + s &lt; rhs.w + rhs.s;
    }
} c[1000001];

int main() {
    n = read();
    for (int i = 1; i &lt;= n; ++i)
        c[i].w = read(), c[i].s = read();
    std::sort(c + 1, c + n + 1);
    int ans = -1e9, p = 0;
    for (int i = 1; i &lt;= n; ++i) {
        ans = std::max(ans, p - c[i].s);
        p += c[i].w;
    }
    printf(&quot;%d\n&quot;, ans);
    return 0;
}
</code></pre>
<hr />
<h2><a id="to-the-max" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>To The Max</h2>
<p><tc><c>0x080B</c><e>Easy</e><t>贪心</t><t>前缀和</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>考虑从一维的最大子段和转移。不就多了一个维度吗。</p>
<p>枚举矩形的上底和下底就行了。</p>
<p>时间复杂度 \(O(n^3)\)。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n;
int s[101][101];

int main() {
    n = read();
    for (int i = 1; i &lt;= n; ++i)
        for (int j = 1; j &lt;= n; ++j)
            s[i][j] = read() + s[i][j - 1];
    int ans = -1e9;
    for (int i = 1; i &lt;= n; ++i)
        for (int j = i; j &lt;= n; ++j) {
            int max = -1e9, cur = 0;
            for (int k = 1; k &lt;= n; ++k) {
                cur += s[k][j] - s[k][i - 1];
                max = std::max(max, cur);
                cur = std::max(cur, 0);
            }
            ans = std::max(ans, max);
        }
    printf(&quot;%d\n&quot;, ans);
    return 0;
}
</code></pre>
<hr />
<h2><a id="task" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Task</h2>
<p><tc><c>0x080C</c><m>Medium-</m><t>贪心</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>Ref: 0x0701</p>
<p>考虑对于每个任务以 \(x\) 为第一关键字、\(y\) 为第二关键字从大到小排序，优先保证上面的任务。</p>
<p>对于每个任务，选用 \(x,y\) 均满足要求且 \(y\) 最小的机器。这样确保对于接下来处理的任务，\(x\) 的要求都能满足，且 \(y\) 的要求也尽量能满足。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>考虑使用 <code>std::multiset</code> 维护信息。每次将 \(x\) 满足要求的取出并放入 <code>std::multiset</code> 里，用 <code>lower_bound</code> 查询符合要求且最小的 \(y\)。</p>
<pre class="line-numbers"><code class="language-cpp">int n, m;
std::pair&lt;int, int&gt; a[100001], b[100001];
std::multiset&lt;int&gt; s;

int main() {
    while (std::cin &gt;&gt; n &gt;&gt; m) {
        s.clear();
        for (int i = 1; i &lt;= n; ++i)
            std::cin &gt;&gt; a[i].first &gt;&gt; a[i].second;
        for (int i = 1; i &lt;= m; ++i)
            std::cin &gt;&gt; b[i].first &gt;&gt; b[i].second;
        std::sort(a + 1, a + n + 1);
        std::sort(b + 1, b + m + 1);
        int j = n, cnt = 0; long long ans = 0;
        for (int i = m; i; --i) {
            while (j &amp;&amp; a[j].first &gt;= b[i].first)
                s.insert(a[j--].second);
            auto it = s.lower_bound(b[i].second);
            if (it != s.end()) {
                ++cnt;
                ans += b[i].first * 500ll + b[i].second * 2;
                s.erase(it);
            }
        }
        std::cout &lt;&lt; cnt &lt;&lt; ' ' &lt;&lt; ans &lt;&lt; std::endl;
    }
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x0805 ~ 0x0808]]></title>
    <link href="oi.afobject.ml/0x08-2.html"/>
    <updated>2022-04-04T22:22:36+08:00</updated>
    <id>oi.afobject.ml/0x08-2.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E9%98%B2%E7%BA%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>防线</h2>
<p><tc><c>0x0805</c><e>Easy</e><t>二分</t><t>前缀和</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>《人工 h1》<strong>最多只有一个事奇数的位置！</strong>《/人工 h1》</p>
<p>所以直接二分出第一个出现前缀和为奇数的位置就好了。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>样例搞偷袭不讲武德！!1</p>
<pre class="line-numbers"><code class="language-cpp">#define int long long

int T, n;
int s[200001], e[200001], d[200001];

int upper(int x, int y) {
    if (x % y) return x / y + 1;
    else return x / y;
}

int sum(int x) {
    if (x &lt; 0) return 0;
    int ans = 0;
    for (int i = 1; i &lt;= n; ++i)
        if (s[i] &lt;= x)
            ans += upper(std::min(e[i], x) - s[i] + 1, d[i]);
    return ans;
}

signed main() {
    T = read();
    while (T--) {
        n = read();
        for (int i = 1; i &lt;= n; ++i)
            s[i] = read(), e[i] = read(), d[i] = read();
        int l = 0, r = 1ll &lt;&lt; 31;
        while (l &lt; r) {
            const int mid = (l + r) &gt;&gt; 1;
            if (sum(mid) &amp; 1) r = mid;
            else l = mid + 1;
        }
        if (l == 1ll &lt;&lt; 31) puts(&quot;There's no weakness.&quot;);
        else printf(&quot;%lld %lld\n&quot;, l, sum(l) - sum(l - 1));
    }
    return 0;
}
</code></pre>
<hr />
<h2><a id="corral-the-cows" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Corral the Cows</h2>
<p><tc><c>0x0806</c><c>USACO</c><e>Easy+</e><t>二分</t><t>前缀和</t><t>离散化</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>由于 \(n\) 极小，考虑离散化。</p>
<p>离散化完了以后照样二分就完了。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>注意：</p>
<ol>
<li>处理重合的点；</li>
<li>边界情况。</li>
</ol>
<pre class="line-numbers"><code class="language-cpp">int n, c;
int x[501], y[501];
int a[501], b[501];
int sizeA, sizeB;
int x1[501], y1[501];
int g[501][501];

int xid(int x) {
    return std::lower_bound(a + 1, a + sizeA, x) - a;
}
int yid(int y) {
    return std::lower_bound(b + 1, b + sizeB, y) - b;
}

bool check(int d) {
    for (int a2 = 1; a2 &lt; sizeA; ++a2)
        for (int b2 = 1; b2 &lt; sizeB; ++b2) {
            const int a1 = xid(x1[a2] - d + 1),
                      b1 = yid(y1[b2] - d + 1);
            const int sum = g[a2][b2] - g[a1 - 1][b2] - g[a2][b1 - 1] + g[a1 - 1][b1 - 1];
            if (sum &gt;= c)
                return true;
        }
    return false;
}

int main() {
    c = read(), n = read();
    for (int i = 1; i &lt;= n; ++i) {
        x[i] = a[i] = read();
        y[i] = b[i] = read();
    }

    std::sort(a + 1, a + n + 1);
    std::sort(b + 1, b + n + 1);
    sizeA = std::unique(a + 1, a + n + 1) - a;
    sizeB = std::unique(b + 1, b + n + 1) - b;
    for (int i = 1; i &lt;= n; ++i) {
        const int p = xid(x[i]), q = yid(y[i]);
        x1[p] = x[i], y1[q] = y[i];
        ++g[p][q];
    }
    for (int i = 1; i &lt;= n; ++i)
        for (int j = 1; j &lt;= n; ++j)
            g[i][j] += g[i - 1][j] + g[i][j - 1] - g[i - 1][j - 1];

    int l = 1, r = 1e5;
    while (l &lt; r) {
        const int mid = (l + r) &gt;&gt; 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    printf(&quot;%d\n&quot;, l);
    return 0;
}
</code></pre>
<hr />
<h2><a id="%E7%B3%96%E6%9E%9C%E4%BC%A0%E9%80%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>糖果传递</h2>
<p><tc><c>0x0807</c><c>HAOI 2008</c><e>Easy+</e><t>前缀和</t><t>数学</t><t>环上问题</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>0x0503 简化版，这里重新推导一遍，思路可能不同。</p>
<p>先破环成链。假如在 \(a_1\) 与 \(a_n\) 之间断开。</p>
<p>要让 \(a_1\) 达到 \(\overline{a}\)，则需要 \(a_2\) 提供它 \(\overline{a}-a_1\)（不管正负），贡献增加 \(\mid\overline{a}-a_1\mid\)。</p>
<p>此时 \(a_2 \gets a_1 + a_2 - \overline{a}\)。想让 \(a_2\) 达到 \(\overline{a}\)，那么就要 \(a_3\) 给它 \(\overline{a}-(a_1+a_2-\overline{a})=2\cdot\overline{a}-(a_1+a_2)\)，贡献增加 \(\mid2\cdot\overline{a}-(a_1+a_2)\mid\)。</p>
<p>可以发现，总答案为</p>
\[\sum_{i=1}^n\left|i \cdot \overline{a}-\sum_{j=1}^ia_j\right|
\]
<p>假如双倍一下，进一步推广，破环破在 \(a_{k+1}\) 与 \(a_k\) 之间的，总答案为</p>
\[\sum_{i=1}^{n}\left|i \cdot \overline{a}-\sum_{j=k+1}^{i+k}a_j\right|
\]
<p>设前缀和数组为 \(s\)，即 \(s_i = \sum\limits_{j=1}^ia_j\)。</p>
<p>答案变形为</p>
\[\sum_{i=1}^{n}\left|i \cdot \overline{a}-s_{i+k}+s_{k}\right|
\]
<p>前面那个东西实在是不顺眼，所以我们让 \(a_i \gets a_i-\overline{a}\) 再计算前缀和 \(s\)，答案变形为：</p>
\[\sum_{i=1}^{n}\left|s_{k}-s_{i+k}\right|
\]
<p>\(s_k\) 定，考虑到 \(s_n=0\)，而因为珈贝了，我们这里的前缀和 \(s\) 的值域是 \(2n\)，\(s_{n+j}=s_{j}\)，所以式子里的 \(s_{i+k}\) 可以取到 \(s_1 \sim s_n\) 的任何值，所以答案也就是</p>
\[\sum_{i=1}^{n}\left|s_{k}-s_i\right|
\]
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">#define int long long
#define abs(x) ((x) &gt; 0 ? (x) : -(x))

int n;
int a[1000001], s[1000001];

signed main() {
    n = read();
    int sum = 0;
    for (int i = 1; i &lt;= n; ++i)
        a[i] = read(), sum += a[i];
    const int aver = sum / n;
    for (int i = 1; i &lt;= n; ++i)
        s[i] = s[i - 1] + a[i] - aver;
    std::sort(s + 1, s + n + 1);
    int ans = 0;
    for (int i = 1; i &lt;= n; ++i)
        ans += abs(s[(n + 1) &gt;&gt; 1] - s[i]);
    printf(&quot;%lld\n&quot;, ans);
    return 0;
}
</code></pre>
<hr />
<h2><a id="soldiers" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Soldiers</h2>
<p><tc><c>0x0808</c><m>Medium-</m><t>数学</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>纵坐标移到中位数容易证明，接下来考虑横坐标。</p>
<p>首先证明一个事：按 \(x\) 坐标排序后，每个点的顺序与最终结果相同。</p>
<blockquote>
<h4><a id="%E8%AF%81%E6%98%8E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>证明</h4>
<p>若交换一组 \((i,j)\)（\(x_i&gt;x_j\) 且 \(a_i&gt;a_j\)）那么答案将减少 \(\Delta=\mid x_i - a_i \mid + \mid  x_j - a_j \mid - \mid x_i - a_j \mid - \mid x_j - a_i \mid\)</p>
<ul>
<li>
<p>若 \(x_j &gt; a_i\) 或 \(x_i &lt; a_j\)：\(\Delta=0\)</p>
</li>
<li>
<p>若 \(a_j&lt;x_j&lt;a_i&lt;x_i\)：\(\Delta=x_i-a_i+x_j-a_j-x_i+a_j+x_j-a_i=2\cdot x_j-2\cdot a_i&lt;0\)</p>
</li>
<li>
<p>若 \(a_j&lt;x_j&lt;x_i&lt;a_i\)：\(\Delta=a_i-x_i+x_j-a_j-x_i+a_j+x_j-a_i=2\cdot x_j-2\cdot x_i&lt;0\)</p>
</li>
<li>
<p>若 \(x_j&lt;a_j&lt;x_i&lt;a_i\)：\(\Delta=a_i-x_i+a_j-x_j-x_i+a_j+x_j-a_i=2\cdot a_j-2\cdot x_i&lt;0\)</p>
</li>
<li>
<p>若 \(x_j&lt;a_j&lt;a_i&lt;x_i\)：\(\Delta=x_i-a_i+a_j-x_j-x_i+a_j+x_j-a_i=2\cdot a_j-2\cdot a_i&lt;0\)</p>
</li>
</ul>
<p>所以是正确的。</p>
</blockquote>
<p>然后就容易了，因为本来 \(x\) 坐标很小或者很大的，到时候相对于其他点就一定可以少移动一点。所以先把这个东西消掉，因此这个时候就处理好，向最右边的看齐，从右到左第 \(i\) 个点的横坐标加上 \(i\)（也可以当成，向最左边的对齐，从左到右第 \(i\) 个点的横坐标减去 \(i\)）。</p>
<p>更理性一点，设最终移到 \( a+1, a+2, \ldots, a+n\)。那么第 \(i\) 个点的贡献是 \(\mid x_i-(a+i) \mid=\mid (x_i-i)-a \mid\)。所以 \(x_i \gets x_i-i\) 即可。</p>
<p>这个时候，就可以照常取中位数然后算答案了。管他上一步是加还是减，相对坐标差不变，答案不变就完了。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">#define abs(x) ((x) &gt; 0 ? (x) : -(x))

int n, x[10001], y[10001];

int main() {
    n = read();
    for (int i = 1; i &lt;= n; ++i)
        x[i] = read(), y[i] = read();
    std::sort(x + 1, x + n + 1);
    for (int i = 1; i &lt;= n; ++i)
        x[i] -= i;
    std::sort(y + 1, y + n + 1);
    std::sort(x + 1, x + n + 1);
    int ans = 0, x0 = x[(n + 1) &gt;&gt; 1], y0 = y[(n + 1) &gt;&gt; 1];
    for (int i = 1; i &lt;= n; ++i)
        ans += abs(x[i] - x0) + abs(y[i] - y0);
    printf(&quot;%d\n&quot;, ans);
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x0801 ~ 0x0804]]></title>
    <link href="oi.afobject.ml/0x08-1.html"/>
    <updated>2022-04-03T23:51:45+08:00</updated>
    <id>oi.afobject.ml/0x08-1.html</id>
    <content type="html"><![CDATA[
<h2><a id="the-pilots-brothers-refrigerator" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Pilots Brothers' Refrigerator</h2>
<p><tc><c>0x0801</c><e>Easy</e><t>状压</t><t>枚举</t><t>模拟</t></tc></p>
<p>给定一个 \(4\times4\) 的 0-1 矩阵，每次选择一个 \((i,j)\)，使得第 \(i\) 行、第 \(j\) 列上所有的数反转。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>枚举每一个位置是否反转，并模拟。时间复杂度 O(能过)。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">bool m[5][5], c[5][5];

int main() {
    for (int i = 1; i &lt;= 4; ++i)
        for (int j = 1; j &lt;= 4; ++j) {
            char q; std::cin &gt;&gt; q;
            m[i][j] = (q == '-');
        }
    int min = 17, minS = 0;
    for (int s = 0; s &lt; 1 &lt;&lt; 16; ++s) {
        memcpy(c, m, sizeof c);
        int cnt = 0;
        for (int i = 0; i &lt; 16; ++i)
            if (s &amp; (1 &lt;&lt; i)) {
                ++cnt;
                const int row = i / 4 + 1, col = i % 4 + 1;
                for (int j = 1; j &lt;= 4; ++j)
                    c[row][j] ^= 1;
                for (int j = 1; j &lt;= 4; ++j)
                    c[j][col] ^= 1;
                c[row][col] ^= 1;
            }
        bool sum = 1;
        for (int i = 1; i &lt;= 4; ++i)
            for (int j = 1; j &lt;= 4; ++j)
                sum &amp;= c[i][j];
        if (sum &amp;&amp; cnt &lt; min)
            min = cnt, minS = s;
    }
    printf(&quot;%d\n&quot;, min);
    for (int i = 0; i &lt; 16; ++i)
        if (minS &amp; (1 &lt;&lt; i))
            printf(&quot;%d %d\n&quot;, i / 4 + 1, i % 4 + 1);
    return 0;
}
</code></pre>
<hr />
<h2><a id="%E5%8D%A0%E5%8D%9Cdiy" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>占卜 DIY</h2>
<p><tc><c>0x0802</c><e>Easy</e><t>模拟</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>？？？？？？？</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">struct Node {
    int num;
    bool state;
};
std::deque&lt;Node&gt; q[14];

int trans(char c) {
    if (c &gt;= '2' &amp;&amp; c &lt;= '9')
        return c - '0';
    switch (c) {
        case '0': return 10;
        case 'J': return 11;
        case 'Q': return 12;
        case 'K': return 13;
        case 'A': return 1;
    }
    return 0;
}

int buc[14];

int main() {
    for (int i = 1; i &lt;= 13; ++i) {
        char c;
        for (int j = 1; j &lt;= 4; ++j) {
            std::cin &gt;&gt; c;
            // front 上，back 下。
            q[i].push_back({trans(c), false});
        }
    }
    while (q[13].size()) {
        auto current = q[13].front();
        q[13].pop_front();
        while (true) {
            const int t = current.num;
            if (t == 13)
                break;
            q[t].push_front({t, true});
            current = q[t].back();
            q[t].pop_back();
        }
    }
    for (int i = 1; i &lt;= 13; ++i)
        while (q[i].size())
            buc[q[i].front().num] += q[i].front().state,
            q[i].pop_front();
    int ans = 0;
    for (int i = 1; i &lt; 13; ++i)
        if (buc[i] == 4)
            ++ans;
    std::cout &lt;&lt; ans &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<hr />
<h2><a id="fractal" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Fractal</h2>
<p><tc><c>0x0803</c><e>Easy</e><t>模拟</t><t>分形</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>？？？？？？？</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">int n;
int pow3[1001];
char res[1001][1001];

void fractal(int x, int y, int level) {
    if (level == 1) {
        res[x][y] = 'X';
        return;
    }
    const int t = pow3[level - 2];
    fractal(x, y, level - 1);
    fractal(x + (t &lt;&lt; 1), y, level - 1);
    fractal(x, y + (t &lt;&lt; 1), level - 1);
    fractal(x + (t &lt;&lt; 1), y + (t &lt;&lt; 1), level - 1);
    fractal(x + t, y + t, level - 1);
}

int main() {
    pow3[0] = 1;
    for (int i = 1; i &lt;= 7; ++i)
        pow3[i] = pow3[i - 1] * 3;
    while (scanf(&quot;%d&quot;, &amp;n)) {
        if (n == -1)
            break;
        memset(res, ' ', sizeof res);
        fractal(1, 1, n);
        for (int i = 1; i &lt;= pow3[n - 1]; ++i) {
            for (int j = 1; j &lt;= pow3[n - 1]; ++j)
                printf(&quot;%c&quot;, res[i][j]);
            putchar('\n');
        }
        puts(&quot;-&quot;);
    }
    return 0;
}
</code></pre>
<hr />
<h2><a id="raid" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Raid</h2>
<p><tc><c>0x0804</c></tc></p>
<p>疑似只能用玄学算法卡过，最坏情况 \(n^2\)。。。先跳过了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NOI Online 2022 Junior]]></title>
    <link href="oi.afobject.ml/noiol-junior-2022.html"/>
    <updated>2022-03-27T16:14:49+08:00</updated>
    <id>oi.afobject.ml/noiol-junior-2022.html</id>
    <content type="html"><![CDATA[
<p>场外，不会做 T2。</p>
<span id="more"></span><!-- more -->
<h2><a id="%E6%95%B0%E5%AD%A6%E6%B8%B8%E6%88%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数学游戏</h2>
<p><tc><m>Medium+</m><t>数学</t><t>GCD</t></tc></p>
<p>对于每一组 \((x,z)\)，求最小的 \(y\)，使得 \(x \times y \times \gcd(x,y) = z\)。</p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>设 \(x = \gcd(x,y) \cdot a\)，\(y = \gcd(x,y)\cdot b\)。</p>
<p>则 \(\dfrac zx = \gcd(x,y) \cdot y = \gcd(x,y)^2 \cdot b\)。注意到 \(x^2=\gcd(x,y)^2 \cdot a^2\)，考虑消去没用的 \(a\)。</p>
<p>因为 \(a \perp b\)，所以 \(\gcd\left(\dfrac zx, x^2\right)=\gcd(x,y)^2\)。所以 \(\gcd(x,y) = \sqrt{\gcd\left(\dfrac zx, x^2\right)}\)。</p>
<p>所以 \(y = \dfrac z {x \cdot \sqrt{\gcd\left(\dfrac zx, x^2\right)}}\)。</p>
<p>没法用以上方法复原 \(y\) 的，均为无解。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<pre class="line-numbers"><code class="language-cpp">#define int long long

int t, x, z;

int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}

signed main() {
    t = read();
    while (t--) {
        x = read(), z = read();
        if (z % x) { puts(&quot;-1&quot;); continue; }
        const int k = z / x;
        const int g = gcd(x * x, k);
        const int rt = sqrt(g);
        if (rt * rt != g) { puts(&quot;-1&quot;); continue; }
        printf(&quot;%lld\n&quot;, z / (x * rt));
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NOI Online 2022 Senior]]></title>
    <link href="oi.afobject.ml/noiol-senior-2022.html"/>
    <updated>2022-03-26T16:46:05+08:00</updated>
    <id>oi.afobject.ml/noiol-senior-2022.html</id>
    <content type="html"><![CDATA[
<p>场外，口胡了 T1。</p>
<span id="more"></span><!-- more -->
<h2><a id="%E4%B8%B9%E9%92%93%E5%8D%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>丹钓占</h2>
<p><tc><m>Medium+</m><t>DS</t><t>树状数组</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<p>初步思考：对于第 \(i\) 个二元组，求出最左能使它优秀的端点 \(x_i\)，在这个端点及其右侧的任意一个位置，都能使它「优秀」。即开头模拟一遍预处理，每个二元组的 \(x\) 即为把该弹的都弹掉后栈顶的下标。</p>
<p>之后对于每一组询问，输出 \(\sum_{i=l}^r[l \ge x_i]\) 就行了。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h3>
<p>考虑将询问离线，按左端点从小到大排序。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0npr5t0lyj211h0u00v5.jpg" alt="" /></p>
<p>实现过程是这样的：</p>
<ol>
<li>模拟，记录 \(x\)；</li>
<li>将所有的询问按左端点从小到大排序，将 \(x\) 按从大到小的顺序依次压入一个栈（代码实现的时候随便什么东西维护一下就行，我懒，用了 <code>std::priority_queue</code>，还是因为我懒，所以用取相反数来达到小根堆的效果）中，栈顶为最小的 \(x\)；</li>
<li>对于每一个下标 \(i\)，维护一个叫做 \(d_i\) 的布尔值，代表当前 \(l\) 是否 \(\ge x_i\)；</li>
<li>遍历排序好的询问，对于每一次询问 \([l,r]\)：
<ol>
<li>将所有 \(\le l\) 的 \(x\) 从栈顶弹出，并将相应的 \(d\) 赋为 \(1\)；</li>
<li>通过树状数组求出 \(\sum_{i=l}^r d_i\)。</li>
</ol>
</li>
<li>按原顺序输出答案。</li>
</ol>
<pre class="line-numbers"><code class="language-cpp">struct Node {
    int l, r, id;
    bool operator &lt; (const Node &amp;rhs) const {
        if (l == rhs.l)
            return r &lt; rhs.r;
        return l &lt; rhs.l;
    }
};

int n, q;
int a[1000001], b[1000001];
int c[1000001];
Node e[1000001];
int ans[1000001];

void update(int idx) {
    while (idx &lt;= n)
        ++c[idx], idx += idx &amp; (-idx);
}
int query(int idx) {
    int ans = 0;
    while (idx)
        ans += c[idx], idx -= idx &amp; (-idx);
    return ans;
}

int main() {
    n = read(), q = read();
    for (int i = 1; i &lt;= n; ++i)
        a[i] = read();
    for (int i = 1; i &lt;= n; ++i)
        b[i] = read();

    std::stack&lt;Node&gt; s;
    std::priority_queue&lt;std::pair&lt;int, int&gt;&gt; p;
    for (int i = 1; i &lt;= n; ++i) {
        while (!s.empty() &amp;&amp; (s.top().l == a[i] || s.top().r &lt;= b[i]))
            s.pop();
        if (s.empty()) p.push({-1, i});
        else p.push({-s.top().id - 1, i});
        s.push({a[i], b[i], i});
    }

    for (int i = 1; i &lt;= q; ++i) {
        const int l = read(), r = read();
        e[i] = {l, r, i};
    }
    std::sort(e + 1, e + q + 1);
    for (int i = 1; i &lt;= q; ++i) {
        while (!p.empty() &amp;&amp; -p.top().first &lt;= e[i].l) {
            update(p.top().second);
            p.pop();
        }
        ans[e[i].id] = query(e[i].r) - query(e[i].l - 1);
    }

    for (int i = 1; i &lt;= q; ++i)
        printf(&quot;%d\n&quot;, ans[i]);
    return 0;
}
</code></pre>
<hr />
<h2><a id="%E8%AE%A8%E8%AE%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>讨论</h2>
<p><tc><m>Medium+</m><t>？</t><t>？</t></tc></p>
<h3><a id="%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法</h3>
<h4><a id="30%E5%88%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>30 分</h4>
<p><code>std::bitset</code> 暴力，\(O(Tn^3)\)。</p>

]]></content>
  </entry>
  
</feed>
